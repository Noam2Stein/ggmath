// This file was generated by an associated codegen crate.
// To modify this file, modify the source code of the associated codegen crate.

/// A trait to extend the functionality of primitive float types.
pub trait FloatExt {
    /// Linearly interpolates between `self` and `other` based on the interpolation factor `t`,
    /// which is clamped to the range `[0.0, 1.0]`.
    ///
    /// This function uses the "delta lerp" formula:
    /// `a + (b - a) * t`,
    /// which is more numerically stable and is usually faster than the "weighted lerp" formula:
    /// `a * (1.0 - t) + b * t`.
    ///
    /// The weighted formula can be used by calling [`FloatExt::lerp_weighted`],
    /// and is more numerically stable when interpolating large values that are far away from each other.
    fn lerp(self, other: Self, t: Self) -> Self;

    /// Linearly interpolates between `self` and `other` based on the interpolation factor `t`,
    /// which is clamped to the range `[0.0, 1.0]`.
    ///
    /// This function uses the "weighted lerp" formula:
    /// `a * (1.0 - t) + b * t`
    /// which is less numerically stable and usually slower than the "delta lerp" formula:
    /// `a + (b - a) * t`.
    ///
    /// The weighted formula can be used by calling [`FloatExt::lerp_weighted`],
    /// and is more numerically stable when interpolating large values that are far away from each other.
    fn lerp_weighted(self, other: Self, t: Self) -> Self;

    /// Linearly interpolates between `self` and `other` based on the interpolation factor `t`,
    /// which is clamped to the range `[0.0, 1.0]`.
    ///
    /// This function uses the "delta lerp" formula:
    /// `a + (b - a) * t`
    /// which is more numerically stable and is usually faster than the "weighted lerp" formula:
    /// `a * (1.0 - t) + b * t`.
    ///
    /// The weighted formula can be used by calling [`FloatExt::lerp_weighted`],
    /// and is more numerically stable when interpolating large values that are far away from each other.
    fn lerp_unclamped(self, other: Self, t: Self) -> Self;

    /// Linearly interpolates between `self` and `other` based on the interpolation factor `t`,
    /// which is clamped to the range `[0.0, 1.0]`.
    ///
    /// This function uses the "weighted lerp" formula:
    /// `a * (1.0 - t) + b * t`
    /// which is less numerically stable and usually slower than the "delta lerp" formula:
    /// `a + (b - a) * t`.
    ///
    /// The weighted formula can be used by calling [`FloatExt::lerp_weighted`],
    /// and is more numerically stable when interpolating large values that are far away from each other.
    fn lerp_unclamped_weighted(self, other: Self, t: Self) -> Self;

    /// Moves `self` towards `target` by at most `max_delta`.
    fn move_towards(self, other: Self, max_delta: Self) -> Self;
}

impl FloatExt for f32 {
    #[inline(always)]
    fn lerp(self, other: Self, t: Self) -> Self {
        self.lerp_unclamped(other, t.clamp(0.0, 1.0))
    }

    #[inline(always)]
    fn lerp_weighted(self, other: Self, t: Self) -> Self {
        self.lerp_unclamped_weighted(other, t.clamp(0.0, 1.0))
    }

    #[inline(always)]
    fn lerp_unclamped(self, other: Self, t: Self) -> Self {
        self + (other - self) * t
    }

    #[inline(always)]
    fn lerp_unclamped_weighted(self, other: Self, t: Self) -> Self {
        self * (1.0 - t) + other * t
    }

    #[inline(always)]
    fn move_towards(self, target: Self, max_delta: Self) -> Self {
        target.clamp(self - max_delta, self + max_delta)
    }
}

impl FloatExt for f64 {
    #[inline(always)]
    fn lerp(self, other: Self, t: Self) -> Self {
        self.lerp_unclamped(other, t.clamp(0.0, 1.0))
    }

    #[inline(always)]
    fn lerp_weighted(self, other: Self, t: Self) -> Self {
        self.lerp_unclamped_weighted(other, t.clamp(0.0, 1.0))
    }

    #[inline(always)]
    fn lerp_unclamped(self, other: Self, t: Self) -> Self {
        self + (other - self) * t
    }

    #[inline(always)]
    fn lerp_unclamped_weighted(self, other: Self, t: Self) -> Self {
        self * (1.0 - t) + other * t
    }

    #[inline(always)]
    fn move_towards(self, target: Self, max_delta: Self) -> Self {
        target.clamp(self - max_delta, self + max_delta)
    }
}

