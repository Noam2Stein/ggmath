
            // This file was generated by an associated codegen crate.
            // To modify this file, modify the source code of the associated codegen crate.
            
            #[doc=" A trait that adds additional functions to float types."]
pub trait FloatExt {
    #[doc=" Linearly interpolates between `self` and `other` based on the interpolation factor `t`,"]
    #[doc=" which is clamped to the range `[0.0, 1.0]`."]
    #[doc=""]
    #[doc=" This function uses the \"delta lerp\" formula which is:"]
    #[doc=" `a + (b - a) * t`"]
    #[doc=""]
    #[doc=" This formula is more numerically stable and is usually faster than the \"weighted lerp\" formula:"]
    #[doc=" `a * (1.0 - t) + b * t`"]
    #[doc=""]
    #[doc=" The other formula can be used by calling `lerp_weighted`."]
    #[doc=" It is useful when interpolating large values that are very far away from each other."]
    fn lerp(self, other: Self, t: Self) -> Self;

    #[doc=" Linearly interpolates between `self` and `other` based on the interpolation factor `t`,"]
    #[doc=" which is clamped to the range `[0.0, 1.0]`."]
    #[doc=""]
    #[doc=" This function uses the \"weighted lerp\" formula which is:"]
    #[doc=" `a * (1.0 - t) + b * t`"]
    #[doc=""]
    #[doc=" This formula is usually worse than the \"delta lerp\" formula:"]
    #[doc=" `a + (b - a) * t`"]
    #[doc=""]
    #[doc=" This \"weighted\" formula is useful when interpolating large values that are very far away from each other."]
    fn lerp_weighted(self, other: Self, t: Self) -> Self;

    #[doc=" Linearly interpolates between `self` and `other` based on the interpolation factor `t`."]
    #[doc=" If `t` is outside the range `[0.0, 1.0]`, the result is linearly extrapolated."]
    #[doc=""]
    #[doc=" This function uses the \"delta lerp\" formula which is:"]
    #[doc=" `a + (b - a) * t`"]
    #[doc=""]
    #[doc=" This formula is more numerically stable and is usually faster than the \"weighted lerp\" formula:"]
    #[doc=" `a * (1.0 - t) + b * t`"]
    #[doc=""]
    #[doc=" The other formula can be used by calling `lerp_weighted`."]
    #[doc=" It is useful when interpolating large values that are very far away from each other."]
    fn lerp_unclamped(self, other: Self, t: Self) -> Self;

    #[doc=" Linearly interpolates between `self` and `other` based on the interpolation factor `t`."]
    #[doc=" If `t` is outside the range `[0.0, 1.0]`, the result is linearly extrapolated."]
    #[doc=""]
    #[doc=" This function uses the \"weighted lerp\" formula which is:"]
    #[doc=" `a * (1.0 - t) + b * t`"]
    #[doc=""]
    #[doc=" This formula is usually worse than the \"delta lerp\" formula:"]
    #[doc=" `a + (b - a) * t`"]
    #[doc=""]
    #[doc=" This \"weighted\" formula is useful when interpolating large values that are very far away from each other."]
    fn lerp_unclamped_weighted(self, other: Self, t: Self) -> Self;

    #[doc=" Moves `self` towards `target` by at most `max_delta`."]
    fn move_towards(self, other: Self, max_delta: Self) -> Self;
}

impl FloatExt for f32 {
    #[inline(always)]
    fn lerp(self, other: Self, t: Self) -> Self {
        self.lerp_unclamped(other, t.clamp(0.0, 1.0))
    }

    #[inline(always)]
    fn lerp_weighted(self, other: Self, t: Self) -> Self {
        self.lerp_unclamped_weighted(other, t.clamp(0.0, 1.0))
    }

    #[inline(always)]
    fn lerp_unclamped(self, other: Self, t: Self) -> Self {
        self + (other - self) * t
    }

    #[inline(always)]
    fn lerp_unclamped_weighted(self, other: Self, t: Self) -> Self {
        self * (1.0 - t) + other * t
    }
}impl FloatExt for f64 {
    #[inline(always)]
    fn lerp(self, other: Self, t: Self) -> Self {
        self.lerp_unclamped(other, t.clamp(0.0, 1.0))
    }

    #[inline(always)]
    fn lerp_weighted(self, other: Self, t: Self) -> Self {
        self.lerp_unclamped_weighted(other, t.clamp(0.0, 1.0))
    }

    #[inline(always)]
    fn lerp_unclamped(self, other: Self, t: Self) -> Self {
        self + (other - self) * t
    }

    #[inline(always)]
    fn lerp_unclamped_weighted(self, other: Self, t: Self) -> Self {
        self * (1.0 - t) + other * t
    }
}

        
