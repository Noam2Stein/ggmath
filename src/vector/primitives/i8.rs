// This file was generated by a codegen tool.
// To modify this file, modify the source code of the codegen tool.

use crate::{
    Scalar, ScalarNegOne, ScalarOne, ScalarZero, Simd, Simdness, Usize, VecLen, Vector,
    scalar_neg_one_boilerplate, scalar_one_boilerplate, scalar_zero_boilerplate,
};

impl<const N: usize, S: Simdness> Vector<N, i8, S>
where
    Usize<N>: VecLen,
{
    // The following code is generated for all primitives

    /// Variation of `Vector::from_array` that is `const`.
    /// This may be slower than `Vector::from_array`.
    ///
    /// When rust stabilizes const traits, this will be deleted.
    #[inline(always)]
    pub const fn const_from_array(array: [i8; N]) -> Self {
        Self::pick_by_simdness(Vector(array), Vector(array))
    }

    // The following code is generated for all int primitives

    /// A vector of all minimum values.
    pub const MIN: Self = Self::const_from_array([i8::MIN; N]);
    /// A vector of all maximum values.
    pub const MAX: Self = Self::const_from_array([i8::MAX; N]);

    /// Converts `self` to a vector of `f32` elements.
    #[inline(always)]
    pub fn as_f32(self) -> Vector<N, f32, S> {
        self.map(|x| x as f32)
    }

    /// Converts `self` to a vector of `f64` elements.
    #[inline(always)]
    pub fn as_f64(self) -> Vector<N, f64, S> {
        self.map(|x| x as f64)
    }

    /// Converts `self` to a vector of `i16` elements.
    #[inline(always)]
    pub fn as_i16(self) -> Vector<N, i16, S> {
        self.map(|x| x as i16)
    }

    /// Converts `self` to a vector of `i32` elements.
    #[inline(always)]
    pub fn as_i32(self) -> Vector<N, i32, S> {
        self.map(|x| x as i32)
    }

    /// Converts `self` to a vector of `i64` elements.
    #[inline(always)]
    pub fn as_i64(self) -> Vector<N, i64, S> {
        self.map(|x| x as i64)
    }

    /// Converts `self` to a vector of `i128` elements.
    #[inline(always)]
    pub fn as_i128(self) -> Vector<N, i128, S> {
        self.map(|x| x as i128)
    }

    /// Converts `self` to a vector of `isize` elements.
    #[inline(always)]
    pub fn as_isize(self) -> Vector<N, isize, S> {
        self.map(|x| x as isize)
    }

    /// Converts `self` to a vector of `u8` elements.
    #[inline(always)]
    pub fn as_u8(self) -> Vector<N, u8, S> {
        self.map(|x| x as u8)
    }

    /// Converts `self` to a vector of `u16` elements.
    #[inline(always)]
    pub fn as_u16(self) -> Vector<N, u16, S> {
        self.map(|x| x as u16)
    }

    /// Converts `self` to a vector of `u32` elements.
    #[inline(always)]
    pub fn as_u32(self) -> Vector<N, u32, S> {
        self.map(|x| x as u32)
    }

    /// Converts `self` to a vector of `u64` elements.
    #[inline(always)]
    pub fn as_u64(self) -> Vector<N, u64, S> {
        self.map(|x| x as u64)
    }

    /// Converts `self` to a vector of `u128` elements.
    #[inline(always)]
    pub fn as_u128(self) -> Vector<N, u128, S> {
        self.map(|x| x as u128)
    }

    /// Converts `self` to a vector of `usize` elements.
    #[inline(always)]
    pub fn as_usize(self) -> Vector<N, usize, S> {
        self.map(|x| x as usize)
    }

    /// Returns `-self` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_neg(self) -> Option<Self> {
        self.map(|x| x.checked_neg()).flatten()
    }

    /// Returns `self + other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_add(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self.index(i).checked_add(other.index(i))).flatten()
    }

    /// Returns `self - other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_sub(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self.index(i).checked_sub(other.index(i))).flatten()
    }

    /// Returns `self * other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_mul(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self.index(i).checked_mul(other.index(i))).flatten()
    }

    /// Returns `self / other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_div(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self.index(i).checked_div(other.index(i))).flatten()
    }

    /// Returns `self % other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_rem(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self.index(i).checked_rem(other.index(i))).flatten()
    }

    /// Returns `-self` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_neg(self) -> Self {
        self.map(|x| x.wrapping_neg())
    }

    /// Returns `self + other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_add(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).wrapping_add(other.index(i)))
    }

    /// Returns `self - other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_sub(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).wrapping_sub(other.index(i)))
    }

    /// Returns `self * other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_mul(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).wrapping_mul(other.index(i)))
    }

    /// Returns `self / other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_div(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).wrapping_div(other.index(i)))
    }

    /// Returns `self % other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_rem(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).wrapping_rem(other.index(i)))
    }

    /// Returns `self + other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_add(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).saturating_add(other.index(i)))
    }

    /// Returns `self - other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_sub(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).saturating_sub(other.index(i)))
    }

    /// Returns `self * other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_mul(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).saturating_mul(other.index(i)))
    }

    /// Returns `self / other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_div(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).saturating_div(other.index(i)))
    }

    /// Returns a vector of the minimum of each element between `self` and `other`.
    #[inline(always)]
    pub fn min(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).min(other.index(i)))
    }

    /// Returns a vector of the maximum of each element between `self` and `other`.
    #[inline(always)]
    pub fn max(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).max(other.index(i)))
    }

    /// Returns a vector with each element clamped between `min` and `max`.
    #[inline(always)]
    pub fn clamp(self, min: Self, max: Self) -> Self {
        self.max(min).min(max)
    }

    /// Returns the minimum element in the vector.
    #[inline(always)]
    pub fn min_element(self) -> i8 {
        self.reduce(|a, b| a.min(b))
    }

    /// Returns the maximum element in the vector.
    #[inline(always)]
    pub fn max_element(self) -> i8 {
        self.reduce(|a, b| a.max(b))
    }

    // The following code is generated for all signed int primitives

    /// Returns `-self` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_neg(self) -> Self {
        Vector::from_fn(|i| self.index(i).saturating_neg())
    }

    /// Returns a vector containing the signum of each element of `self`.
    /// Signum for each element is:
    /// - `1` if the element is positive
    /// - `-1` if the element is negative
    /// - `0` if the element is zero
    #[inline(always)]
    pub fn signum(self) -> Self {
        self.map(|x| x.signum())
    }

    /// Returns a vector containing the absolute value of each element of `self`.
    #[inline(always)]
    pub fn abs(self) -> Self {
        self.map(|x| x.abs())
    }

    /// Returns a vector containing the absolute difference between each element of `self` and `other`.
    #[inline(always)]
    pub fn abs_diff(self, other: Self) -> Vector<N, u8, S> {
        Vector::from_fn(|i| self.index(i).abs_diff(other.index(i)))
    }

    /// Returns a vector containing the squared distance between each element of `self` and `other`.
    #[inline(always)]
    pub fn distance_sq(self, other: Self) -> u8 {
        self.abs_diff(other).mag_sq()
    }
}

impl Scalar for i8 {
    type SimdVectorStorage<const N: usize>
        = [i8; N]
    where
        Usize<N>: VecLen;

    #[inline(always)]
    fn vec_from_array<const N: usize>(array: [i8; N]) -> Vector<N, i8, Simd>
    where
        Usize<N>: VecLen,
    {
        Vector(array)
    }

    #[inline(always)]
    fn vec_as_array<const N: usize>(vec: Vector<N, i8, Simd>) -> [i8; N]
    where
        Usize<N>: VecLen,
    {
        vec.0
    }
}

impl ScalarZero for i8 {
    const ZERO: Self = 0;

    scalar_zero_boilerplate! {}
}

impl ScalarOne for i8 {
    const ONE: Self = 1;

    scalar_one_boilerplate! {}
}

impl ScalarNegOne for i8 {
    const NEG_ONE: Self = -1;

    scalar_neg_one_boilerplate! {}
}
