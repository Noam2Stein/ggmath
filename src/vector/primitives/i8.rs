// This file was generated by an associated codegen crate.
// To modify this file, modify the source code of the associated codegen crate.

use crate::{ScalarNegOne, ScalarOne, ScalarZero, Usize, VecAlignment, VecLen, Vector};

impl<const N: usize, A: VecAlignment> Vector<N, i8, A>
where
    Usize<N>: VecLen,
{
    // The following items are generated for all primitive number types

    /// A vector of all minimum values.
    pub const MIN: Self = Self::const_splat(i8::MIN);
    /// A vector of all maximum values.
    pub const MAX: Self = Self::const_splat(i8::MAX);

    /// Converts `self` to a vector of `f32` elements.
    #[inline(always)]
    pub fn as_f32(self) -> Vector<N, f32, A> {
        self.map(|x| x as f32)
    }

    /// Converts `self` to a vector of `f64` elements.
    #[inline(always)]
    pub fn as_f64(self) -> Vector<N, f64, A> {
        self.map(|x| x as f64)
    }

    /// Converts `self` to a vector of `i16` elements.
    #[inline(always)]
    pub fn as_i16(self) -> Vector<N, i16, A> {
        self.map(|x| x as i16)
    }

    /// Converts `self` to a vector of `i32` elements.
    #[inline(always)]
    pub fn as_i32(self) -> Vector<N, i32, A> {
        self.map(|x| x as i32)
    }

    /// Converts `self` to a vector of `i64` elements.
    #[inline(always)]
    pub fn as_i64(self) -> Vector<N, i64, A> {
        self.map(|x| x as i64)
    }

    /// Converts `self` to a vector of `i128` elements.
    #[inline(always)]
    pub fn as_i128(self) -> Vector<N, i128, A> {
        self.map(|x| x as i128)
    }

    /// Converts `self` to a vector of `isize` elements.
    #[inline(always)]
    pub fn as_isize(self) -> Vector<N, isize, A> {
        self.map(|x| x as isize)
    }

    /// Converts `self` to a vector of `u8` elements.
    #[inline(always)]
    pub fn as_u8(self) -> Vector<N, u8, A> {
        self.map(|x| x as u8)
    }

    /// Converts `self` to a vector of `u16` elements.
    #[inline(always)]
    pub fn as_u16(self) -> Vector<N, u16, A> {
        self.map(|x| x as u16)
    }

    /// Converts `self` to a vector of `u32` elements.
    #[inline(always)]
    pub fn as_u32(self) -> Vector<N, u32, A> {
        self.map(|x| x as u32)
    }

    /// Converts `self` to a vector of `u64` elements.
    #[inline(always)]
    pub fn as_u64(self) -> Vector<N, u64, A> {
        self.map(|x| x as u64)
    }

    /// Converts `self` to a vector of `u128` elements.
    #[inline(always)]
    pub fn as_u128(self) -> Vector<N, u128, A> {
        self.map(|x| x as u128)
    }

    /// Converts `self` to a vector of `usize` elements.
    #[inline(always)]
    pub fn as_usize(self) -> Vector<N, usize, A> {
        self.map(|x| x as usize)
    }

    // The following items are generated for all primitive int types

    /// Returns `-self` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_neg(self) -> Option<Self> {
        self.map(|x| x.checked_neg()).flatten()
    }

    /// Returns `self + other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_add(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self[i].checked_add(other[i])).flatten()
    }

    /// Returns `self - other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_sub(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self[i].checked_sub(other[i])).flatten()
    }

    /// Returns `self * other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_mul(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self[i].checked_mul(other[i])).flatten()
    }

    /// Returns `self / other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_div(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self[i].checked_div(other[i])).flatten()
    }

    /// Returns `self % other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_rem(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self[i].checked_rem(other[i])).flatten()
    }

    /// Returns `-self` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_neg(self) -> Self {
        self.map(|x| x.wrapping_neg())
    }

    /// Returns `self + other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_add(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].wrapping_add(other[i]))
    }

    /// Returns `self - other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_sub(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].wrapping_sub(other[i]))
    }

    /// Returns `self * other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_mul(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].wrapping_mul(other[i]))
    }

    /// Returns `self / other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_div(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].wrapping_div(other[i]))
    }

    /// Returns `self % other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_rem(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].wrapping_rem(other[i]))
    }

    /// Returns `self + other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_add(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].saturating_add(other[i]))
    }

    /// Returns `self - other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_sub(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].saturating_sub(other[i]))
    }

    /// Returns `self * other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_mul(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].saturating_mul(other[i]))
    }

    /// Returns `self / other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_div(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].saturating_div(other[i]))
    }

    // The following items are generated for all signed int types

    /// Returns `-self` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_neg(self) -> Self {
        Vector::from_fn(|i| self[i].saturating_neg())
    }

    /// Returns a vector containing the signum of each element of `self`.
    /// Signum for each element is:
    /// - `1` if the element is positive
    /// - `-1` if the element is negative
    /// - `0` if the element is zero
    #[inline(always)]
    pub fn signum(self) -> Self {
        self.map(|x| x.signum())
    }
}

impl ScalarZero for i8 {
    const ZERO: Self = 0;

    const VEC2_ZERO: Vec2<i8> = Vec2::const_from_array([0; 2]);
    const VEC3_ZERO: Vec3<i8> = Vec3::const_from_array([0; 3]);
    const VEC4_ZERO: Vec4<i8> = Vec4::const_from_array([0; 4]);
}

impl ScalarOne for i8 {
    const ONE: Self = 1;

    const VEC2_ONE: Vec2<i8> = Vec2::const_from_array([1; 2]);
    const VEC3_ONE: Vec3<i8> = Vec3::const_from_array([1; 3]);
    const VEC4_ONE: Vec4<i8> = Vec4::const_from_array([1; 4]);

    const VEC2_x: Vec2<i8> = Vec2::const_from_array([1, 0]);

    const VEC2_y: Vec2<i8> = Vec2::const_from_array([0, 1]);

    const VEC3_x: Vec3<i8> = Vec3::const_from_array([1, 0, 0]);

    const VEC3_y: Vec3<i8> = Vec3::const_from_array([0, 1, 0]);

    const VEC3_z: Vec3<i8> = Vec3::const_from_array([0, 0, 1]);

    const VEC4_x: Vec4<i8> = Vec4::const_from_array([1, 0, 0, 0]);

    const VEC4_y: Vec4<i8> = Vec4::const_from_array([0, 1, 0, 0]);

    const VEC4_z: Vec4<i8> = Vec4::const_from_array([0, 0, 1, 0]);

    const VEC4_w: Vec4<i8> = Vec4::const_from_array([0, 0, 0, 1]);
}

impl ScalarNegOne for i8 {
    const NEG_ONE: Self = -1;

    const VEC2_NEG_ONE: Vec2<i8> = Vec2::const_from_array([-1; 2]);
    const VEC3_NEG_ONE: Vec3<i8> = Vec3::const_from_array([-1; 3]);
    const VEC4_NEG_ONE: Vec4<i8> = Vec4::const_from_array([-1; 4]);

    const VEC2_NEG_x: Vec2<i8> = Vec2::const_from_array([-1, 0]);

    const VEC2_NEG_y: Vec2<i8> = Vec2::const_from_array([0, -1]);

    const VEC3_NEG_x: Vec3<i8> = Vec3::const_from_array([-1, 0, 0]);

    const VEC3_NEG_y: Vec3<i8> = Vec3::const_from_array([0, -1, 0]);

    const VEC3_NEG_z: Vec3<i8> = Vec3::const_from_array([0, 0, -1]);

    const VEC4_NEG_x: Vec4<i8> = Vec4::const_from_array([-1, 0, 0, 0]);

    const VEC4_NEG_y: Vec4<i8> = Vec4::const_from_array([0, -1, 0, 0]);

    const VEC4_NEG_z: Vec4<i8> = Vec4::const_from_array([0, 0, -1, 0]);

    const VEC4_NEG_w: Vec4<i8> = Vec4::const_from_array([0, 0, 0, -1]);
}
