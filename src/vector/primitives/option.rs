// This file was generated by a codegen tool.
// To modify this file, modify the source code of the codegen tool.

use crate::{Scalar, Simd, Simdness, Usize, VecLen, Vector};

impl<T: Scalar> Scalar for Option<T> {
    type SimdVectorStorage<const N: usize>
        = [Option<T>; N]
    where
        Usize<N>: VecLen;

    #[inline(always)]
    fn vec_from_array<const N: usize>(array: [Option<T>; N]) -> Vector<N, Option<T>, Simd>
    where
        Usize<N>: VecLen,
    {
        Vector(array)
    }

    #[inline(always)]
    fn vec_as_array<const N: usize>(vec: Vector<N, Option<T>, Simd>) -> [Option<T>; N]
    where
        Usize<N>: VecLen,
    {
        vec.0
    }
}

impl<const N: usize, T: Scalar, S: Simdness> Vector<N, Option<T>, S>
where
    Usize<N>: VecLen,
{
    /// Returns a vector of bools with `true` for each element that is `Some`, otherwise `false`.
    #[inline(always)]
    pub fn some_mask(self) -> Vector<N, bool, S> {
        self.map(|x| x.is_some())
    }

    /// Returns a vector of bools with `true` for each element that is `None`, otherwise `false`.
    #[inline(always)]
    pub fn none_mask(self) -> Vector<N, bool, S> {
        self.map(|x| x.is_none())
    }

    /// Returns `Some(self)` if all elements are `Some`, otherwise returns `None`.
    #[inline(always)]
    pub fn flatten(self) -> Option<Vector<N, T, S>> {
        if self.some_mask().all_true() {
            Some(self.map(|x| x.unwrap()))
        } else {
            None
        }
    }
}
