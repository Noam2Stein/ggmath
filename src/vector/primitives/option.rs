// This file was generated by an associated codegen crate.
// To modify this file, modify the source code of the associated codegen crate.

use crate::{Scalar, Simdness, Usize, Vec2, Vec3, Vec4, VecLen, Vector};

impl<T: Scalar> Scalar for Option<T> {
    type InnerSimdVec2 = [Option<T>; 2];
    type InnerSimdVec3 = [Option<T>; 3];
    type InnerSimdVec4 = [Option<T>; 4];

    #[inline(always)]
    fn vec2_from_array(array: [Option<T>; 2]) -> Vec2<Option<T>> {
        Vector(array)
    }

    #[inline(always)]
    fn vec2_as_array(vec: Vec2<Option<T>>) -> [Option<T>; 2] {
        vec.0
    }

    #[inline(always)]
    fn vec3_from_array(array: [Option<T>; 3]) -> Vec3<Option<T>> {
        Vector(array)
    }

    #[inline(always)]
    fn vec3_as_array(vec: Vec3<Option<T>>) -> [Option<T>; 3] {
        vec.0
    }

    #[inline(always)]
    fn vec4_from_array(array: [Option<T>; 4]) -> Vec4<Option<T>> {
        Vector(array)
    }

    #[inline(always)]
    fn vec4_as_array(vec: Vec4<Option<T>>) -> [Option<T>; 4] {
        vec.0
    }
}

impl<const N: usize, T: Scalar, S: Simdness> Vector<N, Option<T>, S>
where
    Usize<N>: VecLen,
{
    /// Returns a vector of bools with `true` for each element that is `Some`, otherwise `false`.
    #[inline(always)]
    pub fn some_mask(self) -> Vector<N, bool, S> {
        self.map(|x| x.is_some())
    }

    /// Returns a vector of bools with `true` for each element that is `None`, otherwise `false`.
    #[inline(always)]
    pub fn none_mask(self) -> Vector<N, bool, S> {
        self.map(|x| x.is_none())
    }

    /// Returns `Some(self)` if all elements are `Some`, otherwise returns `None`.
    #[inline(always)]
    pub fn flatten(self) -> Option<Vector<N, T, S>> {
        if self.some_mask().all_true() {
            Some(self.map(|x| x.unwrap()))
        } else {
            None
        }
    }
}
