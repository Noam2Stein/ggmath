// This file was generated by an associated codegen crate.
// To modify this file, modify the source code of the associated codegen crate.

use core::mem::transmute_copy;

use crate::{
    NonSimd, Scalar, ScalarOne, ScalarZero, Simd, Simdness, Usize, Vec2, Vec3, Vec4, VecLen, Vector,
};

impl<const N: usize, S: Simdness> Vector<N, u64, S>
where
    Usize<N>: VecLen,
{
    // The following code is generated for all primitives

    /// Variation of `Vector::from_array` that is `const`.
    /// This may be slower than `Vector::from_array`.
    ///
    /// When rust stabilizes const traits, this will be deleted.
    #[inline(always)]
    pub const fn const_from_array(array: [u64; N]) -> Self {
        unsafe {
            if S::IS_SIMD {
                match N {
                    2 => {
                        let array = transmute_copy::<[u64; N], [u64; 2]>(&array);
                        let vec = Vector::<2, _, _>(array);

                        transmute_copy::<Vector<2, u64, Simd>, Vector<N, u64, S>>(&vec)
                    }
                    3 => {
                        let array = transmute_copy::<[u64; N], [u64; 3]>(&array);
                        let vec = Vector::<3, _, _>(array);

                        transmute_copy::<Vector<3, u64, Simd>, Vector<N, u64, S>>(&vec)
                    }
                    4 => {
                        let array = transmute_copy::<[u64; N], [u64; 4]>(&array);
                        let vec = Vector::<4, _, _>(array);

                        transmute_copy::<Vector<4, u64, Simd>, Vector<N, u64, S>>(&vec)
                    }
                    _ => panic!("unusual vector type"),
                }
            } else {
                transmute_copy::<Vector<N, u64, NonSimd>, Vector<N, u64, S>>(&Vector(array))
            }
        }
    }

    /// Variation of `Vector::splat` that is `const`.
    /// This may be slower than `Vector::splat`.
    ///
    /// When rust stabilizes const traits, this will be deleted.
    #[inline(always)]
    pub const fn const_splat(value: u64) -> Self {
        Self::const_from_array([value; N])
    }

    // The following code is generated for all number primitives

    /// A vector of all minimum values.
    pub const MIN: Self = Self::const_splat(u64::MIN);
    /// A vector of all maximum values.
    pub const MAX: Self = Self::const_splat(u64::MAX);

    /// Converts `self` to a vector of `f32` elements.
    #[inline(always)]
    pub fn as_f32(self) -> Vector<N, f32, S> {
        self.map(|x| x as f32)
    }

    /// Converts `self` to a vector of `f64` elements.
    #[inline(always)]
    pub fn as_f64(self) -> Vector<N, f64, S> {
        self.map(|x| x as f64)
    }

    /// Converts `self` to a vector of `i8` elements.
    #[inline(always)]
    pub fn as_i8(self) -> Vector<N, i8, S> {
        self.map(|x| x as i8)
    }

    /// Converts `self` to a vector of `i16` elements.
    #[inline(always)]
    pub fn as_i16(self) -> Vector<N, i16, S> {
        self.map(|x| x as i16)
    }

    /// Converts `self` to a vector of `i32` elements.
    #[inline(always)]
    pub fn as_i32(self) -> Vector<N, i32, S> {
        self.map(|x| x as i32)
    }

    /// Converts `self` to a vector of `i64` elements.
    #[inline(always)]
    pub fn as_i64(self) -> Vector<N, i64, S> {
        self.map(|x| x as i64)
    }

    /// Converts `self` to a vector of `i128` elements.
    #[inline(always)]
    pub fn as_i128(self) -> Vector<N, i128, S> {
        self.map(|x| x as i128)
    }

    /// Converts `self` to a vector of `isize` elements.
    #[inline(always)]
    pub fn as_isize(self) -> Vector<N, isize, S> {
        self.map(|x| x as isize)
    }

    /// Converts `self` to a vector of `u8` elements.
    #[inline(always)]
    pub fn as_u8(self) -> Vector<N, u8, S> {
        self.map(|x| x as u8)
    }

    /// Converts `self` to a vector of `u16` elements.
    #[inline(always)]
    pub fn as_u16(self) -> Vector<N, u16, S> {
        self.map(|x| x as u16)
    }

    /// Converts `self` to a vector of `u32` elements.
    #[inline(always)]
    pub fn as_u32(self) -> Vector<N, u32, S> {
        self.map(|x| x as u32)
    }

    /// Converts `self` to a vector of `u128` elements.
    #[inline(always)]
    pub fn as_u128(self) -> Vector<N, u128, S> {
        self.map(|x| x as u128)
    }

    /// Converts `self` to a vector of `usize` elements.
    #[inline(always)]
    pub fn as_usize(self) -> Vector<N, usize, S> {
        self.map(|x| x as usize)
    }

    // The following code is generated for all int primitives

    /// Returns `-self` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_neg(self) -> Option<Self> {
        self.map(|x| x.checked_neg()).flatten()
    }

    /// Returns `self + other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_add(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self.index(i).checked_add(other.index(i))).flatten()
    }

    /// Returns `self - other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_sub(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self.index(i).checked_sub(other.index(i))).flatten()
    }

    /// Returns `self * other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_mul(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self.index(i).checked_mul(other.index(i))).flatten()
    }

    /// Returns `self / other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_div(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self.index(i).checked_div(other.index(i))).flatten()
    }

    /// Returns `self % other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_rem(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self.index(i).checked_rem(other.index(i))).flatten()
    }

    /// Returns `-self` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_neg(self) -> Self {
        self.map(|x| x.wrapping_neg())
    }

    /// Returns `self + other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_add(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).wrapping_add(other.index(i)))
    }

    /// Returns `self - other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_sub(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).wrapping_sub(other.index(i)))
    }

    /// Returns `self * other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_mul(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).wrapping_mul(other.index(i)))
    }

    /// Returns `self / other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_div(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).wrapping_div(other.index(i)))
    }

    /// Returns `self % other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_rem(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).wrapping_rem(other.index(i)))
    }

    /// Returns `self + other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_add(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).saturating_add(other.index(i)))
    }

    /// Returns `self - other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_sub(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).saturating_sub(other.index(i)))
    }

    /// Returns `self * other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_mul(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).saturating_mul(other.index(i)))
    }

    /// Returns `self / other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_div(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).saturating_div(other.index(i)))
    }

    /// Returns a vector of the minimum of each element between `self` and `other`.
    #[inline(always)]
    pub fn min(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).min(other.index(i)))
    }

    /// Returns a vector of the maximum of each element between `self` and `other`.
    #[inline(always)]
    pub fn max(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).max(other.index(i)))
    }

    /// Returns a vector with each element clamped between `min` and `max`.
    #[inline(always)]
    pub fn clamp(self, min: Self, max: Self) -> Self {
        self.max(min).min(max)
    }

    /// Returns the minimum element in the vector.
    #[inline(always)]
    pub fn min_element(self) -> u64 {
        self.reduce(|a, b| a.min(b))
    }

    /// Returns the maximum element in the vector.
    #[inline(always)]
    pub fn max_element(self) -> u64 {
        self.reduce(|a, b| a.max(b))
    }
}

impl Scalar for u64 {
    type InnerSimdVec2 = [u64; 2];
    type InnerSimdVec3 = [u64; 3];
    type InnerSimdVec4 = [u64; 4];

    #[inline(always)]
    fn vec2_from_array(array: [u64; 2]) -> Vec2<u64> {
        Vector(array)
    }

    #[inline(always)]
    fn vec2_as_array(vec: Vec2<u64>) -> [u64; 2] {
        vec.0
    }

    #[inline(always)]
    fn vec3_from_array(array: [u64; 3]) -> Vec3<u64> {
        Vector(array)
    }

    #[inline(always)]
    fn vec3_as_array(vec: Vec3<u64>) -> [u64; 3] {
        vec.0
    }

    #[inline(always)]
    fn vec4_from_array(array: [u64; 4]) -> Vec4<u64> {
        Vector(array)
    }

    #[inline(always)]
    fn vec4_as_array(vec: Vec4<u64>) -> [u64; 4] {
        vec.0
    }
}

impl ScalarZero for u64 {
    const ZERO: Self = 0;

    const VEC2_ZERO: Vec2<u64> = Vec2::<u64>::const_from_array([0; 2]);
    const VEC3_ZERO: Vec3<u64> = Vec3::<u64>::const_from_array([0; 3]);
    const VEC4_ZERO: Vec4<u64> = Vec4::<u64>::const_from_array([0; 4]);
}

impl ScalarOne for u64 {
    const ONE: Self = 1;

    const VEC2_ONE: Vec2<u64> = Vec2::<u64>::const_from_array([1; 2]);
    const VEC3_ONE: Vec3<u64> = Vec3::<u64>::const_from_array([1; 3]);
    const VEC4_ONE: Vec4<u64> = Vec4::<u64>::const_from_array([1; 4]);

    const VEC2_X: Vec2<u64> = Vec2::<u64>::const_from_array([1, 0]);

    const VEC2_Y: Vec2<u64> = Vec2::<u64>::const_from_array([0, 1]);

    const VEC3_X: Vec3<u64> = Vec3::<u64>::const_from_array([1, 0, 0]);

    const VEC3_Y: Vec3<u64> = Vec3::<u64>::const_from_array([0, 1, 0]);

    const VEC3_Z: Vec3<u64> = Vec3::<u64>::const_from_array([0, 0, 1]);

    const VEC4_X: Vec4<u64> = Vec4::<u64>::const_from_array([1, 0, 0, 0]);

    const VEC4_Y: Vec4<u64> = Vec4::<u64>::const_from_array([0, 1, 0, 0]);

    const VEC4_Z: Vec4<u64> = Vec4::<u64>::const_from_array([0, 0, 1, 0]);

    const VEC4_W: Vec4<u64> = Vec4::<u64>::const_from_array([0, 0, 0, 1]);
}
