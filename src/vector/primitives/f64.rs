// This file was generated by an associated codegen crate.
// To modify this file, modify the source code of the associated codegen crate.

use core::mem::transmute_copy;

use crate::{
    NonSimd, Scalar, ScalarNegOne, ScalarOne, ScalarZero, Simd, Simdness, Usize, Vec2, Vec3, Vec4,
    VecLen, Vector,
};

impl<const N: usize, S: Simdness> Vector<N, f64, S>
where
    Usize<N>: VecLen,
{
    // The following code is for all primitives

    /// Variation of `Vector::from_array` that is `const`.
    /// This may be slower than `Vector::from_array`.
    ///
    /// When rust stabilizes const traits, this will be deleted.
    #[inline(always)]
    pub const fn const_from_array(array: [f64; N]) -> Self {
        unsafe {
            if S::IS_SIMD {
                match N {
                    2 => {
                        let array = transmute_copy::<[f64; N], [f64; 2]>(&array);
                        let vec = Vector::<2, _, _>(array);

                        transmute_copy::<Vector<2, f64, Simd>, Vector<N, f64, S>>(&vec)
                    }
                    3 => {
                        let array = transmute_copy::<[f64; N], [f64; 3]>(&array);
                        let vec = Vector::<3, _, _>(array);

                        transmute_copy::<Vector<3, f64, Simd>, Vector<N, f64, S>>(&vec)
                    }
                    4 => {
                        let array = transmute_copy::<[f64; N], [f64; 4]>(&array);
                        let vec = Vector::<4, _, _>(array);

                        transmute_copy::<Vector<4, f64, Simd>, Vector<N, f64, S>>(&vec)
                    }
                    _ => panic!("unusual vector type"),
                }
            } else {
                transmute_copy::<Vector<N, f64, NonSimd>, Vector<N, f64, S>>(&Vector(array))
            }
        }
    }

    /// Variation of `Vector::splat` that is `const`.
    /// This may be slower than `Vector::splat`.
    ///
    /// When rust stabilizes const traits, this will be deleted.
    #[inline(always)]
    pub const fn const_splat(value: f64) -> Self {
        Self::const_from_array([value; N])
    }

    // The following code is for all number primitives

    /// A vector of all minimum values.
    pub const MIN: Self = Self::const_splat(f64::MIN);
    /// A vector of all maximum values.
    pub const MAX: Self = Self::const_splat(f64::MAX);

    /// Converts `self` to a vector of `f32` elements.
    #[inline(always)]
    pub fn as_f32(self) -> Vector<N, f32, S> {
        self.map(|x| x as f32)
    }

    /// Converts `self` to a vector of `i8` elements.
    #[inline(always)]
    pub fn as_i8(self) -> Vector<N, i8, S> {
        self.map(|x| x as i8)
    }

    /// Converts `self` to a vector of `i16` elements.
    #[inline(always)]
    pub fn as_i16(self) -> Vector<N, i16, S> {
        self.map(|x| x as i16)
    }

    /// Converts `self` to a vector of `i32` elements.
    #[inline(always)]
    pub fn as_i32(self) -> Vector<N, i32, S> {
        self.map(|x| x as i32)
    }

    /// Converts `self` to a vector of `i64` elements.
    #[inline(always)]
    pub fn as_i64(self) -> Vector<N, i64, S> {
        self.map(|x| x as i64)
    }

    /// Converts `self` to a vector of `i128` elements.
    #[inline(always)]
    pub fn as_i128(self) -> Vector<N, i128, S> {
        self.map(|x| x as i128)
    }

    /// Converts `self` to a vector of `isize` elements.
    #[inline(always)]
    pub fn as_isize(self) -> Vector<N, isize, S> {
        self.map(|x| x as isize)
    }

    /// Converts `self` to a vector of `u8` elements.
    #[inline(always)]
    pub fn as_u8(self) -> Vector<N, u8, S> {
        self.map(|x| x as u8)
    }

    /// Converts `self` to a vector of `u16` elements.
    #[inline(always)]
    pub fn as_u16(self) -> Vector<N, u16, S> {
        self.map(|x| x as u16)
    }

    /// Converts `self` to a vector of `u32` elements.
    #[inline(always)]
    pub fn as_u32(self) -> Vector<N, u32, S> {
        self.map(|x| x as u32)
    }

    /// Converts `self` to a vector of `u64` elements.
    #[inline(always)]
    pub fn as_u64(self) -> Vector<N, u64, S> {
        self.map(|x| x as u64)
    }

    /// Converts `self` to a vector of `u128` elements.
    #[inline(always)]
    pub fn as_u128(self) -> Vector<N, u128, S> {
        self.map(|x| x as u128)
    }

    /// Converts `self` to a vector of `usize` elements.
    #[inline(always)]
    pub fn as_usize(self) -> Vector<N, usize, S> {
        self.map(|x| x as usize)
    }

    // The following code is for all float primitives

    /// A vector with all elements set to `NaN`.
    pub const NAN: Self = Self::const_splat(f64::NAN);
    /// A vector with all elements set to `Infinity`.
    pub const INFINITY: Self = Self::const_splat(f64::INFINITY);
    /// A vector with all elements set to `-Infinity`.
    pub const NEG_INFINITY: Self = Self::const_splat(f64::NEG_INFINITY);
    /// A vector with all elements set to `Epsilon`.
    pub const EPSILON: Self = Self::const_splat(f64::EPSILON);

    /// Returns a vector of the Euclidean division of each element by `other`.
    #[inline(always)]
    pub fn div_euclid(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).div_euclid(other.index(i)))
    }

    /// Returns a vector of the remainder of the Euclidean division of each element by `other`.
    #[inline(always)]
    pub fn rem_euclid(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).rem_euclid(other.index(i)))
    }

    /// Returns a vector of the minimum of each element between `self` and `other`.
    #[inline(always)]
    pub fn min(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).min(other.index(i)))
    }

    /// Returns a vector of the maximum of each element between `self` and `other`.
    #[inline(always)]
    pub fn max(self, other: Self) -> Self {
        Vector::from_fn(|i| self.index(i).max(other.index(i)))
    }

    /// Returns a vector with each element clamped between `min` and `max`.
    #[inline(always)]
    pub fn clamp(self, min: Self, max: Self) -> Self {
        self.max(min).min(max)
    }

    /// Returns the minimum element in the vector.
    #[inline(always)]
    pub fn min_element(self) -> f64 {
        self.reduce(|a, b| a.min(b))
    }

    /// Returns the maximum element in the vector.
    #[inline(always)]
    pub fn max_element(self) -> f64 {
        self.reduce(|a, b| a.max(b))
    }

    /// Returns a vector containing the signum of each element of `self`.
    /// Signum for each element is:
    /// - `1.0` if the element is positive or `+0.0`
    /// - `-1.0` if the element is negative `-0.0`
    #[inline(always)]
    pub fn signum(self) -> Self {
        self.map(|x| x.signum())
    }

    /// Returns a vector containing the absolute value of each element of `self`.
    #[inline(always)]
    pub fn abs(self) -> Self {
        self.map(|x| x.abs())
    }

    /// Returns a vector containing the squared distance between each element of `self` and `other`.
    #[inline(always)]
    pub fn distance_sq(self, other: Self) -> f64 {
        (self - other).mag_sq()
    }

    /// Returns a vector of bools with `true` for each element that has a negative sign, including `-0.0`.
    #[inline(always)]
    pub fn negative_sign_mask(self) -> Vector<N, bool, S> {
        self.map(|x| x.is_sign_negative())
    }

    /// Returns a vector of bools with `true` for each element that has a positive sign, including `+0.0`.
    #[inline(always)]
    pub fn positive_sign_mask(self) -> Vector<N, bool, S> {
        self.map(|x| x.is_sign_positive())
    }

    /// Returns a vector of bools with `true` for each element that is `NaN`.
    #[inline(always)]
    pub fn nan_mask(self) -> Vector<N, bool, S> {
        self.map(|x| x.is_nan())
    }

    /// Returns a vector of bools with `true` for each element that is finite.
    #[inline(always)]
    pub fn finite_mask(self) -> Vector<N, bool, S> {
        self.map(|x| x.is_finite())
    }

    /// Returns `true` if any element is `NaN`.
    #[inline(always)]
    pub fn is_nan(self) -> bool {
        self.nan_mask().any_true()
    }

    /// Returns `true` if all elements are finite.
    #[inline(always)]
    pub fn is_finite(self) -> bool {
        self.finite_mask().all_true()
    }

    /// Returns a vector with the same direction as `self`, but with a magnitude of `1`.
    #[inline(always)]
    pub fn normalize(self) -> Self {
        #[cfg(debug_assertions)]
        assert!(self.mag_sq() > 0.0, "self must be non-zero");

        self / self.mag()
    }

    /// Returns a vector with the same direction as `self`, but with a magnitude of `1`.
    /// If `self` is zero, `None` is returned.
    #[inline(always)]
    pub fn checked_normalize(self) -> Option<Self> {
        let normalized = self.normalize();
        if normalized.is_finite() {
            Some(normalized)
        } else {
            None
        }
    }

    /// Returns a vector with the same direction as `self`, but with a magnitude of `1`.
    #[inline(always)]
    pub fn normalize_or(self, default: Self) -> Self {
        let normalized = self.normalize();
        if normalized.is_finite() {
            normalized
        } else {
            default
        }
    }

    /// Returns a vector with the same direction as `self`, but with a magnitude of `1`.
    /// If `self` is zero, zero is returned.
    #[inline(always)]
    pub fn normalize_or_zero(self) -> Self {
        self.normalize_or(Self::ZERO)
    }

    /// Linearly interpolates between `self` and `other` based on the interpolation factor `t`,
    /// which is clamped to the range `[0.0, 1.0]`.
    ///
    /// This function uses the "delta lerp" formula:
    /// `a + (b - a) * t`,
    /// which is more numerically stable and is usually faster than the "weighted lerp" formula:
    /// `a * (1.0 - t) + b * t`.
    ///
    /// The weighted formula can be used by calling [`Self::lerp_weighted`],
    /// and is more numerically stable when interpolating large values that are far away from each other.
    #[inline(always)]
    pub fn lerp(self, other: Self, t: f64) -> Self {
        self.lerp_unclamped(other, t.clamp(0.0, 1.0))
    }

    /// Linearly interpolates between `self` and `other` based on the interpolation factor `t`,
    /// which is clamped to the range `[0.0, 1.0]`.
    ///
    /// This function uses the "weighted lerp" formula:
    /// `a * (1.0 - t) + b * t`
    /// which is less numerically stable and usually slower than the "delta lerp" formula:
    /// `a + (b - a) * t`.
    ///
    /// This weighted formula is more numerically stable when interpolating large values that are far away from each other.
    #[inline(always)]
    pub fn lerp_weighted(self, other: Self, t: f64) -> Self {
        self.lerp_unclamped_weighted(other, t.clamp(0.0, 1.0))
    }

    /// Linearly interpolates between `self` and `other` based on the interpolation factor `t`,
    /// or linearly extrapolates if `t` is outside the range `[0.0, 1.0]`.
    ///
    /// This function uses the "delta lerp" formula:
    /// `a + (b - a) * t`
    /// which is more numerically stable and is usually faster than the "weighted lerp" formula:
    /// `a * (1.0 - t) + b * t`.
    ///
    /// The weighted formula can be used by calling [`FloatExt::lerp_unclamped_weighted`],
    /// and is more numerically stable when interpolating large values that are far away from each other.
    #[inline(always)]
    pub fn lerp_unclamped(self, other: Self, t: f64) -> Self {
        self + (other - self) * t
    }

    /// Linearly interpolates between `self` and `other` based on the interpolation factor `t`,
    /// or linearly extrapolates if `t` is outside the range `[0.0, 1.0]`.
    ///
    /// This function uses the "weighted lerp" formula:
    /// `a * (1.0 - t) + b * t`
    /// which is less numerically stable and usually slower than the "delta lerp" formula:
    /// `a + (b - a) * t`.
    ///
    /// This weighted formula is more numerically stable when interpolating large values that are far away from each other.
    #[inline(always)]
    pub fn lerp_unclamped_weighted(self, other: Self, t: f64) -> Self {
        self * (1.0 - t) + other * t
    }

    /// Moves `self` towards `target` by at most `max_delta`.
    #[inline(always)]
    pub fn move_towards(self, target: Self, max_delta: f64) -> Self {
        let delta = target - self;
        let delta_mag = delta.mag();
        if delta_mag <= max_delta || delta_mag <= 1e-4 {
            return target;
        }
        self + delta / delta_mag * max_delta
    }

    /// Returns the projection of `self` onto `other`.
    #[inline(always)]
    pub fn project_onto(self, other: Self) -> Self {
        other * self.dot(other) * (1.0 / other.mag_sq())
    }

    /// Returns the projection of `self` onto `other`,
    /// where `other` must be normalized.
    ///
    /// This is faster than `project_onto`.
    #[inline(always)]
    pub fn project_onto_normalized(self, other: Self) -> Self {
        #[cfg(debug_assertions)]
        assert!(other.mag_sq() == 1.0, "other must be normalized");

        other * self.dot(other)
    }

    /// Returns the rejection of `self` from `other`.
    #[inline(always)]
    pub fn reject_from(self, other: Self) -> Self {
        self - self.project_onto(other)
    }

    /// Returns the rejection of `self` from `other`,
    /// where `other` must be normalized.
    ///
    /// This is faster than `reject_from`.
    #[inline(always)]
    pub fn reject_from_normalized(self, other: Self) -> Self {
        #[cfg(debug_assertions)]
        assert!(other.mag_sq() == 1.0, "other must be normalized");

        self - self.project_onto_normalized(other)
    }

    /// Returns the reflection of `self` off of `normal`.
    ///
    /// `normal` must be normalized.
    #[inline(always)]
    pub fn reflect(self, normal: Self) -> Self {
        #[cfg(debug_assertions)]
        assert!(normal.mag_sq() == 1.0, "normal must be normalized");

        self - normal * (2.0 * self.dot(normal))
    }

    /// Returns the refraction of `self` through `normal` for the given ratio of indices of refraction.
    ///
    /// `self` and `normal` must be normalized.
    #[inline(always)]
    pub fn refract(self, normal: Self, eta: f64) -> Self {
        #[cfg(debug_assertions)]
        assert!(self.mag_sq() == 1.0, "self must be normalized");

        #[cfg(debug_assertions)]
        assert!(normal.mag_sq() == 1.0, "normal must be normalized");

        let n_dot_i = normal.dot(self);
        let k = 1.0 - eta * eta * (1.0 - n_dot_i * n_dot_i);
        if k >= 0.0 {
            self * eta - normal * (eta * n_dot_i + k.sqrt())
        } else {
            Self::ZERO
        }
    }
}

#[cfg(feature = "std")]
impl<const N: usize, S: Simdness> Vector<N, f64, S>
where
    Usize<N>: VecLen,
{
    // The following items are generated for all float types

    /// Returns a vector containing the square root of each element of `self`.
    #[inline(always)]
    pub fn sqrt(self) -> Self {
        self.map(|x| x.sqrt())
    }

    /// Returns a vector containing the rounded value of each element of `self`.
    #[inline(always)]
    pub fn round(self) -> Self {
        self.map(|x| x.round())
    }

    /// Returns a vector containing the floor value of each element of `self`.
    #[inline(always)]
    pub fn floor(self) -> Self {
        self.map(|x| x.floor())
    }

    /// Returns a vector containing the ceiling value of each element of `self`.
    #[inline(always)]
    pub fn ceil(self) -> Self {
        self.map(|x| x.ceil())
    }

    /// Returns a vector containing the truncated value of each element of `self`.
    #[inline(always)]
    pub fn trunc(self) -> Self {
        self.map(|x| x.trunc())
    }

    /// Returns a vector containing the fractional part of each element of `self` as `self - self.trunc()`.
    #[inline(always)]
    pub fn fract(self) -> Self {
        self.map(|x| x.fract())
    }

    /// Returns a vector containing the sine of each element of `self`.
    #[inline(always)]
    pub fn sin(self) -> Self {
        self.map(|x| x.sin())
    }

    /// Returns a vector containing the cosine of each element of `self`.
    #[inline(always)]
    pub fn cos(self) -> Self {
        self.map(|x| x.cos())
    }

    /// Returns a vector containing the tangent of each element of `self`.
    #[inline(always)]
    pub fn tan(self) -> Self {
        self.map(|x| x.tan())
    }

    /// Returns a vector containing the arcsine of each element of `self`.
    #[inline(always)]
    pub fn asin(self) -> Self {
        self.map(|x| x.asin())
    }

    /// Returns a vector containing the arccosine of each element of `self`.
    #[inline(always)]
    pub fn acos(self) -> Self {
        self.map(|x| x.acos())
    }

    /// Returns a vector containing the arctangent of each element of `self`.
    #[inline(always)]
    pub fn atan(self) -> Self {
        self.map(|x| x.atan())
    }

    /// Returns a vector containing the hyperbolic sine of each element of `self`.
    #[inline(always)]
    pub fn sinh(self) -> Self {
        self.map(|x| x.sinh())
    }

    /// Returns a vector containing the hyperbolic cosine of each element of `self`.
    #[inline(always)]
    pub fn cosh(self) -> Self {
        self.map(|x| x.cosh())
    }

    /// Returns a vector containing the hyperbolic tangent of each element of `self`.
    #[inline(always)]
    pub fn tanh(self) -> Self {
        self.map(|x| x.tanh())
    }

    /// Returns a vector containing the hyperbolic arclength sine of each element of `self`.
    #[inline(always)]
    pub fn asinh(self) -> Self {
        self.map(|x| x.asinh())
    }

    /// Returns a vector containing the hyperbolic arclength cosine of each element of `self`.
    #[inline(always)]
    pub fn acosh(self) -> Self {
        self.map(|x| x.acosh())
    }

    /// Returns a vector containing the hyperbolic arclength tangent of each element of `self`.
    #[inline(always)]
    pub fn atanh(self) -> Self {
        self.map(|x| x.atanh())
    }

    /// Returns the magnitude of `self`.
    #[inline(always)]
    pub fn mag(self) -> f64 {
        self.mag_sq().sqrt()
    }

    /// Returns the Euclidean distance between `self` and `other`.
    #[inline(always)]
    pub fn distance(self, other: Self) -> f64 {
        self.distance_sq(other).sqrt()
    }

    /// Returns the angle in radians between `self` and `other` in the range `[0.0, π]`.
    #[inline(always)]
    pub fn angle(self, other: Self) -> f64 {
        (self.dot(other) / (self.mag_sq() * other.mag_sq()).sqrt()).acos()
    }
}

#[cfg(feature = "std")]
impl<S: Simdness> Vector<2, f64, S> {
    /// Returns the signed angle in radians between `self` and `other` in the range `[-π, π]`.
    #[inline(always)]
    pub fn signed_angle(self, other: Self) -> f64 {
        self.angle(other) * self.perp_dot(other).signum()
    }
}

impl Scalar for f64 {
    type InnerSimdVec2 = [f64; 2];
    type InnerSimdVec3 = [f64; 3];
    type InnerSimdVec4 = [f64; 4];

    #[inline(always)]
    fn vec2_from_array(array: [f64; 2]) -> Vec2<f64> {
        Vector(array)
    }

    #[inline(always)]
    fn vec2_as_array(vec: Vec2<f64>) -> [f64; 2] {
        vec.0
    }

    #[inline(always)]
    fn vec3_from_array(array: [f64; 3]) -> Vec3<f64> {
        Vector(array)
    }

    #[inline(always)]
    fn vec3_as_array(vec: Vec3<f64>) -> [f64; 3] {
        vec.0
    }

    #[inline(always)]
    fn vec4_from_array(array: [f64; 4]) -> Vec4<f64> {
        Vector(array)
    }

    #[inline(always)]
    fn vec4_as_array(vec: Vec4<f64>) -> [f64; 4] {
        vec.0
    }
}

impl ScalarZero for f64 {
    const ZERO: Self = 0.0;

    const VEC2_ZERO: Vec2<f64> = Vec2::<f64>::const_from_array([0.0; 2]);
    const VEC3_ZERO: Vec3<f64> = Vec3::<f64>::const_from_array([0.0; 3]);
    const VEC4_ZERO: Vec4<f64> = Vec4::<f64>::const_from_array([0.0; 4]);
}

impl ScalarOne for f64 {
    const ONE: Self = 1.0;

    const VEC2_ONE: Vec2<f64> = Vec2::<f64>::const_from_array([1.0; 2]);
    const VEC3_ONE: Vec3<f64> = Vec3::<f64>::const_from_array([1.0; 3]);
    const VEC4_ONE: Vec4<f64> = Vec4::<f64>::const_from_array([1.0; 4]);

    const VEC2_X: Vec2<f64> = Vec2::<f64>::const_from_array([1.0, 0.0]);
    const VEC2_Y: Vec2<f64> = Vec2::<f64>::const_from_array([0.0, 1.0]);

    const VEC3_X: Vec3<f64> = Vec3::<f64>::const_from_array([1.0, 0.0, 0.0]);
    const VEC3_Y: Vec3<f64> = Vec3::<f64>::const_from_array([0.0, 1.0, 0.0]);
    const VEC3_Z: Vec3<f64> = Vec3::<f64>::const_from_array([0.0, 0.0, 1.0]);

    const VEC4_X: Vec4<f64> = Vec4::<f64>::const_from_array([1.0, 0.0, 0.0, 0.0]);
    const VEC4_Y: Vec4<f64> = Vec4::<f64>::const_from_array([0.0, 1.0, 0.0, 0.0]);
    const VEC4_Z: Vec4<f64> = Vec4::<f64>::const_from_array([0.0, 0.0, 1.0, 0.0]);
    const VEC4_W: Vec4<f64> = Vec4::<f64>::const_from_array([0.0, 0.0, 0.0, 1.0]);
}

impl ScalarNegOne for f64 {
    const NEG_ONE: Self = -1.0;

    const VEC2_NEG_ONE: Vec2<f64> = Vec2::<f64>::const_from_array([-1.0; 2]);
    const VEC3_NEG_ONE: Vec3<f64> = Vec3::<f64>::const_from_array([-1.0; 3]);
    const VEC4_NEG_ONE: Vec4<f64> = Vec4::<f64>::const_from_array([-1.0; 4]);

    const VEC2_NEG_X: Vec2<f64> = Vec2::<f64>::const_from_array([-1.0, 0.0]);
    const VEC2_NEG_Y: Vec2<f64> = Vec2::<f64>::const_from_array([0.0, -1.0]);

    const VEC3_NEG_X: Vec3<f64> = Vec3::<f64>::const_from_array([-1.0, 0.0, 0.0]);
    const VEC3_NEG_Y: Vec3<f64> = Vec3::<f64>::const_from_array([0.0, -1.0, 0.0]);
    const VEC3_NEG_Z: Vec3<f64> = Vec3::<f64>::const_from_array([0.0, 0.0, -1.0]);

    const VEC4_NEG_X: Vec4<f64> = Vec4::<f64>::const_from_array([-1.0, 0.0, 0.0, 0.0]);
    const VEC4_NEG_Y: Vec4<f64> = Vec4::<f64>::const_from_array([0.0, -1.0, 0.0, 0.0]);
    const VEC4_NEG_Z: Vec4<f64> = Vec4::<f64>::const_from_array([0.0, 0.0, -1.0, 0.0]);
    const VEC4_NEG_W: Vec4<f64> = Vec4::<f64>::const_from_array([0.0, 0.0, 0.0, -1.0]);
}
