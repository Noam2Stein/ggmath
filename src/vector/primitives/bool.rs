// This file was generated by an associated codegen crate.
// To modify this file, modify the source code of the associated codegen crate.

use core::mem::transmute_copy;

use crate::{NonSimd, Scalar, Simd, Simdness, Usize, Vec2, Vec3, Vec4, VecLen, Vector};

impl<const N: usize, S: Simdness> Vector<N, bool, S>
where
    Usize<N>: VecLen,
{
    // The following code is generated for all primitives

    /// Variation of `Vector::from_array` that is `const`.
    /// This may be slower than `Vector::from_array`.
    ///
    /// When rust stabilizes const traits, this will be deleted.
    #[inline(always)]
    pub const fn const_from_array(array: [bool; N]) -> Self {
        unsafe {
            if S::IS_SIMD {
                match N {
                    2 => {
                        let array = transmute_copy::<[bool; N], [bool; 2]>(&array);
                        let vec = Vector::<2, _, _>(array);

                        transmute_copy::<Vector<2, bool, Simd>, Vector<N, bool, S>>(&vec)
                    }
                    3 => {
                        let array = transmute_copy::<[bool; N], [bool; 3]>(&array);
                        let vec = Vector::<3, _, _>(array);

                        transmute_copy::<Vector<3, bool, Simd>, Vector<N, bool, S>>(&vec)
                    }
                    4 => {
                        let array = transmute_copy::<[bool; N], [bool; 4]>(&array);
                        let vec = Vector::<4, _, _>(array);

                        transmute_copy::<Vector<4, bool, Simd>, Vector<N, bool, S>>(&vec)
                    }
                    _ => panic!("unusual vector type"),
                }
            } else {
                transmute_copy::<Vector<N, bool, NonSimd>, Vector<N, bool, S>>(&Vector(array))
            }
        }
    }

    /// Variation of `Vector::splat` that is `const`.
    /// This may be slower than `Vector::splat`.
    ///
    /// When rust stabilizes const traits, this will be deleted.
    #[inline(always)]
    pub const fn const_splat(value: bool) -> Self {
        Self::const_from_array([value; N])
    }

    // The following code is generated for `bool`

    /// All `true`.
    pub const TRUE: Self = Self::const_splat(true);
    /// All `false`.
    pub const FALSE: Self = Self::const_splat(false);

    /// Returns `true` if all elements are `true`.
    #[inline(always)]
    pub fn all_true(self) -> bool {
        self.all(|x| x)
    }

    /// Returns `true` if any element is `true`.
    #[inline(always)]
    pub fn any_true(self) -> bool {
        self.any(|x| x)
    }

    /// Returns `true` if all elements are `false`.
    #[inline(always)]
    pub fn all_false(self) -> bool {
        self.all(|x| !x)
    }

    /// Returns `true` if any element is `false`.
    #[inline(always)]
    pub fn any_false(self) -> bool {
        self.any(|x| !x)
    }

    /// Returns the number of `true` elements.
    #[inline(always)]
    pub fn count_true(self) -> usize {
        self.count(|x| x)
    }

    /// Returns the number of `false` elements.
    #[inline(always)]
    pub fn count_false(self) -> usize {
        self.count(|x| !x)
    }

    /// Returns a vector of `T2` elements where each element is `if_true` if the corresponding element in `self` is `true` and `if_false` if the corresponding element in `self` is `false`.
    #[inline(always)]
    pub fn select<T2: Scalar>(
        self,
        if_true: Vector<N, T2, S>,
        if_false: Vector<N, T2, S>,
    ) -> Vector<N, T2, S> {
        Vector::from_fn(|i| {
            if self.index(i) {
                if_true.index(i)
            } else {
                if_false.index(i)
            }
        })
    }

    /// Converts `self` to a vector of `i8` elements.
    #[inline(always)]
    pub fn as_i8(self) -> Vector<N, i8, S> {
        self.map(|x| x as i8)
    }

    /// Converts `self` to a vector of `i16` elements.
    #[inline(always)]
    pub fn as_i16(self) -> Vector<N, i16, S> {
        self.map(|x| x as i16)
    }

    /// Converts `self` to a vector of `i32` elements.
    #[inline(always)]
    pub fn as_i32(self) -> Vector<N, i32, S> {
        self.map(|x| x as i32)
    }

    /// Converts `self` to a vector of `i64` elements.
    #[inline(always)]
    pub fn as_i64(self) -> Vector<N, i64, S> {
        self.map(|x| x as i64)
    }

    /// Converts `self` to a vector of `i128` elements.
    #[inline(always)]
    pub fn as_i128(self) -> Vector<N, i128, S> {
        self.map(|x| x as i128)
    }

    /// Converts `self` to a vector of `isize` elements.
    #[inline(always)]
    pub fn as_isize(self) -> Vector<N, isize, S> {
        self.map(|x| x as isize)
    }

    /// Converts `self` to a vector of `u8` elements.
    #[inline(always)]
    pub fn as_u8(self) -> Vector<N, u8, S> {
        self.map(|x| x as u8)
    }

    /// Converts `self` to a vector of `u16` elements.
    #[inline(always)]
    pub fn as_u16(self) -> Vector<N, u16, S> {
        self.map(|x| x as u16)
    }

    /// Converts `self` to a vector of `u32` elements.
    #[inline(always)]
    pub fn as_u32(self) -> Vector<N, u32, S> {
        self.map(|x| x as u32)
    }

    /// Converts `self` to a vector of `u64` elements.
    #[inline(always)]
    pub fn as_u64(self) -> Vector<N, u64, S> {
        self.map(|x| x as u64)
    }

    /// Converts `self` to a vector of `u128` elements.
    #[inline(always)]
    pub fn as_u128(self) -> Vector<N, u128, S> {
        self.map(|x| x as u128)
    }

    /// Converts `self` to a vector of `usize` elements.
    #[inline(always)]
    pub fn as_usize(self) -> Vector<N, usize, S> {
        self.map(|x| x as usize)
    }
}

impl Scalar for bool {
    type InnerSimdVec2 = [bool; 2];
    type InnerSimdVec3 = [bool; 3];
    type InnerSimdVec4 = [bool; 4];

    #[inline(always)]
    fn vec2_from_array(array: [bool; 2]) -> Vec2<bool> {
        Vector(array)
    }

    #[inline(always)]
    fn vec2_as_array(vec: Vec2<bool>) -> [bool; 2] {
        vec.0
    }

    #[inline(always)]
    fn vec3_from_array(array: [bool; 3]) -> Vec3<bool> {
        Vector(array)
    }

    #[inline(always)]
    fn vec3_as_array(vec: Vec3<bool>) -> [bool; 3] {
        vec.0
    }

    #[inline(always)]
    fn vec4_from_array(array: [bool; 4]) -> Vec4<bool> {
        Vector(array)
    }

    #[inline(always)]
    fn vec4_as_array(vec: Vec4<bool>) -> [bool; 4] {
        vec.0
    }
}
