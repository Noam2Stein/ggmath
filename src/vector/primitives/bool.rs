// This file was generated by an associated codegen crate.
// To modify this file, modify the source code of the associated codegen crate.

use core::mem::transmute_copy;

use crate::{Scalar, Usize, Vec2, Vec3, Vec4, VecAligned, VecAlignment, VecLen, VecPacked, Vector};

impl<const N: usize, A: VecAlignment> Vector<N, bool, A>
where
    Usize<N>: VecLen,
{
    // The following code is for all primitives

    #[inline(always)]
    pub const fn const_from_array(array: [bool; N]) -> Self {
        unsafe {
            if A::IS_ALIGNED {
                match N {
                    2 => {
                        let array = transmute_copy::<[bool; N], [bool; 2]>(&array);
                        let vec = Vector::<2, _, _>(array);

                        transmute_copy::<Vector<2, bool, VecAligned>, Vector<N, bool, A>>(&vec)
                    }
                    3 => {
                        let array = transmute_copy::<[bool; N], [bool; 3]>(&array);
                        let vec = Vector::<3, _, _>(array);

                        transmute_copy::<Vector<3, bool, VecAligned>, Vector<N, bool, A>>(&vec)
                    }
                    4 => {
                        let array = transmute_copy::<[bool; N], [bool; 4]>(&array);
                        let vec = Vector::<4, _, _>(array);

                        transmute_copy::<Vector<4, bool, VecAligned>, Vector<N, bool, A>>(&vec)
                    }
                    _ => panic!("unusual vector type"),
                }
            } else {
                transmute_copy::<Vector<N, bool, VecPacked>, Vector<N, bool, A>>(&Vector(array))
            }
        }
    }

    #[inline(always)]
    pub const fn const_splat(value: bool) -> Self {
        Self::const_from_array([value; N])
    }

    // The following code is only for bool

    /// All `true`.
    pub const TRUE: Self = Self::const_splat(true);
    /// All `false`.
    pub const FALSE: Self = Self::const_splat(false);

    /// Returns `true` if all elements are `true`.
    #[inline(always)]
    pub fn all_true(self) -> bool {
        self.all(|x| x)
    }

    /// Returns `true` if any element is `true`.
    #[inline(always)]
    pub fn any_true(self) -> bool {
        self.any(|x| x)
    }

    /// Returns `true` if all elements are `false`.
    #[inline(always)]
    pub fn all_false(self) -> bool {
        self.all(|x| !x)
    }

    /// Returns `true` if any element is `false`.
    #[inline(always)]
    pub fn any_false(self) -> bool {
        self.any(|x| !x)
    }

    /// Returns the number of `true` elements.
    #[inline(always)]
    pub fn count_true(self) -> usize {
        self.count(|x| x)
    }

    /// Returns the number of `false` elements.
    #[inline(always)]
    pub fn count_false(self) -> usize {
        self.count(|x| !x)
    }

    /// Converts `self` to a vector of `i8` elements.
    #[inline(always)]
    pub fn as_i8(self) -> Vector<N, i8, A> {
        self.map(|x| x as i8)
    }

    /// Converts `self` to a vector of `i16` elements.
    #[inline(always)]
    pub fn as_i16(self) -> Vector<N, i16, A> {
        self.map(|x| x as i16)
    }

    /// Converts `self` to a vector of `i32` elements.
    #[inline(always)]
    pub fn as_i32(self) -> Vector<N, i32, A> {
        self.map(|x| x as i32)
    }

    /// Converts `self` to a vector of `i64` elements.
    #[inline(always)]
    pub fn as_i64(self) -> Vector<N, i64, A> {
        self.map(|x| x as i64)
    }

    /// Converts `self` to a vector of `i128` elements.
    #[inline(always)]
    pub fn as_i128(self) -> Vector<N, i128, A> {
        self.map(|x| x as i128)
    }

    /// Converts `self` to a vector of `isize` elements.
    #[inline(always)]
    pub fn as_isize(self) -> Vector<N, isize, A> {
        self.map(|x| x as isize)
    }

    /// Converts `self` to a vector of `u8` elements.
    #[inline(always)]
    pub fn as_u8(self) -> Vector<N, u8, A> {
        self.map(|x| x as u8)
    }

    /// Converts `self` to a vector of `u16` elements.
    #[inline(always)]
    pub fn as_u16(self) -> Vector<N, u16, A> {
        self.map(|x| x as u16)
    }

    /// Converts `self` to a vector of `u32` elements.
    #[inline(always)]
    pub fn as_u32(self) -> Vector<N, u32, A> {
        self.map(|x| x as u32)
    }

    /// Converts `self` to a vector of `u64` elements.
    #[inline(always)]
    pub fn as_u64(self) -> Vector<N, u64, A> {
        self.map(|x| x as u64)
    }

    /// Converts `self` to a vector of `u128` elements.
    #[inline(always)]
    pub fn as_u128(self) -> Vector<N, u128, A> {
        self.map(|x| x as u128)
    }

    /// Converts `self` to a vector of `usize` elements.
    #[inline(always)]
    pub fn as_usize(self) -> Vector<N, usize, A> {
        self.map(|x| x as usize)
    }
}

impl Scalar for bool {
    type InnerAlignedVec2 = [bool; 2];
    type InnerAlignedVec3 = [bool; 3];
    type InnerAlignedVec4 = [bool; 4];

    #[inline(always)]
    fn vec2_from_array(array: [bool; 2]) -> Vec2<bool> {
        Vector(array)
    }

    #[inline(always)]
    fn vec2_as_array(vec: Vec2<bool>) -> [bool; 2] {
        vec.0
    }

    #[inline(always)]
    fn vec3_from_array(array: [bool; 3]) -> Vec3<bool> {
        Vector(array)
    }

    #[inline(always)]
    fn vec3_as_array(vec: Vec3<bool>) -> [bool; 3] {
        vec.0
    }

    #[inline(always)]
    fn vec4_from_array(array: [bool; 4]) -> Vec4<bool> {
        Vector(array)
    }

    #[inline(always)]
    fn vec4_as_array(vec: Vec4<bool>) -> [bool; 4] {
        vec.0
    }
}
