// This file was generated by an associated codegen crate.
// To modify this file, modify the source code of the associated codegen crate.

//! Vector related types and traits

use core::{
    fmt::{Debug, Display},
    hash::{Hash, Hasher},
    mem::{transmute, transmute_copy},
    ops::*,
    slice::SliceIndex,
};

use crate::{Construct, IndexOutOfBoundsError, Usize, return_for_types};

mod dir;
mod primitives;
mod swizzle;
pub use dir::*;

/// A generic vector type.
///
/// This type is generic over 3 parameters:
/// - `N`: The length of the vector, which currently supports 2, 3 and 4.
/// - `T`: The type of the vector, which must implement the [`Scalar`] trait.
/// - `A`: The "alignment" of the vector, which enables or disables SIMD memory alignment.
///
/// This type has very very useful type-aliases:
/// - `Vec{N}<T>` like `Vec2<f32>` is for SIMD aligned vectors
/// - `Vec{N}P<T>` like `Vec2P<f32>` is for non-SIMD aligned vectors
///
/// # Length
///
/// Currently only the lengths 2, 3 and 4 are supported in order to specialize their inner vector type.
/// In the future if rust gains more type-system features, more lengths will be supported.
///
/// Beware that code should never rely on the fact that 2, 3 and 4 are the only supported lengths.
/// Code that branches based on vector length should either properly handle all usize values or use [`VecLenEnum`].
///
/// # Alignment
///
/// The `A` generic parameter controls whether or not the vector is SIMD aligned,
/// and can be set to either `VecAligned` or `VecPacked`.
///
/// SIMD can improve performance of vector operations,
/// but it can also increase the size of the vector in memory.
///
/// `Vector<N, T, VecAligned>` vectors are SIMD aligned if it increases performance,
/// while `Vector<N, T, VecPacked>` vectors are not SIMD aligned and are always stored as `[T; N]`.
///
/// This means that `VecAligned` are for performance and `VecPacked` are for memory efficiency.
///
/// Beware that while `VecPacked` guarentees an exact memory layout of `[T; N]`, `VecAligned` does not guarantee a specific alignment rule/pattern.
/// For example, `Vector<3, f32, VecAligned`/`Vec3<f32>` isn't guaranteed to be aligned to a 128-bit boundary.
/// It is up to the implementation of [`Scalar`] to determine `VecAligned` alignment for whatever is most performant.
///
/// # Examples
/// ```
/// use ggmath::aliases::*;
///
/// // This is a non memory critical scenario so we should use `VecAligned`.
/// struct PlayerState {
///     // Vector<3, f32, VecAligned>
///     position: Vec3<f32>,
///     // ...
/// }
///
/// // This is a memory critical scenario so we should use `VecPacked`.
/// struct GpuVertex {
///     // Vector<3, f32, VecPacked>
///     position: Vec3P<f32>,
///     // Vector<3, f32, VecPacked>
///     normal: Vec3P<f32>,
///     // Vector<2, f32, VecPacked>
///     uv: Vec2P<f32>,
/// }
/// ```
#[repr(transparent)]
pub struct Vector<const N: usize, T: Scalar, A: VecAlignment>(pub A::InnerVector<N, T>)
where
    Usize<N>: VecLen;

/// Type alias for [`Vector<2, T, VecAligned>`][Vector].
pub type Vec2<T> = Vector<2, T, VecAligned>;

/// Type alias for [`Vector<2, T, VecPacked>`][Vector].
pub type Vec2P<T> = Vector<2, T, VecPacked>;

/// Type alias for [`Vector<3, T, VecAligned>`][Vector].
pub type Vec3<T> = Vector<3, T, VecAligned>;

/// Type alias for [`Vector<3, T, VecPacked>`][Vector].
pub type Vec3P<T> = Vector<3, T, VecPacked>;

/// Type alias for [`Vector<4, T, VecAligned>`][Vector].
pub type Vec4<T> = Vector<4, T, VecAligned>;

/// Type alias for [`Vector<4, T, VecPacked>`][Vector].
pub type Vec4P<T> = Vector<4, T, VecPacked>;

/// Macro that generates vector type aliases for a specific scalar type.
///
/// Syntax: `vector_aliases!(<visibility> <prefix> => <scalar>)`
///
/// # Examples
///
/// ```
/// use ggmath::*;
///
/// vector_aliases!(pub F => f32);
/// ```
/// Generates:
/// ```
/// pub type FVec2 = ggmath::Vec2<f32>;
/// pub type FVec2P = ggmath::Vec2P<f32>;
/// pub type FVec3 = ggmath::Vec3<f32>;
/// pub type FVec3P = ggmath::Vec3P<f32>;
/// pub type FVec4 = ggmath::Vec4<f32>;
/// pub type FVec4P = ggmath::Vec4P<f32>;
///
/// ```
#[macro_export]
macro_rules! vector_aliases {
    (pub($($vis:tt)*) $prefix:ident => $t:ty) => {
        $crate::vector_aliases!(@(pub $($vis)*) $prefix => $t);
    };
    (pub $prefix:ident => $t:ty) => {
        $crate::vector_aliases!(@(pub) $prefix => $t);
    };
    ($prefix:ident => $t:ty) => {
        $crate::vector_aliases!(@() $prefix => $t);
    };

    (@($($vis:tt)*) $prefix:ident => $t:ty) => {
        $crate::_hidden_::paste! {
            #[doc = "Type alias to [`Vector<2, " $t ", VecAligned>`][Vector]."]
			$($vis)* type [<$prefix Vec2>] = $crate::Vec2<$t>;

			#[doc = "Type alias to [`Vector<2, " $t ", VecPacked>`][Vector]."]
			$($vis)* type [<$prefix Vec2P>] = $crate::Vec2P<$t>;

			#[doc = "Type alias to [`Vector<3, " $t ", VecAligned>`][Vector]."]
			$($vis)* type [<$prefix Vec3>] = $crate::Vec3<$t>;

			#[doc = "Type alias to [`Vector<3, " $t ", VecPacked>`][Vector]."]
			$($vis)* type [<$prefix Vec3P>] = $crate::Vec3P<$t>;

			#[doc = "Type alias to [`Vector<4, " $t ", VecAligned>`][Vector]."]
			$($vis)* type [<$prefix Vec4>] = $crate::Vec4<$t>;

			#[doc = "Type alias to [`Vector<4, " $t ", VecPacked>`][Vector]."]
			$($vis)* type [<$prefix Vec4P>] = $crate::Vec4P<$t>;

        }
    };
}

/// A trait that marks a `Usize<N>` type as a valid vector length.
/// See [`Vector`] for more information.
pub trait VecLen {
    /// The inner type contained inside `Vector<N, T, VecAligned>`.
    ///
    /// This redirects to `T::InnerAlignedVec{N}`,
    /// for example `T::InnerAlignedVec2` for `Usize<2>`.
    type InnerAlignedVector<T: Scalar>: Construct;

    /// The length value as an enum.
    const ENUM: VecLenEnum;
}

/// An enum with all currently supported vector lengths.
///
/// The enum value of a generic `const N: usize` value can be accessed with [`<Usize<N> as VecLen>::ENUM`][`VecLen::ENUM`].
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum VecLenEnum {
    /// `2`
    Two,
    /// `3`
    Three,
    /// `4`
    Four,
}

/// A trait that marks a type as a valid scalar type that can be used in a vector.
/// This trait is implemented for most primitive types, like `f32`, `f64`, `bool`, `usize`, etc.
///
/// # Implementing `Scalar`
///
/// When implementing `Scalar` you need to fill:
///
/// 1.
/// `InnerAlignedVec2`, `InnerAlignedVec3`, etc
///
/// These are the inner types stored inside `VecAligned` vectors,
/// for example `Vector<3, f32, VecAligned>` is stored as `f32::InnerAlignedVec3`.
///
/// The reference of these types MUST be transmutable to `&[T; N]`,
/// if its not then using that vector is undefined behavior.
/// This means that you cannot do things like expand `Vec3<bool>` into a 128-bit SIMD register with 32-bit lanes.
///
/// 2.
/// `GARBAGE`, `INNER_ALIGNED_VEC2_GARBAGE`, `INNER_ALIGNED_VEC3_GARBAGE`, etc
///
/// These need to be any valid value of `Self`, `Self::InnerAlignedVec2`, `Self::InnerAlignedVec3`, etc.
/// This is used to properly initialize aligned vectors.
///
/// # Examples
///
/// ```
/// #[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, Default)]
/// struct BigInt {
///     // private fields
/// }
///
/// // impl Add, Sub... for BigInt
///
/// // lets say BigInt cannot benefit from SIMD operations, or we just don't want to optimize it yet.
/// // When not wanting SIMD we can fill `InnerAlignedVec{N}` with `[Self; N]`.
/// impl Scalar for BigInt {
///     type InnerAlignedVec2 = [Self; 2];
/// 	type InnerAlignedVec3 = [Self; 3];
/// 	type InnerAlignedVec4 = [Self; 4];
///
/// }
///
/// struct SmallInt(i32);
///
/// // impl Add, Sub... for SmallInt
///
/// // lets say SmallInt can benefit from SIMD operations.
/// impl Scalar for SmallInt {
///     // use i32 vector types for aligned vectors.
///     type InnerAlignedVec2 = Vector<2, Self, VecAligned>;
/// 	type InnerAlignedVec3 = Vector<3, Self, VecAligned>;
/// 	type InnerAlignedVec4 = Vector<4, Self, VecAligned>;
///
/// }
/// ```
pub trait Scalar: Construct {
    /// The inner type contained inside `Vector<2, Self, VecAligned>` vectors.
    type InnerAlignedVec2: Construct;

    /// The inner type contained inside `Vector<3, Self, VecAligned>` vectors.
    type InnerAlignedVec3: Construct;

    /// The inner type contained inside `Vector<4, Self, VecAligned>` vectors.
    type InnerAlignedVec4: Construct;

    /// Constructs an aligned vec2 from an array.
    fn vec2_from_array(array: [Self; 2]) -> Vec2<Self>;

    /// Converts an aligned vec2 to an array.
    fn vec2_as_array(vec: Vec2<Self>) -> [Self; 2];

    /// Constructs an aligned vec3 from an array.
    fn vec3_from_array(array: [Self; 3]) -> Vec3<Self>;

    /// Converts an aligned vec3 to an array.
    fn vec3_as_array(vec: Vec3<Self>) -> [Self; 3];

    /// Constructs an aligned vec4 from an array.
    fn vec4_from_array(array: [Self; 4]) -> Vec4<Self>;

    /// Converts an aligned vec4 to an array.
    fn vec4_as_array(vec: Vec4<Self>) -> [Self; 4];

    /// Overridable implementation of `Vector::splat` for aligned vec2s.
    #[inline(always)]
    fn vec2_splat(value: Self) -> Vec2<Self> {
        Vec2::from_array([value; 2])
    }

    /// Overridable implementation of `Vector::splat` for aligned vec3s.
    #[inline(always)]
    fn vec3_splat(value: Self) -> Vec3<Self> {
        Vec3::from_array([value; 3])
    }

    /// Overridable implementation of `Vector::splat` for aligned vec4s.
    #[inline(always)]
    fn vec4_splat(value: Self) -> Vec4<Self> {
        Vec4::from_array([value; 4])
    }

    /// Overridable implementation of `Vector::eq` for aligned vec2s.
    #[inline(always)]
    fn vec2_eq<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> bool
    where
        Self: PartialEq<T2>,
    {
        (0..2).all(|i| vec.index(i) == other.index(i))
    }

    /// Overridable implementation of `Vector::ne` for aligned vec2s.
    #[inline(always)]
    fn vec2_ne<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> bool
    where
        Self: PartialEq<T2>,
    {
        (0..2).any(|i| vec.index(i) != other.index(i))
    }

    /// Overridable implementation of `Vector::eq` for aligned vec3s.
    #[inline(always)]
    fn vec3_eq<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> bool
    where
        Self: PartialEq<T2>,
    {
        (0..3).all(|i| vec.index(i) == other.index(i))
    }

    /// Overridable implementation of `Vector::ne` for aligned vec3s.
    #[inline(always)]
    fn vec3_ne<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> bool
    where
        Self: PartialEq<T2>,
    {
        (0..3).any(|i| vec.index(i) != other.index(i))
    }

    /// Overridable implementation of `Vector::eq` for aligned vec4s.
    #[inline(always)]
    fn vec4_eq<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> bool
    where
        Self: PartialEq<T2>,
    {
        (0..4).all(|i| vec.index(i) == other.index(i))
    }

    /// Overridable implementation of `Vector::ne` for aligned vec4s.
    #[inline(always)]
    fn vec4_ne<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> bool
    where
        Self: PartialEq<T2>,
    {
        (0..4).any(|i| vec.index(i) != other.index(i))
    }

    /// Overridable implementation of `Vector::neg` for aligned vec2s.
    #[inline(always)]
    fn vec2_neg(vec: Vec2<Self>) -> Vec2<<Self as Neg>::Output>
    where
        Self: Neg<Output: Scalar>,
    {
        vec.map(|v| v.neg())
    }

    /// Overridable implementation of `Vector::neg` for aligned vec3s.
    #[inline(always)]
    fn vec3_neg(vec: Vec3<Self>) -> Vec3<<Self as Neg>::Output>
    where
        Self: Neg<Output: Scalar>,
    {
        vec.map(|v| v.neg())
    }

    /// Overridable implementation of `Vector::neg` for aligned vec4s.
    #[inline(always)]
    fn vec4_neg(vec: Vec4<Self>) -> Vec4<<Self as Neg>::Output>
    where
        Self: Neg<Output: Scalar>,
    {
        vec.map(|v| v.neg())
    }

    /// Overridable implementation of `Vector::not` for aligned vec2s.
    #[inline(always)]
    fn vec2_not(vec: Vec2<Self>) -> Vec2<<Self as Not>::Output>
    where
        Self: Not<Output: Scalar>,
    {
        vec.map(|v| v.not())
    }

    /// Overridable implementation of `Vector::not` for aligned vec3s.
    #[inline(always)]
    fn vec3_not(vec: Vec3<Self>) -> Vec3<<Self as Not>::Output>
    where
        Self: Not<Output: Scalar>,
    {
        vec.map(|v| v.not())
    }

    /// Overridable implementation of `Vector::not` for aligned vec4s.
    #[inline(always)]
    fn vec4_not(vec: Vec4<Self>) -> Vec4<<Self as Not>::Output>
    where
        Self: Not<Output: Scalar>,
    {
        vec.map(|v| v.not())
    }

    /// Overridable implementation of `Vector::add` for aligned vec2s.
    #[inline(always)]
    fn vec2_add<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> Vec2<<Self as Add<T2>>::Output>
    where
        Self: Add<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).add(other.index(i)))
    }

    /// Overridable implementation of `Vector::add` for aligned vec3s.
    #[inline(always)]
    fn vec3_add<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> Vec3<<Self as Add<T2>>::Output>
    where
        Self: Add<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).add(other.index(i)))
    }

    /// Overridable implementation of `Vector::add` for aligned vec4s.
    #[inline(always)]
    fn vec4_add<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> Vec4<<Self as Add<T2>>::Output>
    where
        Self: Add<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).add(other.index(i)))
    }

    /// Overridable implementation of `Vector::sub` for aligned vec2s.
    #[inline(always)]
    fn vec2_sub<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> Vec2<<Self as Sub<T2>>::Output>
    where
        Self: Sub<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).sub(other.index(i)))
    }

    /// Overridable implementation of `Vector::sub` for aligned vec3s.
    #[inline(always)]
    fn vec3_sub<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> Vec3<<Self as Sub<T2>>::Output>
    where
        Self: Sub<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).sub(other.index(i)))
    }

    /// Overridable implementation of `Vector::sub` for aligned vec4s.
    #[inline(always)]
    fn vec4_sub<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> Vec4<<Self as Sub<T2>>::Output>
    where
        Self: Sub<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).sub(other.index(i)))
    }

    /// Overridable implementation of `Vector::mul` for aligned vec2s.
    #[inline(always)]
    fn vec2_mul<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> Vec2<<Self as Mul<T2>>::Output>
    where
        Self: Mul<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).mul(other.index(i)))
    }

    /// Overridable implementation of `Vector::mul` for aligned vec3s.
    #[inline(always)]
    fn vec3_mul<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> Vec3<<Self as Mul<T2>>::Output>
    where
        Self: Mul<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).mul(other.index(i)))
    }

    /// Overridable implementation of `Vector::mul` for aligned vec4s.
    #[inline(always)]
    fn vec4_mul<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> Vec4<<Self as Mul<T2>>::Output>
    where
        Self: Mul<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).mul(other.index(i)))
    }

    /// Overridable implementation of `Vector::div` for aligned vec2s.
    #[inline(always)]
    fn vec2_div<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> Vec2<<Self as Div<T2>>::Output>
    where
        Self: Div<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).div(other.index(i)))
    }

    /// Overridable implementation of `Vector::div` for aligned vec3s.
    #[inline(always)]
    fn vec3_div<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> Vec3<<Self as Div<T2>>::Output>
    where
        Self: Div<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).div(other.index(i)))
    }

    /// Overridable implementation of `Vector::div` for aligned vec4s.
    #[inline(always)]
    fn vec4_div<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> Vec4<<Self as Div<T2>>::Output>
    where
        Self: Div<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).div(other.index(i)))
    }

    /// Overridable implementation of `Vector::rem` for aligned vec2s.
    #[inline(always)]
    fn vec2_rem<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> Vec2<<Self as Rem<T2>>::Output>
    where
        Self: Rem<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).rem(other.index(i)))
    }

    /// Overridable implementation of `Vector::rem` for aligned vec3s.
    #[inline(always)]
    fn vec3_rem<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> Vec3<<Self as Rem<T2>>::Output>
    where
        Self: Rem<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).rem(other.index(i)))
    }

    /// Overridable implementation of `Vector::rem` for aligned vec4s.
    #[inline(always)]
    fn vec4_rem<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> Vec4<<Self as Rem<T2>>::Output>
    where
        Self: Rem<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).rem(other.index(i)))
    }

    /// Overridable implementation of `Vector::shl` for aligned vec2s.
    #[inline(always)]
    fn vec2_shl<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> Vec2<<Self as Shl<T2>>::Output>
    where
        Self: Shl<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).shl(other.index(i)))
    }

    /// Overridable implementation of `Vector::shl` for aligned vec3s.
    #[inline(always)]
    fn vec3_shl<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> Vec3<<Self as Shl<T2>>::Output>
    where
        Self: Shl<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).shl(other.index(i)))
    }

    /// Overridable implementation of `Vector::shl` for aligned vec4s.
    #[inline(always)]
    fn vec4_shl<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> Vec4<<Self as Shl<T2>>::Output>
    where
        Self: Shl<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).shl(other.index(i)))
    }

    /// Overridable implementation of `Vector::shr` for aligned vec2s.
    #[inline(always)]
    fn vec2_shr<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> Vec2<<Self as Shr<T2>>::Output>
    where
        Self: Shr<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).shr(other.index(i)))
    }

    /// Overridable implementation of `Vector::shr` for aligned vec3s.
    #[inline(always)]
    fn vec3_shr<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> Vec3<<Self as Shr<T2>>::Output>
    where
        Self: Shr<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).shr(other.index(i)))
    }

    /// Overridable implementation of `Vector::shr` for aligned vec4s.
    #[inline(always)]
    fn vec4_shr<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> Vec4<<Self as Shr<T2>>::Output>
    where
        Self: Shr<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).shr(other.index(i)))
    }

    /// Overridable implementation of `Vector::bitand` for aligned vec2s.
    #[inline(always)]
    fn vec2_bitand<T2: Scalar>(
        vec: Vec2<Self>,
        other: Vec2<T2>,
    ) -> Vec2<<Self as BitAnd<T2>>::Output>
    where
        Self: BitAnd<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitand(other.index(i)))
    }

    /// Overridable implementation of `Vector::bitand` for aligned vec3s.
    #[inline(always)]
    fn vec3_bitand<T2: Scalar>(
        vec: Vec3<Self>,
        other: Vec3<T2>,
    ) -> Vec3<<Self as BitAnd<T2>>::Output>
    where
        Self: BitAnd<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitand(other.index(i)))
    }

    /// Overridable implementation of `Vector::bitand` for aligned vec4s.
    #[inline(always)]
    fn vec4_bitand<T2: Scalar>(
        vec: Vec4<Self>,
        other: Vec4<T2>,
    ) -> Vec4<<Self as BitAnd<T2>>::Output>
    where
        Self: BitAnd<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitand(other.index(i)))
    }

    /// Overridable implementation of `Vector::bitor` for aligned vec2s.
    #[inline(always)]
    fn vec2_bitor<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> Vec2<<Self as BitOr<T2>>::Output>
    where
        Self: BitOr<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitor(other.index(i)))
    }

    /// Overridable implementation of `Vector::bitor` for aligned vec3s.
    #[inline(always)]
    fn vec3_bitor<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> Vec3<<Self as BitOr<T2>>::Output>
    where
        Self: BitOr<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitor(other.index(i)))
    }

    /// Overridable implementation of `Vector::bitor` for aligned vec4s.
    #[inline(always)]
    fn vec4_bitor<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> Vec4<<Self as BitOr<T2>>::Output>
    where
        Self: BitOr<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitor(other.index(i)))
    }

    /// Overridable implementation of `Vector::bitxor` for aligned vec2s.
    #[inline(always)]
    fn vec2_bitxor<T2: Scalar>(
        vec: Vec2<Self>,
        other: Vec2<T2>,
    ) -> Vec2<<Self as BitXor<T2>>::Output>
    where
        Self: BitXor<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitxor(other.index(i)))
    }

    /// Overridable implementation of `Vector::bitxor` for aligned vec3s.
    #[inline(always)]
    fn vec3_bitxor<T2: Scalar>(
        vec: Vec3<Self>,
        other: Vec3<T2>,
    ) -> Vec3<<Self as BitXor<T2>>::Output>
    where
        Self: BitXor<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitxor(other.index(i)))
    }

    /// Overridable implementation of `Vector::bitxor` for aligned vec4s.
    #[inline(always)]
    fn vec4_bitxor<T2: Scalar>(
        vec: Vec4<Self>,
        other: Vec4<T2>,
    ) -> Vec4<<Self as BitXor<T2>>::Output>
    where
        Self: BitXor<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitxor(other.index(i)))
    }

    /// Overridable implementation of aligned vec2 getters like `Vec2::x`.
    #[inline(always)]
    fn vec2_swizzle1<const SRC: usize>(vec: Vec2<Self>) -> Self {
        vec.index(SRC)
    }

    /// Overridable implementation of aligned vec2 swizzles that return vec2s, like `Vec2::xx`.
    #[inline(always)]
    fn vec2_swizzle2<const X_SRC: usize, const Y_SRC: usize>(vec: Vec2<Self>) -> Vec2<Self> {
        Vec2::from_array([vec.index(X_SRC), vec.index(Y_SRC)])
    }

    /// Overridable implementation of aligned vec2 swizzles that return vec3s, like `Vec2::xxy`.
    #[inline(always)]
    fn vec2_swizzle3<const X_SRC: usize, const Y_SRC: usize, const Z_SRC: usize>(
        vec: Vec2<Self>,
    ) -> Vec3<Self> {
        Vec3::from_array([vec.index(X_SRC), vec.index(Y_SRC), vec.index(Z_SRC)])
    }

    /// Overridable implementation of aligned vec2 swizzles that return vec4s, like `Vec2::xxyy`.
    #[inline(always)]
    fn vec2_swizzle4<
        const X_SRC: usize,
        const Y_SRC: usize,
        const Z_SRC: usize,
        const W_SRC: usize,
    >(
        vec: Vec2<Self>,
    ) -> Vec4<Self> {
        Vec4::from_array([
            vec.index(X_SRC),
            vec.index(Y_SRC),
            vec.index(Z_SRC),
            vec.index(W_SRC),
        ])
    }

    /// Overridable implementation of aligned vec3 getters like `Vec3::x`.
    #[inline(always)]
    fn vec3_swizzle1<const SRC: usize>(vec: Vec3<Self>) -> Self {
        vec.index(SRC)
    }

    /// Overridable implementation of aligned vec3 swizzles that return vec2s, like `Vec3::xy`.
    #[inline(always)]
    fn vec3_swizzle2<const X_SRC: usize, const Y_SRC: usize>(vec: Vec3<Self>) -> Vec2<Self> {
        Vec2::from_array([vec.index(X_SRC), vec.index(Y_SRC)])
    }

    /// Overridable implementation of aligned vec3 swizzles that return vec3s, like `Vec3::xyz`.
    #[inline(always)]
    fn vec3_swizzle3<const X_SRC: usize, const Y_SRC: usize, const Z_SRC: usize>(
        vec: Vec3<Self>,
    ) -> Vec3<Self> {
        Vec3::from_array([vec.index(X_SRC), vec.index(Y_SRC), vec.index(Z_SRC)])
    }

    /// Overridable implementation of aligned vec3 swizzles that return vec4s, like `Vec3::xyzy`.
    #[inline(always)]
    fn vec3_swizzle4<
        const X_SRC: usize,
        const Y_SRC: usize,
        const Z_SRC: usize,
        const W_SRC: usize,
    >(
        vec: Vec3<Self>,
    ) -> Vec4<Self> {
        Vec4::from_array([
            vec.index(X_SRC),
            vec.index(Y_SRC),
            vec.index(Z_SRC),
            vec.index(W_SRC),
        ])
    }

    /// Overridable implementation of aligned vec4 getters like `Vec4::x`.
    #[inline(always)]
    fn vec4_swizzle1<const SRC: usize>(vec: Vec4<Self>) -> Self {
        vec.index(SRC)
    }

    /// Overridable implementation of aligned vec4 swizzles that return vec2s, like `Vec4::xw`.
    #[inline(always)]
    fn vec4_swizzle2<const X_SRC: usize, const Y_SRC: usize>(vec: Vec4<Self>) -> Vec2<Self> {
        Vec2::from_array([vec.index(X_SRC), vec.index(Y_SRC)])
    }

    /// Overridable implementation of aligned vec4 swizzles that return vec3s, like `Vec4::xwx`.
    #[inline(always)]
    fn vec4_swizzle3<const X_SRC: usize, const Y_SRC: usize, const Z_SRC: usize>(
        vec: Vec4<Self>,
    ) -> Vec3<Self> {
        Vec3::from_array([vec.index(X_SRC), vec.index(Y_SRC), vec.index(Z_SRC)])
    }

    /// Overridable implementation of aligned vec4 swizzles that return vec4s, like `Vec4::xwxw`.
    #[inline(always)]
    fn vec4_swizzle4<
        const X_SRC: usize,
        const Y_SRC: usize,
        const Z_SRC: usize,
        const W_SRC: usize,
    >(
        vec: Vec4<Self>,
    ) -> Vec4<Self> {
        Vec4::from_array([
            vec.index(X_SRC),
            vec.index(Y_SRC),
            vec.index(Z_SRC),
            vec.index(W_SRC),
        ])
    }

    /// Overridable implementation of aligned vec2 "with swizzles" that replaces scalars, like `Vec2::with_x`.
    #[inline(always)]
    fn vec2_with_swizzle1<const DST: usize>(vec: Vec2<Self>, value: Self) -> Vec2<Self> {
        let mut output = vec;
        output.set(DST, value);

        output
    }

    /// Overridable implementation of aligned vec2 "with swizzles" that replaces vec2s, like `Vec2::with_xy`.
    #[inline(always)]
    fn vec2_with_swizzle2<const x_DST: usize, const y_DST: usize>(
        vec: Vec2<Self>,
        value: Self,
    ) -> Vec2<Self> {
        let mut output = vec;
        output.set(x_DST, value.index(0));
        output.set(y_DST, value.index(1));

        output
    }

    /// Overridable implementation of aligned vec3 "with swizzles" that replaces scalars, like `Vec3::with_y`.
    #[inline(always)]
    fn vec3_with_swizzle1<const DST: usize>(vec: Vec3<Self>, value: Self) -> Vec3<Self> {
        let mut output = vec;
        output.set(DST, value);

        output
    }

    /// Overridable implementation of aligned vec3 "with swizzles" that replaces vec2s, like `Vec3::with_yx`.
    #[inline(always)]
    fn vec3_with_swizzle2<const x_DST: usize, const y_DST: usize>(
        vec: Vec3<Self>,
        value: Self,
    ) -> Vec2<Self> {
        let mut output = vec;
        output.set(x_DST, value.index(0));
        output.set(y_DST, value.index(1));

        output
    }

    /// Overridable implementation of aligned vec3 "with swizzles" that replaces vec3s, like `Vec3::with_yxz`.
    #[inline(always)]
    fn vec3_with_swizzle3<const x_DST: usize, const y_DST: usize, const z_DST: usize>(
        vec: Vec3<Self>,
        value: Self,
    ) -> Vec3<Self> {
        let mut output = vec;
        output.set(x_DST, value.index(0));
        output.set(y_DST, value.index(1));
        output.set(z_DST, value.index(2));

        output
    }

    /// Overridable implementation of aligned vec4 "with swizzles" that replaces scalars, like `Vec4::with_y`.
    #[inline(always)]
    fn vec4_with_swizzle1<const DST: usize>(vec: Vec4<Self>, value: Self) -> Vec4<Self> {
        let mut output = vec;
        output.set(DST, value);

        output
    }

    /// Overridable implementation of aligned vec4 "with swizzles" that replaces vec2s, like `Vec4::with_yz`.
    #[inline(always)]
    fn vec4_with_swizzle2<const x_DST: usize, const y_DST: usize>(
        vec: Vec4<Self>,
        value: Self,
    ) -> Vec2<Self> {
        let mut output = vec;
        output.set(x_DST, value.index(0));
        output.set(y_DST, value.index(1));

        output
    }

    /// Overridable implementation of aligned vec4 "with swizzles" that replaces vec3s, like `Vec4::with_yzx`.
    #[inline(always)]
    fn vec4_with_swizzle3<const x_DST: usize, const y_DST: usize, const z_DST: usize>(
        vec: Vec4<Self>,
        value: Self,
    ) -> Vec3<Self> {
        let mut output = vec;
        output.set(x_DST, value.index(0));
        output.set(y_DST, value.index(1));
        output.set(z_DST, value.index(2));

        output
    }

    /// Overridable implementation of aligned vec4 "with swizzles" that replaces vec4s, like `Vec4::with_yzxw`.
    #[inline(always)]
    fn vec4_with_swizzle4<
        const x_DST: usize,
        const y_DST: usize,
        const z_DST: usize,
        const w_DST: usize,
    >(
        vec: Vec4<Self>,
        value: Self,
    ) -> Vec4<Self> {
        let mut output = vec;
        output.set(x_DST, value.index(0));
        output.set(y_DST, value.index(1));
        output.set(z_DST, value.index(2));
        output.set(w_DST, value.index(3));

        output
    }
}

/// See [`Vector`] for information.
pub trait VecAlignment: 'static {
    /// The inner type contained inside [`Vector`].
    ///
    /// For `VecAligned` vectors this is `T::InnerAlignedVec{N}`,
    /// for example `T::InnerAlignedVec2` for `Vec2`.
    ///
    /// For `VecPacked` vectors this is `[T; N]`,
    /// for example `[T; 2]` for `Vec2`.
    type InnerVector<const N: usize, T: Scalar>: Construct
    where
        Usize<N>: VecLen;

    /// Whether or not the vector is SIMD aligned.
    const IS_ALIGNED: bool;
}

/// See [`Vector`] for information.
pub struct VecAligned;

/// See [`Vector`] for information.
pub struct VecPacked;

impl VecLen for Usize<2> {
    type InnerAlignedVector<T: Scalar> = T::InnerAlignedVec2;

    const ENUM: VecLenEnum = VecLenEnum::Two;
}

impl VecLen for Usize<3> {
    type InnerAlignedVector<T: Scalar> = T::InnerAlignedVec3;

    const ENUM: VecLenEnum = VecLenEnum::Three;
}

impl VecLen for Usize<4> {
    type InnerAlignedVector<T: Scalar> = T::InnerAlignedVec4;

    const ENUM: VecLenEnum = VecLenEnum::Four;
}

impl VecAlignment for VecAligned {
    type InnerVector<const N: usize, T: Scalar>
        = <Usize<N> as VecLen>::InnerAlignedVector<T>
    where
        Usize<N>: VecLen;

    const IS_ALIGNED: bool = true;
}

impl VecAlignment for VecPacked {
    type InnerVector<const N: usize, T: Scalar>
        = [T; N]
    where
        Usize<N>: VecLen;

    const IS_ALIGNED: bool = false;
}

impl<const N: usize, T: Scalar, A: VecAlignment> Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    /// Returns true if the vector is aligned.
    /// The output is strictly determined by the type of the vector.
    #[inline(always)]
    pub const fn is_aligned(self) -> bool {
        A::IS_ALIGNED
    }

    /// Converts the vector to an aligned vector.
    #[inline(always)]
    pub fn align(self) -> Vector<N, T, VecAligned> {
        self.to_storage()
    }

    /// Converts the vector to a packed vector.
    #[inline(always)]
    pub fn pack(self) -> Vector<N, T, VecPacked> {
        self.to_storage()
    }

    /// Converts the vector to the specified alignment.
    #[inline(always)]
    pub fn to_storage<A2: VecAlignment>(self) -> Vector<N, T, A2> {
        match A::IS_ALIGNED {
            true => match A2::IS_ALIGNED {
                true => unsafe { transmute_copy::<Vector<N, T, A>, Vector<N, T, A2>>(&self) },
                false => Vector::from_array(self.to_array()),
            },
            false => match A2::IS_ALIGNED {
                true => Vector::from_array(self.to_array()),
                false => unsafe { transmute_copy::<Vector<N, T, A>, Vector<N, T, A2>>(&self) },
            },
        }
    }

    /// Creates a new vector from an array.
    #[inline(always)]
    pub fn from_array(array: [T; N]) -> Self {
        return_for_types! {
            (array: [T; N] => [T; 2]) -> Vector<2, T, VecAligned> => Vector<N, T, A> {
                |array| T::vec2_from_array(array)
            }
        }

        return_for_types! {
            (array: [T; N] => [T; 3]) -> Vector<3, T, VecAligned> => Vector<N, T, A> {
                |array| T::vec3_from_array(array)
            }
        }

        return_for_types! {
            (array: [T; N] => [T; 4]) -> Vector<4, T, VecAligned> => Vector<N, T, A> {
                |array| T::vec4_from_array(array)
            }
        }

        return_for_types! {
            (array: [T; N] => [T; N]) -> Vector<N, T, VecPacked> => Vector<N, T, A> {
                |array| Vector(array)
            }
        }

        unreachable!("unusual vector type")
    }

    /// Creates a new vector where each component is the same value.
    #[inline(always)]
    pub fn splat(value: T) -> Self {
        return_for_types! {
            (value: T => T) -> Vector<2, T, VecAligned> => Vector<N, T, A> {
                |value| T::vec2_splat(value)
            }
        }

        return_for_types! {
            (value: T => T) -> Vector<3, T, VecAligned> => Vector<N, T, A> {
                |value| T::vec3_splat(value)
            }
        }

        return_for_types! {
            (value: T => T) -> Vector<4, T, VecAligned> => Vector<N, T, A> {
                |value| T::vec4_splat(value)
            }
        }

        Vector::from_array([value; N])
    }

    /// Creates a new vector where each component is evaluated from the given function called with the component index.
    /// The function is called in order.
    #[inline(always)]
    pub fn from_fn<F: FnMut(usize) -> T>(f: F) -> Self {
        Vector::from_array(core::array::from_fn(f))
    }

    /// Returns the number of components in the vector.
    #[inline(always)]
    pub const fn len(self) -> usize {
        N
    }

    /// Converts the vector to an array.
    #[inline(always)]
    pub fn as_array(self) -> [T; N] {
        return_for_types! {
            (self: Vector<N, T, A> => Vector<2, T, VecAligned>) -> [T; 2] => [T; N] {
                |(vec,)| T::vec2_as_array(vec)
            }
        }

        return_for_types! {
            (self: Vector<N, T, A> => Vector<3, T, VecAligned>) -> [T; 3] => [T; N] {
                |(vec,)| T::vec3_as_array(vec)
            }
        }

        return_for_types! {
            (self: Vector<N, T, A> => Vector<4, T, VecAligned>) -> [T; 4] => [T; N] {
                |(vec,)| T::vec4_as_array(vec)
            }
        }

        return_for_types! {
            (self: Vector<N, T, A> => Vector<N, T, VecPacked>) -> [T; N] => [T; N] {
                |(vec,)| vec.0
            }
        }

        unreachable!("unusual vector type")
    }

    /// Returns the component at the given index or panics if the index is out of bounds.
    #[inline(always)]
    pub fn index(self, index: usize) -> T {
        self.as_array().index(index)
    }

    /// Returns the component at the given index or returns None if the index is out of bounds.
    #[inline(always)]
    pub fn get(self, index: usize) -> Option<T> {
        self.as_array().get(index)
    }

    /// Returns the component at the given index with no bounds checking.
    ///
    /// # Safety
    /// The caller must ensure that the index is in bounds.
    #[inline(always)]
    pub unsafe fn get_unchecked(self, index: usize) -> T {
        unsafe { self.as_array().get_unchecked(index) }
    }

    /// Sets the component at the given index or panics if the index is out of bounds.
    #[inline(always)]
    pub fn set(&mut self, index: usize, value: T) {
        let mut array = self.as_array();
        array[index] = value;
        *self = Self::from_array(array);
    }

    /// Sets the component at the given index or returns an error if the index is out of bounds.
    #[inline(always)]
    pub fn try_set(&mut self, index: usize, value: T) -> Result<(), IndexOutOfBoundsError> {
        if index >= N {
            return Err(IndexOutOfBoundsError);
        }

        unsafe { self.set_unchecked(index, value) }

        Ok(())
    }

    /// Sets the component at the given index with no bounds checking.
    ///
    /// # Safety
    /// The caller must ensure that the index is in bounds.
    #[inline(always)]
    pub unsafe fn set_unchecked(&mut self, index: usize, value: T) {
        let mut array = self.as_array();
        unsafe { *array.get_unchecked_mut(index) = value };
        *self = Self::from_array(array);
    }

    /// Maps each component of the vector to a new value using the given function.
    #[inline(always)]
    pub fn map<T2: Scalar, F: Fn(T) -> T2>(self, f: F) -> Vector<N, T2, A>
    where
        Usize<N>: VecLen,
    {
        Vector::from_array(self.as_array().map(f))
    }

    /// Folds the vector into a single value by repeatedly applying the given function to an accumulator on the vector's elements,
    /// using the given initial value.
    #[inline(always)]
    pub fn fold(self, init: T, mut f: impl FnMut(T, T) -> T) -> T {
        let mut output = init;

        for i in 0..N {
            output = f(output, self.index(i));
        }

        output
    }

    /// Reduces the vector into a single value by repeatedly applying the given function to an accumulator on the vector's elements,
    /// using the first component as the initial value.
    #[inline(always)]
    pub fn reduce(self, mut f: impl FnMut(T, T) -> T) -> T {
        let mut output = self.index(0);

        for i in 1..N {
            output = f(output, self.index(i));
        }

        output
    }

    /// Returns true if all components of the vector satisfy the given predicate.
    /// If a component does not satisfy the predicate,
    /// the function returns false immediately without evaluating the remaining components.
    #[inline(always)]
    pub fn all(self, f: impl FnMut(T) -> bool) -> bool {
        self.into_iter().all(f)
    }

    /// Returns true if any component of the vector satisfies the given predicate.
    /// If a component satisfies the predicate,
    /// the function returns true immediately without evaluating the remaining components.
    #[inline(always)]
    pub fn any(self, f: impl FnMut(T) -> bool) -> bool {
        self.into_iter().any(f)
    }

    /// Returns the number of components that satisfy the given predicate.
    #[inline(always)]
    pub fn count(self, mut f: impl FnMut(T) -> bool) -> usize {
        self.into_iter().filter(|x| f(*x)).count()
    }
}

impl<const N: usize, T: Scalar> Vector<N, T, VecPacked>
where
    Usize<N>: VecLen,
{
    /// Converts an array reference to a vector reference.
    #[inline(always)]
    pub const fn from_array_ref(array: &[T; N]) -> &Self {
        unsafe { transmute::<&[T; N], &Vector<N, T, VecPacked>>(array) }
    }

    /// Converts a mutable array reference to a mutable vector reference.
    #[inline(always)]
    pub const fn from_mut_array(array: &mut [T; N]) -> &mut Self {
        unsafe { transmute::<&mut [T; N], &mut Vector<N, T, VecPacked>>(array) }
    }

    /// Converts a vector reference to an array reference.
    #[inline(always)]
    pub const fn as_array_ref(&self) -> &[T; N] {
        &self.0
    }

    /// Converts a mutable vector reference to a mutable array reference.
    #[inline(always)]
    pub const fn as_mut_array(&mut self) -> &mut [T; N] {
        &mut self.0
    }

    /// Returns a pointer to the first element of the vector.
    #[inline(always)]
    pub const fn as_ptr(&self) -> *const T {
        self.0.as_ptr()
    }

    /// Returns a mutable pointer to the first element of the vector.
    #[inline(always)]
    pub const fn as_mut_ptr(&mut self) -> *mut T {
        self.0.as_mut_ptr()
    }
}

impl<const N: usize, T: Scalar, A: VecAlignment> Clone for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn clone(&self) -> Self {
        *self
    }
}

impl<const N: usize, T: Scalar, A: VecAlignment> Copy for Vector<N, T, A> where Usize<N>: VecLen {}

impl<const N: usize, T: Scalar, A: VecAlignment> IntoIterator for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Item = T;
    type IntoIter = <[T; N] as IntoIterator>::IntoIter;

    #[inline(always)]
    fn into_iter(self) -> Self::IntoIter {
        self.as_array().into_iter()
    }
}

impl<const N: usize, T: Scalar, I: SliceIndex<[T]>> Index<I> for Vector<N, T, VecPacked>
where
    Usize<N>: VecLen,
{
    type Output = I::Output;

    #[inline(always)]
    fn index(&self, index: I) -> &Self::Output {
        &self.0[index]
    }
}

impl<const N: usize, T: Scalar, I: SliceIndex<[T]>> IndexMut<I> for Vector<N, T, VecPacked>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn index_mut(&mut self, index: I) -> &mut Self::Output {
        &mut self.0[index]
    }
}

impl<const N: usize, T: Scalar + PartialEq<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    PartialEq<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn eq(&self, other: &Vector<N, T2, A2>) -> bool {
        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<2, T, VecAligned>,
                other: Vector<N, T2, A2> => Vector<2, T2, VecAligned>,
            ) -> bool => bool {
                |(vec, other)| T::vec2_eq(vec, other)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<3, T, VecAligned>,
                other: Vector<N, T2, A2> => Vector<3, T2, VecAligned>,
            ) -> bool => bool {
                |(vec, other)| T::vec3_eq(vec, other)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<4, T, VecAligned>,
                other: Vector<N, T2, A2> => Vector<4, T2, VecAligned>,
            ) -> bool => bool {
                |(vec, other)| T::vec4_eq(vec, other)
            }
        }

        (0..N).all(|i| self.index(i) == other.index(i))
    }

    #[inline(always)]
    fn ne(&self, other: &Vector<N, T2, A2>) -> bool {
        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<2, T, VecAligned>,
                other: Vector<N, T2, A2> => Vector<2, T2, VecAligned>,
            ) -> bool => bool {
                |(vec, other)| T::vec2_ne(vec, other)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<3, T, VecAligned>,
                other: Vector<N, T2, A2> => Vector<3, T2, VecAligned>,
            ) -> bool => bool {
                |(vec, other)| T::vec3_ne(vec, other)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<4, T, VecAligned>,
                other: Vector<N, T2, A2> => Vector<4, T2, VecAligned>,
            ) -> bool => bool {
                |(vec, other)| T::vec4_ne(vec, other)
            }
        }

        (0..N).any(|i| self.index(i) != other.index(i))
    }
}

impl<const N: usize, T: Scalar + Eq, A: VecAlignment> Eq for Vector<N, T, A> where Usize<N>: VecLen {}

impl<const N: usize, T: Scalar + Hash, A: VecAlignment> Hash for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.as_array().hash(state)
    }
}

impl<const N: usize, T: Scalar + Default, A: VecAlignment> Default for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn default() -> Self {
        Self::splat(T::default())
    }
}

impl<const N: usize, T: Scalar + Debug, A: VecAlignment> Debug for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "(")?;

        for i in 0..N {
            if i != 0 {
                write!(f, ", ")?;
            }

            write!(f, "{:?}", self.index(i))?;
        }

        write!(f, ")")?;

        Ok(())
    }
}

impl<const N: usize, T: Scalar + Display, A: VecAlignment> Display for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "(")?;

        for i in 0..N {
            if i != 0 {
                write!(f, ", ")?;
            }

            write!(f, "{}", self.index(i))?;
        }

        write!(f, ")")?;

        Ok(())
    }
}

impl<const N: usize, T: Scalar + Neg<Output: Scalar>, A: VecAlignment> Neg for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn neg(self) -> Self::Output {
        return_for_types! {
            (self: Vector<N, T, A> => Vector<2, T, VecAligned>) -> Vector<2, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec,)| T::vec2_neg(vec)
            }
        }

        return_for_types! {
            (self: Vector<N, T, A> => Vector<3, T, VecAligned>) -> Vector<3, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec,)| T::vec3_neg(vec)
            }
        }

        return_for_types! {
            (self: Vector<N, T, A> => Vector<4, T, VecAligned>) -> Vector<4, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec,)| T::vec4_neg(vec)
            }
        }

        self.map(|v| v.neg())
    }
}

impl<const N: usize, T: Scalar + Neg<Output: Scalar>, A: VecAlignment> Neg for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn neg(self) -> Self::Output {
        (*self).neg()
    }
}

impl<const N: usize, T: Scalar + Not<Output: Scalar>, A: VecAlignment> Not for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn not(self) -> Self::Output {
        return_for_types! {
            (self: Vector<N, T, A> => Vector<2, T, VecAligned>) -> Vector<2, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec,)| T::vec2_not(vec)
            }
        }

        return_for_types! {
            (self: Vector<N, T, A> => Vector<3, T, VecAligned>) -> Vector<3, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec,)| T::vec3_not(vec)
            }
        }

        return_for_types! {
            (self: Vector<N, T, A> => Vector<4, T, VecAligned>) -> Vector<4, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec,)| T::vec4_not(vec)
            }
        }

        self.map(|v| v.not())
    }
}

impl<const N: usize, T: Scalar + Not<Output: Scalar>, A: VecAlignment> Not for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn not(self) -> Self::Output {
        (*self).not()
    }
}

impl<
    const N: usize,
    T: Scalar + Add<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Add<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn add(self, rhs: Vector<N, T2, A2>) -> Self::Output {
        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<2, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<2, T2, VecAligned>,
            ) -> Vector<2, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec2_add(vec, rhs)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<3, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<3, T2, VecAligned>,
            ) -> Vector<3, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec3_add(vec, rhs)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<4, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<4, T2, VecAligned>,
            ) -> Vector<4, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec4_add(vec, rhs)
            }
        }

        Vector::from_fn(|i| self.index(i).add(rhs.index(i)))
    }
}

impl<
    const N: usize,
    T: Scalar + Add<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Add<Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn add(self, rhs: Vector<N, T2, A2>) -> Self::Output {
        (*self).add(rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Add<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Add<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn add(self, rhs: &Vector<N, T2, A2>) -> Self::Output {
        self.add(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Add<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Add<&Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn add(self, rhs: &Vector<N, T2, A2>) -> Self::Output {
        (*self).add(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Sub<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Sub<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn sub(self, rhs: Vector<N, T2, A2>) -> Self::Output {
        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<2, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<2, T2, VecAligned>,
            ) -> Vector<2, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec2_sub(vec, rhs)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<3, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<3, T2, VecAligned>,
            ) -> Vector<3, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec3_sub(vec, rhs)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<4, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<4, T2, VecAligned>,
            ) -> Vector<4, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec4_sub(vec, rhs)
            }
        }

        Vector::from_fn(|i| self.index(i).sub(rhs.index(i)))
    }
}

impl<
    const N: usize,
    T: Scalar + Sub<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Sub<Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn sub(self, rhs: Vector<N, T2, A2>) -> Self::Output {
        (*self).sub(rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Sub<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Sub<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn sub(self, rhs: &Vector<N, T2, A2>) -> Self::Output {
        self.sub(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Sub<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Sub<&Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn sub(self, rhs: &Vector<N, T2, A2>) -> Self::Output {
        (*self).sub(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Mul<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Mul<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn mul(self, rhs: Vector<N, T2, A2>) -> Self::Output {
        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<2, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<2, T2, VecAligned>,
            ) -> Vector<2, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec2_mul(vec, rhs)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<3, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<3, T2, VecAligned>,
            ) -> Vector<3, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec3_mul(vec, rhs)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<4, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<4, T2, VecAligned>,
            ) -> Vector<4, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec4_mul(vec, rhs)
            }
        }

        Vector::from_fn(|i| self.index(i).mul(rhs.index(i)))
    }
}

impl<
    const N: usize,
    T: Scalar + Mul<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Mul<Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn mul(self, rhs: Vector<N, T2, A2>) -> Self::Output {
        (*self).mul(rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Mul<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Mul<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn mul(self, rhs: &Vector<N, T2, A2>) -> Self::Output {
        self.mul(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Mul<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Mul<&Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn mul(self, rhs: &Vector<N, T2, A2>) -> Self::Output {
        (*self).mul(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Div<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Div<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn div(self, rhs: Vector<N, T2, A2>) -> Self::Output {
        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<2, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<2, T2, VecAligned>,
            ) -> Vector<2, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec2_div(vec, rhs)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<3, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<3, T2, VecAligned>,
            ) -> Vector<3, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec3_div(vec, rhs)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<4, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<4, T2, VecAligned>,
            ) -> Vector<4, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec4_div(vec, rhs)
            }
        }

        Vector::from_fn(|i| self.index(i).div(rhs.index(i)))
    }
}

impl<
    const N: usize,
    T: Scalar + Div<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Div<Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn div(self, rhs: Vector<N, T2, A2>) -> Self::Output {
        (*self).div(rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Div<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Div<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn div(self, rhs: &Vector<N, T2, A2>) -> Self::Output {
        self.div(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Div<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Div<&Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn div(self, rhs: &Vector<N, T2, A2>) -> Self::Output {
        (*self).div(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Rem<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Rem<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn rem(self, rhs: Vector<N, T2, A2>) -> Self::Output {
        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<2, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<2, T2, VecAligned>,
            ) -> Vector<2, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec2_rem(vec, rhs)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<3, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<3, T2, VecAligned>,
            ) -> Vector<3, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec3_rem(vec, rhs)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<4, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<4, T2, VecAligned>,
            ) -> Vector<4, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec4_rem(vec, rhs)
            }
        }

        Vector::from_fn(|i| self.index(i).rem(rhs.index(i)))
    }
}

impl<
    const N: usize,
    T: Scalar + Rem<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Rem<Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn rem(self, rhs: Vector<N, T2, A2>) -> Self::Output {
        (*self).rem(rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Rem<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Rem<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn rem(self, rhs: &Vector<N, T2, A2>) -> Self::Output {
        self.rem(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Rem<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Rem<&Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn rem(self, rhs: &Vector<N, T2, A2>) -> Self::Output {
        (*self).rem(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Shl<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Shl<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn shl(self, rhs: Vector<N, T2, A2>) -> Self::Output {
        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<2, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<2, T2, VecAligned>,
            ) -> Vector<2, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec2_shl(vec, rhs)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<3, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<3, T2, VecAligned>,
            ) -> Vector<3, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec3_shl(vec, rhs)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<4, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<4, T2, VecAligned>,
            ) -> Vector<4, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec4_shl(vec, rhs)
            }
        }

        Vector::from_fn(|i| self.index(i).shl(rhs.index(i)))
    }
}

impl<
    const N: usize,
    T: Scalar + Shl<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Shl<Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn shl(self, rhs: Vector<N, T2, A2>) -> Self::Output {
        (*self).shl(rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Shl<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Shl<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn shl(self, rhs: &Vector<N, T2, A2>) -> Self::Output {
        self.shl(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Shl<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Shl<&Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn shl(self, rhs: &Vector<N, T2, A2>) -> Self::Output {
        (*self).shl(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Shr<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Shr<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn shr(self, rhs: Vector<N, T2, A2>) -> Self::Output {
        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<2, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<2, T2, VecAligned>,
            ) -> Vector<2, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec2_shr(vec, rhs)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<3, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<3, T2, VecAligned>,
            ) -> Vector<3, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec3_shr(vec, rhs)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<4, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<4, T2, VecAligned>,
            ) -> Vector<4, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec4_shr(vec, rhs)
            }
        }

        Vector::from_fn(|i| self.index(i).shr(rhs.index(i)))
    }
}

impl<
    const N: usize,
    T: Scalar + Shr<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Shr<Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn shr(self, rhs: Vector<N, T2, A2>) -> Self::Output {
        (*self).shr(rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Shr<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Shr<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn shr(self, rhs: &Vector<N, T2, A2>) -> Self::Output {
        self.shr(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Shr<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Shr<&Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn shr(self, rhs: &Vector<N, T2, A2>) -> Self::Output {
        (*self).shr(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + BitAnd<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitAnd<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitand(self, rhs: Vector<N, T2, A2>) -> Self::Output {
        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<2, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<2, T2, VecAligned>,
            ) -> Vector<2, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec2_bitand(vec, rhs)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<3, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<3, T2, VecAligned>,
            ) -> Vector<3, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec3_bitand(vec, rhs)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<4, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<4, T2, VecAligned>,
            ) -> Vector<4, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec4_bitand(vec, rhs)
            }
        }

        Vector::from_fn(|i| self.index(i).bitand(rhs.index(i)))
    }
}

impl<
    const N: usize,
    T: Scalar + BitAnd<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitAnd<Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitand(self, rhs: Vector<N, T2, A2>) -> Self::Output {
        (*self).bitand(rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + BitAnd<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitAnd<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitand(self, rhs: &Vector<N, T2, A2>) -> Self::Output {
        self.bitand(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + BitAnd<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitAnd<&Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitand(self, rhs: &Vector<N, T2, A2>) -> Self::Output {
        (*self).bitand(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + BitOr<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitOr<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitor(self, rhs: Vector<N, T2, A2>) -> Self::Output {
        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<2, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<2, T2, VecAligned>,
            ) -> Vector<2, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec2_bitor(vec, rhs)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<3, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<3, T2, VecAligned>,
            ) -> Vector<3, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec3_bitor(vec, rhs)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<4, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<4, T2, VecAligned>,
            ) -> Vector<4, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec4_bitor(vec, rhs)
            }
        }

        Vector::from_fn(|i| self.index(i).bitor(rhs.index(i)))
    }
}

impl<
    const N: usize,
    T: Scalar + BitOr<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitOr<Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitor(self, rhs: Vector<N, T2, A2>) -> Self::Output {
        (*self).bitor(rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + BitOr<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitOr<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitor(self, rhs: &Vector<N, T2, A2>) -> Self::Output {
        self.bitor(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + BitOr<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitOr<&Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitor(self, rhs: &Vector<N, T2, A2>) -> Self::Output {
        (*self).bitor(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + BitXor<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitXor<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitxor(self, rhs: Vector<N, T2, A2>) -> Self::Output {
        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<2, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<2, T2, VecAligned>,
            ) -> Vector<2, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec2_bitxor(vec, rhs)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<3, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<3, T2, VecAligned>,
            ) -> Vector<3, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec3_bitxor(vec, rhs)
            }
        }

        return_for_types! {
            (
                self: Vector<N, T, A> => Vector<4, T, VecAligned>,
                rhs: Vector<N, T2, A2> => Vector<4, T2, VecAligned>,
            ) -> Vector<4, T::Output, VecAligned> => Vector<N, T::Output, A> {
                |(vec, rhs)| T::vec4_bitxor(vec, rhs)
            }
        }

        Vector::from_fn(|i| self.index(i).bitxor(rhs.index(i)))
    }
}

impl<
    const N: usize,
    T: Scalar + BitXor<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitXor<Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitxor(self, rhs: Vector<N, T2, A2>) -> Self::Output {
        (*self).bitxor(rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + BitXor<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitXor<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitxor(self, rhs: &Vector<N, T2, A2>) -> Self::Output {
        self.bitxor(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + BitXor<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitXor<&Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitxor(self, rhs: &Vector<N, T2, A2>) -> Self::Output {
        (*self).bitxor(*rhs)
    }
}

impl<const N: usize, T: Scalar + Add<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    AddAssign<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn add_assign(&mut self, rhs: Vector<N, T2, A2>) {
        *self = (*self).add(rhs)
    }
}

impl<const N: usize, T: Scalar + Add<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    AddAssign<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn add_assign(&mut self, rhs: &Vector<N, T2, A2>) {
        *self = (*self).add(*rhs)
    }
}

impl<const N: usize, T: Scalar + Sub<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    SubAssign<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn sub_assign(&mut self, rhs: Vector<N, T2, A2>) {
        *self = (*self).sub(rhs)
    }
}

impl<const N: usize, T: Scalar + Sub<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    SubAssign<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn sub_assign(&mut self, rhs: &Vector<N, T2, A2>) {
        *self = (*self).sub(*rhs)
    }
}

impl<const N: usize, T: Scalar + Mul<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    MulAssign<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn mul_assign(&mut self, rhs: Vector<N, T2, A2>) {
        *self = (*self).mul(rhs)
    }
}

impl<const N: usize, T: Scalar + Mul<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    MulAssign<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn mul_assign(&mut self, rhs: &Vector<N, T2, A2>) {
        *self = (*self).mul(*rhs)
    }
}

impl<const N: usize, T: Scalar + Div<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    DivAssign<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn div_assign(&mut self, rhs: Vector<N, T2, A2>) {
        *self = (*self).div(rhs)
    }
}

impl<const N: usize, T: Scalar + Div<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    DivAssign<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn div_assign(&mut self, rhs: &Vector<N, T2, A2>) {
        *self = (*self).div(*rhs)
    }
}

impl<const N: usize, T: Scalar + Rem<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    RemAssign<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn rem_assign(&mut self, rhs: Vector<N, T2, A2>) {
        *self = (*self).rem(rhs)
    }
}

impl<const N: usize, T: Scalar + Rem<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    RemAssign<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn rem_assign(&mut self, rhs: &Vector<N, T2, A2>) {
        *self = (*self).rem(*rhs)
    }
}

impl<const N: usize, T: Scalar + Shl<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    ShlAssign<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn shl_assign(&mut self, rhs: Vector<N, T2, A2>) {
        *self = (*self).shl(rhs)
    }
}

impl<const N: usize, T: Scalar + Shl<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    ShlAssign<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn shl_assign(&mut self, rhs: &Vector<N, T2, A2>) {
        *self = (*self).shl(*rhs)
    }
}

impl<const N: usize, T: Scalar + Shr<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    ShrAssign<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn shr_assign(&mut self, rhs: Vector<N, T2, A2>) {
        *self = (*self).shr(rhs)
    }
}

impl<const N: usize, T: Scalar + Shr<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    ShrAssign<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn shr_assign(&mut self, rhs: &Vector<N, T2, A2>) {
        *self = (*self).shr(*rhs)
    }
}

impl<const N: usize, T: Scalar + BitAnd<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    BitAndAssign<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: Vector<N, T2, A2>) {
        *self = (*self).bitand(rhs)
    }
}

impl<const N: usize, T: Scalar + BitAnd<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    BitAndAssign<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: &Vector<N, T2, A2>) {
        *self = (*self).bitand(*rhs)
    }
}

impl<const N: usize, T: Scalar + BitOr<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    BitOrAssign<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: Vector<N, T2, A2>) {
        *self = (*self).bitor(rhs)
    }
}

impl<const N: usize, T: Scalar + BitOr<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    BitOrAssign<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: &Vector<N, T2, A2>) {
        *self = (*self).bitor(*rhs)
    }
}

impl<const N: usize, T: Scalar + BitXor<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    BitXorAssign<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: Vector<N, T2, A2>) {
        *self = (*self).bitxor(rhs)
    }
}

impl<const N: usize, T: Scalar + BitXor<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    BitXorAssign<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: &Vector<N, T2, A2>) {
        *self = (*self).bitxor(*rhs)
    }
}
