// This file was generated by a codegen tool.
// To modify this file, modify the source code of the codegen tool.

//! Vector related types and traits

use core::{
    fmt::{Debug, Display},
    hash::{Hash, Hasher},
    mem::transmute,
    ops::*,
    slice::SliceIndex,
};

use crate::{Construct, IndexOutOfBoundsError, Usize, sealed::Sealed, specialize};

mod constructor;
mod dir;
mod ops;
mod primitives;
mod scalar;
#[cfg(feature = "swizzle")]
mod swizzle;
pub use constructor::*;
pub use dir::*;
pub use scalar::*;

/// A generic vector type.
///
/// Is generic over 3 parameters:
/// - `N`: The length of the vector, which currently can be 2, 3 or 4
/// - `T`: The scalar type of the vector, which must implement [`Scalar`]
/// - `S`: The "simdness" of the vector, which must be either [`Simd`] or [`NonSimd`]
///
/// This type has very very useful type-aliases:
/// - `Vec{N}<T>` like [`Vec2<T>`] is for [`Simd`] vectors
/// - `Vec{N}S<T>` like [`Vec2S<T>`] is for [`NonSimd`] vectors ("s" stands for "scalar")
///
/// # Simdness
///
/// SIMD improves the performance of vector operations but increases the size of the vector in memory.
///
/// The `S` generic parameter controls whether or not the vector is SIMD.
/// [`Simd`] vectors are SIMD and [`NonSimd`] vectors are not.
///
/// Most of the time you should use [`Simd`] vectors (e.g. [`Vec3<T>`]),
/// and only use [`NonSimd`] vectors in memory-critical scenarios.
///
/// The exact vector layout rules are:
///
/// - [`NonSimd`] vectors are always stored as `[T; N]`.
///
/// - [`Simd`] vectors aren't actually guarenteed to be SIMD, especially if it doesn't have a performance benefit.
///
/// # Example
/// ```
/// use ggmath::*;
///
/// // This is a non memory critical scenario so we should use SIMD vectors.
/// struct PlayerState {
///     // Vector<3, f32, Simd>
///     position: Vec3<f32>,
/// }
///
/// // This is a memory critical scenario so we should use non-SIMD vectors.
/// struct GpuVertex {
///     // Vector<3, f32, NonSimd>
///     position: Vec3S<f32>,
///     // Vector<3, f32, NonSimd>
///     normal: Vec3S<f32>,
///     // Vector<2, f32, NonSimd>
///     uv: Vec2S<f32>,
/// }
///
/// fn initial_player_state() -> PlayerState {
///     PlayerState {
///         position: vec3!(0.0, 1.0, 2.0),
///     }
/// }
///
/// fn triangle_vertices() -> [GpuVertex; 3] {
///     [
///         GpuVertex {
///             position: vec3s!(-1.0, -1.0, 0.0),
///             normal: vec3s!(0.0, 0.0, 1.0),
///             uv: vec2s!(0.0, 0.0),
///         },
///         GpuVertex {
///             position: vec3s!(1.0, -1.0, 0.0),
///             normal: vec3s!(0.0, 0.0, 1.0),
///             uv: vec2s!(1.0, 0.0),
///         },
///         GpuVertex {
///             position: vec3s!(0.0, 1.0, 0.0),
///             normal: vec3s!(0.0, 0.0, 1.0),
///             uv: vec2s!(0.5, 1.0),
///         },
///     ]
/// }
/// ```
#[repr(transparent)]
pub struct Vector<const N: usize, T: Scalar, S: Simdness>(pub S::VectorStorage<N, T>)
where
    Usize<N>: VecLen;

/// Type alias for [`Vector<2, T, Simd>`][Vector].
pub type Vec2<T> = Vector<2, T, Simd>;

/// Type alias for [`Vector<3, T, Simd>`][Vector].
pub type Vec3<T> = Vector<3, T, Simd>;

/// Type alias for [`Vector<4, T, Simd>`][Vector].
pub type Vec4<T> = Vector<4, T, Simd>;

/// Type alias for [`Vector<2, T, NonSimd>`][Vector].
/// "S" stands for "scalar".
pub type Vec2S<T> = Vector<2, T, NonSimd>;

/// Type alias for [`Vector<3, T, NonSimd>`][Vector].
/// "S" stands for "scalar".
pub type Vec3S<T> = Vector<3, T, NonSimd>;

/// Type alias for [`Vector<4, T, NonSimd>`][Vector].
/// "S" stands for "scalar".
pub type Vec4S<T> = Vector<4, T, NonSimd>;

/// Generates vector type-aliases for a specific scalar type.
///
/// # Example
///
/// ```
/// use ggmath::*;
///
/// vector_aliases!(pub type F => f32);
/// ```
/// Generates:
/// ```
/// use ggmath::*;
///
/// pub type FVec2 = Vec2<f32>;
/// pub type FVec3 = Vec3<f32>;
/// pub type FVec4 = Vec4<f32>;
/// pub type FVec2S = Vec2S<f32>;
/// pub type FVec3S = Vec3S<f32>;
/// pub type FVec4S = Vec4S<f32>;
/// ```
#[macro_export]
macro_rules! vector_aliases {
    ($(#[$($attr:tt)*])* pub($($vis:tt)*) type $prefix:ident => $t:ty) => {
        $crate::vector_aliases!(@(pub type $($vis)*) $(#[$($attr)*])* $prefix => $t);
    };
    ($(#[$($attr:tt)*])* pub type $prefix:ident => $t:ty) => {
        $crate::vector_aliases!(@(pub) $(#[$($attr)*])* type $prefix => $t);
    };
    ($(#[$($attr:tt)*])* type $prefix:ident => $t:ty) => {
        $crate::vector_aliases!(@() $(#[$($attr)*])* type $prefix => $t);
    };

    (@($($vis:tt)*) $(#[$($attr:tt)*])* type $prefix:ident => $t:ty) => {
        $crate::hidden::paste! {
            #[doc = "Type alias to [`Vector<2, " $t ", Simd>`][Vector]."]
            $(#[$($attr)*])*
            $($vis)* type [<$prefix Vec2>] = $crate::Vec2<$t>;

            #[doc = "Type alias to [`Vector<2, " $t ", NonSimd>`][Vector]."]
            #[doc = "\"S\" stands for \"scalar\"."]
            $(#[$($attr)*])*
            $($vis)* type [<$prefix Vec2S>] = $crate::Vec2S<$t>;

            #[doc = "Type alias to [`Vector<3, " $t ", Simd>`][Vector]."]
            $(#[$($attr)*])*
            $($vis)* type [<$prefix Vec3>] = $crate::Vec3<$t>;

            #[doc = "Type alias to [`Vector<3, " $t ", NonSimd>`][Vector]."]
            #[doc = "\"S\" stands for \"scalar\"."]
            $(#[$($attr)*])*
            $($vis)* type [<$prefix Vec3S>] = $crate::Vec3S<$t>;

            #[doc = "Type alias to [`Vector<4, " $t ", Simd>`][Vector]."]
            $(#[$($attr)*])*
            $($vis)* type [<$prefix Vec4>] = $crate::Vec4<$t>;

            #[doc = "Type alias to [`Vector<4, " $t ", NonSimd>`][Vector]."]
            #[doc = "\"S\" stands for \"scalar\"."]
            $(#[$($attr)*])*
            $($vis)* type [<$prefix Vec4S>] = $crate::Vec4S<$t>;
        }
    };
}

/// Marks a `Usize<N>` type as a valid vector length.
pub trait VecLen: Sealed {
    /// Returns the appropriate type for the given vector length (`T2` for `Usize<2>`, `T3` for `Usize<3>`, etc.).
    type Match<T2: Construct, T3: Construct, T4: Construct>: Construct;

    /// The length value as an enum.
    const ENUM: VecLenEnum;
}

/// An enum with all currently supported vector lengths.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum VecLenEnum {
    /// `2`
    Two,
    /// `3`
    Three,
    /// `4`
    Four,
}

/// See [`Vector`] for information.
pub trait Simdness: Sealed + 'static {
    /// The inner type contained inside [`Vector`].
    type VectorStorage<const N: usize, T: Scalar>: Construct
    where
        Usize<N>: VecLen;

    /// Whether or not the vector is SIMD.
    /// Is `true` for `Simd` and `false` for `NonSimd`.
    const IS_SIMD: bool;
}

/// See [`Vector`] for information.
pub struct Simd;

/// See [`Vector`] for information.
pub struct NonSimd;

impl VecLen for Usize<2> {
    type Match<T2: Construct, T3: Construct, T4: Construct> = T2;

    const ENUM: VecLenEnum = VecLenEnum::Two;
}

impl VecLen for Usize<3> {
    type Match<T2: Construct, T3: Construct, T4: Construct> = T3;

    const ENUM: VecLenEnum = VecLenEnum::Three;
}

impl VecLen for Usize<4> {
    type Match<T2: Construct, T3: Construct, T4: Construct> = T4;

    const ENUM: VecLenEnum = VecLenEnum::Four;
}

#[doc(hidden)]
impl Sealed for Usize<2> {}

#[doc(hidden)]
impl Sealed for Usize<3> {}

#[doc(hidden)]
impl Sealed for Usize<4> {}

impl Simdness for Simd {
    type VectorStorage<const N: usize, T: Scalar>
        = T::SimdVectorStorage<N>
    where
        Usize<N>: VecLen;

    const IS_SIMD: bool = true;
}

impl Simdness for NonSimd {
    type VectorStorage<const N: usize, T: Scalar>
        = [T; N]
    where
        Usize<N>: VecLen;

    const IS_SIMD: bool = false;
}

#[doc(hidden)]
impl Sealed for Simd {}
#[doc(hidden)]
impl Sealed for NonSimd {}

impl<const N: usize, T: Scalar, S: Simdness> Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    /// Picks the vector with the appropriate length.
    pub const fn pick_by_length(
        vec2: Vector<2, T, S>,
        vec3: Vector<3, T, S>,
        vec4: Vector<4, T, S>,
    ) -> Self
    where
        Usize<N>: VecLen,
    {
        unsafe {
            match N {
                2 => core::mem::transmute_copy::<Vector<2, T, S>, Vector<N, T, S>>(&vec2),
                3 => core::mem::transmute_copy::<Vector<3, T, S>, Vector<N, T, S>>(&vec3),
                4 => core::mem::transmute_copy::<Vector<4, T, S>, Vector<N, T, S>>(&vec4),
                _ => panic!("unusual vector length"),
            }
        }
    }

    /// Picks the vector with the appropriate simdness.
    pub const fn pick_by_simdness(
        simd_vec: Vector<N, T, Simd>,
        non_simd_vec: Vector<N, T, NonSimd>,
    ) -> Self
    where
        Usize<N>: VecLen,
    {
        unsafe {
            if S::IS_SIMD {
                core::mem::transmute_copy::<Vector<N, T, Simd>, Vector<N, T, S>>(&simd_vec)
            } else {
                core::mem::transmute_copy::<Vector<N, T, NonSimd>, Vector<N, T, S>>(&non_simd_vec)
            }
        }
    }

    /// Returns `true` for `Simd` vectors and `false` for `NonSimd` vectors.
    #[inline(always)]
    pub const fn is_simd(self) -> bool {
        S::IS_SIMD
    }

    /// Converts the vector to a `Simd` vector.
    #[inline(always)]
    pub fn as_simd(self) -> Vector<N, T, Simd> {
        self.as_storage()
    }

    /// Converts the vector to a `NonSimd` vector.
    #[inline(always)]
    pub fn as_non_simd(self) -> Vector<N, T, NonSimd> {
        self.as_storage()
    }

    /// Converts the vector to the specified simdness.
    #[inline(always)]
    pub fn as_storage<S2: Simdness>(self) -> Vector<N, T, S2> {
        specialize! {
            (self: Vector<N, T, S>) -> Vector<N, T, S2>:

            for (Vector<N, T, S>) -> Vector<N, T, S> {
                |vec| vec
            }
            else {
                Vector::from_array(self.as_array())
            }
        }
    }

    /// Creates a new vector from an array.
    #[inline(always)]
    pub fn from_array(array: [T; N]) -> Self {
        specialize! {
            (array: [T; N]) -> Vector<N, T, S>:

            for ([T; N]) -> Vector<N, T, Simd> {
                |array| T::vec_from_array(array)
            } for ([T; N]) -> Vector<N, T, NonSimd> {
                |array| Vector(array)
            } else {
                unreachable!("unusual vector type")
            }
        }
    }

    /// Creates a new vector where each component is the same value.
    #[inline(always)]
    pub fn splat(value: T) -> Self {
        specialize! {
            (value: T) -> Vector<N, T, S>:

            for (T) -> Vector<N, T, Simd> {
                |value| T::vec_splat(value)
            } else {
                Vector::from_array([value; N])
            }
        }
    }

    /// Creates a new vector where each component is evaluated from the given function called with the component index.
    /// The function is called in order.
    #[inline(always)]
    pub fn from_fn<F: FnMut(usize) -> T>(f: F) -> Self {
        Vector::from_array(core::array::from_fn(f))
    }

    /// Returns the number of components in the vector.
    #[inline(always)]
    pub const fn len(self) -> usize {
        N
    }

    /// Converts the vector to an array.
    #[inline(always)]
    pub fn as_array(self) -> [T; N] {
        specialize! {
            (self: Vector<N, T, S>) -> [T; N]:

            for (Vector<N, T, Simd>) -> [T; N] {
                |vec| T::vec_as_array(vec)
            } for (Vector<N, T, NonSimd>) -> [T; N] {
                |vec| vec.0
            } else {
                unreachable!("unusual vector type")
            }
        }
    }

    /// Returns the component at the given index or panics if the index is out of bounds.
    #[inline(always)]
    pub fn index(self, index: usize) -> T {
        if index >= N {
            panic!("index out of bounds: the len is {N} but the index is {index}");
        }

        unsafe { self.get_unchecked(index) }
    }

    /// Returns the component at the given index or returns None if the index is out of bounds.
    #[inline(always)]
    pub fn get(self, index: usize) -> Option<T> {
        if index >= N {
            None
        } else {
            Some(unsafe { self.get_unchecked(index) })
        }
    }

    /// Returns the component at the given index with no bounds checking.
    ///
    /// # Safety
    /// The caller must ensure that the index is in bounds.
    #[inline(always)]
    pub unsafe fn get_unchecked(self, index: usize) -> T {
        specialize! {
            (self: Vector<N, T, S>, index: usize) -> T:

            for (Vector<N, T, Simd>, usize) -> T {
                |vec, index| unsafe { T::vec_get_unchecked(vec, index) }
            }
            else {
                unsafe { *self.as_array().get_unchecked(index) }
            }
        }
    }

    /// Sets the component at the given index or panics if the index is out of bounds.
    #[inline(always)]
    pub fn set(&mut self, index: usize, value: T) {
        if index >= N {
            panic!("index out of bounds: the len is {N} but the index is {index}");
        }

        unsafe { self.set_unchecked(index, value) }
    }

    /// Sets the component at the given index or returns an error if the index is out of bounds.
    #[inline(always)]
    pub fn try_set(&mut self, index: usize, value: T) -> Result<(), IndexOutOfBoundsError> {
        if index >= N {
            Err(IndexOutOfBoundsError)
        } else {
            unsafe { self.set_unchecked(index, value) }

            Ok(())
        }
    }

    /// Sets the component at the given index with no bounds checking.
    ///
    /// # Safety
    /// The caller must ensure that the index is in bounds.
    #[inline(always)]
    pub unsafe fn set_unchecked(&mut self, index: usize, value: T) {
        *self = specialize! {
            ((*self): Vector<N, T, S>, index: usize, value: T) -> Vector<N, T, S>:

            for (Vector<N, T, Simd>, usize, T) -> Vector<N, T, Simd> {
                |vec, index, value| unsafe { T::vec_with_unchecked(vec, index, value) }
            } else {
                let mut array = self.as_array();
                unsafe {
                    *array.get_unchecked_mut(index) = value;
                }

                Vector::from_array(array)
            }
        };
    }

    /// Returns a vec2 where:
    /// - The `x` (1st) component is `self[X_SRC]`
    /// - The `y` (2nd) component is `self[Y_SRC]`
    ///
    /// Out of bounds indices are compile time errors.
    #[inline(always)]
    pub fn shuffle_2<const X_SRC: usize, const Y_SRC: usize>(self) -> Vector<2, T, S> {
        specialize! {
            (self: Vector<N, T, S>) -> Vector<2, T, S>:

            for (Vector<N, T, Simd>) -> Vector<2, T, Simd> {
                |vec| T::vec_shuffle_2::<N, X_SRC, Y_SRC>(vec)
            }
            else {
                Vector::<2, T, S>::from_array([self.index(X_SRC), self.index(Y_SRC)])
            }
        }
    }

    /// Returns a vec3 where:
    /// - The `x` (1st) component is `self[X_SRC]`
    /// - The `y` (2nd) component is `self[Y_SRC]`
    /// - The `z` (3rd) component is `self[Z_SRC]`
    ///
    /// Out of bounds indices are compile time errors.
    #[inline(always)]
    pub fn shuffle_3<const X_SRC: usize, const Y_SRC: usize, const Z_SRC: usize>(
        self,
    ) -> Vector<3, T, S> {
        specialize! {
            (self: Vector<N, T, S>) -> Vector<3, T, S>:

            for (Vector<N, T, Simd>) -> Vector<3, T, Simd> {
                |vec| T::vec_shuffle_3::<N, X_SRC, Y_SRC, Z_SRC>(vec)
            }
            else {
                Vector::<3, T, S>::from_array([self.index(X_SRC), self.index(Y_SRC), self.index(Z_SRC)])
            }
        }
    }

    /// Returns a vec4 where:
    /// - The `x` (1st) component is `self[X_SRC]`
    /// - The `y` (2nd) component is `self[Y_SRC]`
    /// - The `z` (3rd) component is `self[Z_SRC]`
    /// - The `w` (4th) component is `self[W_SRC]`
    ///
    /// Out of bounds indices are compile time errors.
    #[inline(always)]
    pub fn shuffle_4<
        const X_SRC: usize,
        const Y_SRC: usize,
        const Z_SRC: usize,
        const W_SRC: usize,
    >(
        self,
    ) -> Vector<4, T, S> {
        specialize! {
            (self: Vector<N, T, S>) -> Vector<4, T, S>:

            for (Vector<N, T, Simd>) -> Vector<4, T, Simd> {
                |vec| T::vec_shuffle_4::<N, X_SRC, Y_SRC, Z_SRC, W_SRC>(vec)
            }
            else {
                Vector::<4, T, S>::from_array([self.index(X_SRC), self.index(Y_SRC), self.index(Z_SRC), self.index(W_SRC)])
            }
        }
    }

    /// Maps each component of the vector to a new value using the given function.
    #[inline(always)]
    pub fn map<T2: Scalar, F: Fn(T) -> T2>(self, f: F) -> Vector<N, T2, S>
    where
        Usize<N>: VecLen,
    {
        Vector::from_array(self.as_array().map(f))
    }

    /// Returns an iterator over the components of the vector.
    #[inline(always)]
    pub fn iter(self) -> <[T; N] as IntoIterator>::IntoIter {
        self.into_iter()
    }

    /// Folds the vector into a single value by repeatedly applying the given function to an accumulator on the vector's elements,
    /// using the given initial value.
    #[inline(always)]
    pub fn fold(self, init: T, mut f: impl FnMut(T, T) -> T) -> T {
        let mut output = init;

        for component in self {
            output = f(output, component);
        }

        output
    }

    /// Reduces the vector into a single value by repeatedly applying the given function to an accumulator on the vector's elements,
    /// using the first component as the initial value.
    #[inline(always)]
    pub fn reduce(self, mut f: impl FnMut(T, T) -> T) -> T {
        let mut output = self.index(0);

        for component in self.iter().skip(1) {
            output = f(output, component);
        }

        output
    }

    /// Returns true if all components of the vector satisfy the given predicate.
    /// If a component does not satisfy the predicate,
    /// the function returns false immediately without evaluating the remaining components.
    #[inline(always)]
    pub fn all(self, f: impl FnMut(T) -> bool) -> bool {
        self.iter().all(f)
    }

    /// Returns true if any component of the vector satisfies the given predicate.
    /// If a component satisfies the predicate,
    /// the function returns true immediately without evaluating the remaining components.
    #[inline(always)]
    pub fn any(self, f: impl FnMut(T) -> bool) -> bool {
        self.iter().any(f)
    }

    /// Returns the number of components that satisfy the given predicate.
    #[inline(always)]
    pub fn count(self, mut f: impl FnMut(T) -> bool) -> usize {
        self.iter().filter(|x| f(*x)).count()
    }

    /// Returns a vector of booleans where each component is `true` if the corresponding component of `self` is equal to the corresponding component of `other`.
    #[inline(always)]
    pub fn eq_mask<T2: Scalar>(self, other: Vector<N, T2, S>) -> Vector<N, bool, S>
    where
        T: PartialEq<T2>,
    {
        specialize! {
            (self: Vector<N, T, S>, other: Vector<N, T2, S>) -> Vector<N, bool, S>:

            for (Vector<N, T, Simd>, Vector<N, T2, Simd>) -> Vector<N, bool, Simd> {
                |vec, other| T::vec_eq_mask(vec, other)
            } else {
                Vector::from_fn(|i| self.index(i) == other.index(i))
            }
        }
    }

    /// Returns a vector of booleans where each component is `true` if the corresponding component of `self` is not equal to the corresponding component of `other`.
    #[inline(always)]
    pub fn ne_mask<T2: Scalar>(self, other: Vector<N, T2, S>) -> Vector<N, bool, S>
    where
        T: PartialEq<T2>,
    {
        specialize! {
            (self: Vector<N, T, S>, other: Vector<N, T2, S>) -> Vector<N, bool, S>:

            for (Vector<N, T, Simd>, Vector<N, T2, Simd>) -> Vector<N, bool, Simd> {
                |vec, other| T::vec_ne_mask(vec, other)
            } else {
                Vector::from_fn(|i| self.index(i) != other.index(i))
            }
        }
    }

    /// Returns a vector of booleans where each component is `true` if the corresponding component of `self` is less than the corresponding component of `other`.
    #[inline(always)]
    pub fn lt_mask<T2: Scalar>(self, other: Vector<N, T2, S>) -> Vector<N, bool, S>
    where
        T: PartialOrd<T2>,
    {
        specialize! {
            (self: Vector<N, T, S>, other: Vector<N, T2, S>) -> Vector<N, bool, S>:

            for (Vector<N, T, Simd>, Vector<N, T2, Simd>) -> Vector<N, bool, Simd> {
                |vec, other| T::vec_lt_mask(vec, other)
            } else {
                Vector::from_fn(|i| self.index(i) < other.index(i))
            }
        }
    }

    /// Returns a vector of booleans where each component is `true` if the corresponding component of `self` is less than or equal to the corresponding component of `other`.
    #[inline(always)]
    pub fn le_mask<T2: Scalar>(self, other: Vector<N, T2, S>) -> Vector<N, bool, S>
    where
        T: PartialOrd<T2>,
    {
        specialize! {
            (self: Vector<N, T, S>, other: Vector<N, T2, S>) -> Vector<N, bool, S>:

            for (Vector<N, T, Simd>, Vector<N, T2, Simd>) -> Vector<N, bool, Simd> {
                |vec, other| T::vec_le_mask(vec, other)
            } else {
                Vector::from_fn(|i| self.index(i) <= other.index(i))
            }
        }
    }

    /// Returns a vector of booleans where each component is `true` if the corresponding component of `self` is greater than the corresponding component of `other`.
    #[inline(always)]
    pub fn gt_mask<T2: Scalar>(self, other: Vector<N, T2, S>) -> Vector<N, bool, S>
    where
        T: PartialOrd<T2>,
    {
        specialize! {
            (self: Vector<N, T, S>, other: Vector<N, T2, S>) -> Vector<N, bool, S>:

            for (Vector<N, T, Simd>, Vector<N, T2, Simd>) -> Vector<N, bool, Simd> {
                |vec, other| T::vec_gt_mask(vec, other)
            } else {
                Vector::from_fn(|i| self.index(i) > other.index(i))
            }
        }
    }

    /// Returns a vector of booleans where each component is `true` if the corresponding component of `self` is greater than or equal to the corresponding component of `other`.
    #[inline(always)]
    pub fn ge_mask<T2: Scalar>(self, other: Vector<N, T2, S>) -> Vector<N, bool, S>
    where
        T: PartialOrd<T2>,
    {
        specialize! {
            (self: Vector<N, T, S>, other: Vector<N, T2, S>) -> Vector<N, bool, S>:

            for (Vector<N, T, Simd>, Vector<N, T2, Simd>) -> Vector<N, bool, Simd> {
                |vec, other| T::vec_ge_mask(vec, other)
            } else {
                Vector::from_fn(|i| self.index(i) >= other.index(i))
            }
        }
    }

    /// Returns the sum of the components of the vector.
    #[inline(always)]
    pub fn sum(self) -> T
    where
        T: Add<Output = T>,
    {
        specialize! {
            (self: Vector<N, T, S>) -> T:

            for (Vector<N, T, Simd>) -> T {
                |vec| T::vec_sum(vec)
            } else {
                self.reduce(|a, b| a + b)
            }
        }
    }

    /// Returns the product of the components of the vector.
    #[inline(always)]
    pub fn product(self) -> T
    where
        T: Mul<Output = T>,
    {
        specialize! {
            (self: Vector<N, T, S>) -> T:

            for (Vector<N, T, Simd>) -> T {
                |vec| T::vec_product(vec)
            } else {
                self.reduce(|a, b| a * b)
            }
        }
    }

    /// Returns the square of the magnitude of the vector.
    #[inline(always)]
    pub fn mag_sq(self) -> T
    where
        T: Add<Output = T> + Mul<Output = T>,
    {
        (self * self).sum()
    }

    /// Returns the dot product of `self` and `other`.
    #[inline(always)]
    pub fn dot(self, other: Self) -> T
    where
        T: Add<Output = T> + Mul<Output = T>,
    {
        (self * other).sum()
    }
}

impl<T: Scalar, S: Simdness> Vector<2, T, S> {
    /// Returns `self` rotated 90 degrees counter-clockwise.
    #[inline(always)]
    pub fn perp(self) -> Self
    where
        T: Neg<Output = T>,
    {
        vec2g!(-self.y(), self.x())
    }

    /// Returns the perpendicular dot product of `self` and `other`.
    #[inline(always)]
    pub fn perp_dot(self, other: Self) -> T
    where
        T: Mul<Output = T> + Sub<Output = T>,
    {
        self.x() * other.y() - self.y() * other.x()
    }

    /// Returns the `x` (1st) component of `self`.
    #[inline(always)]
    pub fn x(self) -> T {
        self.index(0)
    }

    /// Returns the `y` (2nd) component of `self`.
    #[inline(always)]
    pub fn y(self) -> T {
        self.index(1)
    }

    /// Returns `self` but with the `x` (1st) component set to `value`.
    #[inline(always)]
    pub fn with_x(self, value: T) -> Self {
        let mut output = self;
        output.set(0, value);
        output
    }

    /// Returns `self` but with the `y` (2nd) component set to `value`.
    #[inline(always)]
    pub fn with_y(self, value: T) -> Self {
        let mut output = self;
        output.set(1, value);
        output
    }

    /// Sets the `x` (1st) component of `self` to `value`.
    #[inline(always)]
    pub fn set_x(&mut self, value: T) {
        *self = self.with_x(value);
    }

    /// Sets the `y` (2nd) component of `self` to `value`.
    #[inline(always)]
    pub fn set_y(&mut self, value: T) {
        *self = self.with_y(value);
    }

    /// Returns `self` but with:
    /// - `self[X_DST]` set to the `x` (1st) component of `value`
    /// - `self[Y_DST]` set to the `y` (2nd) component of `value`
    ///
    /// Out of bounds indices are compile time errors.
    #[inline(always)]
    pub fn with_shuffle_2<const X_DST: usize, const Y_DST: usize>(
        self,
        value: Vector<2, T, S>,
    ) -> Self {
        specialize! {
            (self: Vector<2, T, S>, value: Vector<2, T, _>) -> Vector<2, T, S>:

            for (Vector<2, T, Simd>, Vector<2, T, Simd>) -> Vector<2, T, Simd> {
                |vec, value| T::vec_with_shuffle_2::<2, X_DST, Y_DST>(vec, value)
            } else {
                let mut output = self;
                output.set(X_DST, value.x());
                output.set(Y_DST, value.y());

                output
            }
        }
    }
}

impl<T: Scalar, S: Simdness> Vector<3, T, S> {
    /// Returns the cross product of `self` and `other`.
    #[inline(always)]
    pub fn cross(self, other: Self) -> Self
    where
        T: Mul<Output = T> + Sub<Output = T>,
    {
        self.yzx() * other.zxy() - self.zxy() * other.yzx()
    }

    /// Returns the `x` (1st) component of `self`.
    #[inline(always)]
    pub fn x(self) -> T {
        self.index(0)
    }

    /// Returns the `y` (2nd) component of `self`.
    #[inline(always)]
    pub fn y(self) -> T {
        self.index(1)
    }

    /// Returns the `z` (3rd) component of `self`.
    #[inline(always)]
    pub fn z(self) -> T {
        self.index(2)
    }

    /// Returns `self` but with the `x` (1st) component set to `value`.
    #[inline(always)]
    pub fn with_x(self, value: T) -> Self {
        let mut output = self;
        output.set(0, value);
        output
    }

    /// Returns `self` but with the `y` (2nd) component set to `value`.
    #[inline(always)]
    pub fn with_y(self, value: T) -> Self {
        let mut output = self;
        output.set(1, value);
        output
    }

    /// Returns `self` but with the `z` (3rd) component set to `value`.
    #[inline(always)]
    pub fn with_z(self, value: T) -> Self {
        let mut output = self;
        output.set(2, value);
        output
    }

    /// Sets the `x` (1st) component of `self` to `value`.
    #[inline(always)]
    pub fn set_x(&mut self, value: T) {
        *self = self.with_x(value);
    }

    /// Sets the `y` (2nd) component of `self` to `value`.
    #[inline(always)]
    pub fn set_y(&mut self, value: T) {
        *self = self.with_y(value);
    }

    /// Sets the `z` (3rd) component of `self` to `value`.
    #[inline(always)]
    pub fn set_z(&mut self, value: T) {
        *self = self.with_z(value);
    }

    /// Returns `self` but with:
    /// - `self[X_DST]` set to the `x` (1st) component of `value`
    /// - `self[Y_DST]` set to the `y` (2nd) component of `value`
    ///
    /// Out of bounds indices are compile time errors.
    #[inline(always)]
    pub fn with_shuffle_2<const X_DST: usize, const Y_DST: usize>(
        self,
        value: Vector<2, T, S>,
    ) -> Self {
        specialize! {
            (self: Vector<3, T, S>, value: Vector<2, T, _>) -> Vector<3, T, S>:

            for (Vector<3, T, Simd>, Vector<2, T, Simd>) -> Vector<3, T, Simd> {
                |vec, value| T::vec_with_shuffle_2::<3, X_DST, Y_DST>(vec, value)
            } else {
                let mut output = self;
                output.set(X_DST, value.x());
                output.set(Y_DST, value.y());

                output
            }
        }
    }

    /// Returns `self` but with:
    /// - `self[X_DST]` set to the `x` (1st) component of `value`
    /// - `self[Y_DST]` set to the `y` (2nd) component of `value`
    /// - `self[Z_DST]` set to the `z` (3rd) component of `value`
    ///
    /// Out of bounds indices are compile time errors.
    #[inline(always)]
    pub fn with_shuffle_3<const X_DST: usize, const Y_DST: usize, const Z_DST: usize>(
        self,
        value: Vector<3, T, S>,
    ) -> Self {
        specialize! {
            (self: Vector<3, T, S>, value: Vector<3, T, _>) -> Vector<3, T, S>:

            for (Vector<3, T, Simd>, Vector<3, T, Simd>) -> Vector<3, T, Simd> {
                |vec, value| T::vec_with_shuffle_3::<3, X_DST, Y_DST, Z_DST>(vec, value)
            } else {
                let mut output = self;
                output.set(X_DST, value.x());
                output.set(Y_DST, value.y());
                output.set(Z_DST, value.z());

                output
            }
        }
    }
}

impl<T: Scalar, S: Simdness> Vector<4, T, S> {
    /// Returns the `x` (1st) component of `self`.
    #[inline(always)]
    pub fn x(self) -> T {
        self.index(0)
    }

    /// Returns the `y` (2nd) component of `self`.
    #[inline(always)]
    pub fn y(self) -> T {
        self.index(1)
    }

    /// Returns the `z` (3rd) component of `self`.
    #[inline(always)]
    pub fn z(self) -> T {
        self.index(2)
    }

    /// Returns the `w` (4th) component of `self`.
    #[inline(always)]
    pub fn w(self) -> T {
        self.index(3)
    }

    /// Returns `self` but with the `x` (1st) component set to `value`.
    #[inline(always)]
    pub fn with_x(self, value: T) -> Self {
        let mut output = self;
        output.set(0, value);
        output
    }

    /// Returns `self` but with the `y` (2nd) component set to `value`.
    #[inline(always)]
    pub fn with_y(self, value: T) -> Self {
        let mut output = self;
        output.set(1, value);
        output
    }

    /// Returns `self` but with the `z` (3rd) component set to `value`.
    #[inline(always)]
    pub fn with_z(self, value: T) -> Self {
        let mut output = self;
        output.set(2, value);
        output
    }

    /// Returns `self` but with the `w` (4th) component set to `value`.
    #[inline(always)]
    pub fn with_w(self, value: T) -> Self {
        let mut output = self;
        output.set(3, value);
        output
    }

    /// Sets the `x` (1st) component of `self` to `value`.
    #[inline(always)]
    pub fn set_x(&mut self, value: T) {
        *self = self.with_x(value);
    }

    /// Sets the `y` (2nd) component of `self` to `value`.
    #[inline(always)]
    pub fn set_y(&mut self, value: T) {
        *self = self.with_y(value);
    }

    /// Sets the `z` (3rd) component of `self` to `value`.
    #[inline(always)]
    pub fn set_z(&mut self, value: T) {
        *self = self.with_z(value);
    }

    /// Sets the `w` (4th) component of `self` to `value`.
    #[inline(always)]
    pub fn set_w(&mut self, value: T) {
        *self = self.with_w(value);
    }

    /// Returns `self` but with:
    /// - `self[X_DST]` set to the `x` (1st) component of `value`
    /// - `self[Y_DST]` set to the `y` (2nd) component of `value`
    ///
    /// Out of bounds indices are compile time errors.
    #[inline(always)]
    pub fn with_shuffle_2<const X_DST: usize, const Y_DST: usize>(
        self,
        value: Vector<2, T, S>,
    ) -> Self {
        specialize! {
            (self: Vector<4, T, S>, value: Vector<2, T, _>) -> Vector<4, T, S>:

            for (Vector<4, T, Simd>, Vector<2, T, Simd>) -> Vector<4, T, Simd> {
                |vec, value| T::vec_with_shuffle_2::<4, X_DST, Y_DST>(vec, value)
            } else {
                let mut output = self;
                output.set(X_DST, value.x());
                output.set(Y_DST, value.y());

                output
            }
        }
    }

    /// Returns `self` but with:
    /// - `self[X_DST]` set to the `x` (1st) component of `value`
    /// - `self[Y_DST]` set to the `y` (2nd) component of `value`
    /// - `self[Z_DST]` set to the `z` (3rd) component of `value`
    ///
    /// Out of bounds indices are compile time errors.
    #[inline(always)]
    pub fn with_shuffle_3<const X_DST: usize, const Y_DST: usize, const Z_DST: usize>(
        self,
        value: Vector<3, T, S>,
    ) -> Self {
        specialize! {
            (self: Vector<4, T, S>, value: Vector<3, T, _>) -> Vector<4, T, S>:

            for (Vector<4, T, Simd>, Vector<3, T, Simd>) -> Vector<4, T, Simd> {
                |vec, value| T::vec_with_shuffle_3::<4, X_DST, Y_DST, Z_DST>(vec, value)
            } else {
                let mut output = self;
                output.set(X_DST, value.x());
                output.set(Y_DST, value.y());
                output.set(Z_DST, value.z());

                output
            }
        }
    }

    /// Returns `self` but with:
    /// - `self[X_DST]` set to the `x` (1st) component of `value`
    /// - `self[Y_DST]` set to the `y` (2nd) component of `value`
    /// - `self[Z_DST]` set to the `z` (3rd) component of `value`
    /// - `self[W_DST]` set to the `w` (4th) component of `value`
    ///
    /// Out of bounds indices are compile time errors.
    #[inline(always)]
    pub fn with_shuffle_4<
        const X_DST: usize,
        const Y_DST: usize,
        const Z_DST: usize,
        const W_DST: usize,
    >(
        self,
        value: Vector<4, T, S>,
    ) -> Self {
        specialize! {
            (self: Vector<4, T, S>, value: Vector<4, T, _>) -> Vector<4, T, S>:

            for (Vector<4, T, Simd>, Vector<4, T, Simd>) -> Vector<4, T, Simd> {
                |vec, value| T::vec_with_shuffle_4::<4, X_DST, Y_DST, Z_DST, W_DST>(vec, value)
            } else {
                let mut output = self;
                output.set(X_DST, value.x());
                output.set(Y_DST, value.y());
                output.set(Z_DST, value.z());
                output.set(W_DST, value.w());

                output
            }
        }
    }
}

impl<const N: usize, T: Scalar> Vector<N, T, NonSimd>
where
    Usize<N>: VecLen,
{
    /// Converts an array reference to a vector reference.
    #[inline(always)]
    pub const fn from_array_ref(array: &[T; N]) -> &Self {
        unsafe { transmute::<&[T; N], &Vector<N, T, NonSimd>>(array) }
    }

    /// Converts a mutable array reference to a mutable vector reference.
    #[inline(always)]
    pub const fn from_mut_array(array: &mut [T; N]) -> &mut Self {
        unsafe { transmute::<&mut [T; N], &mut Vector<N, T, NonSimd>>(array) }
    }

    /// Converts a vector reference to an array reference.
    #[inline(always)]
    pub const fn as_array_ref(&self) -> &[T; N] {
        &self.0
    }

    /// Converts a mutable vector reference to a mutable array reference.
    #[inline(always)]
    pub const fn as_mut_array(&mut self) -> &mut [T; N] {
        &mut self.0
    }

    /// Returns a pointer to the first element of the vector.
    #[inline(always)]
    pub const fn as_ptr(&self) -> *const T {
        self.0.as_ptr()
    }

    /// Returns a mutable pointer to the first element of the vector.
    #[inline(always)]
    pub const fn as_mut_ptr(&mut self) -> *mut T {
        self.0.as_mut_ptr()
    }

    /// Returns an iterator over the references to the components of the vector.
    #[inline(always)]
    pub fn iter_ref(&self) -> <&[T; N] as IntoIterator>::IntoIter {
        self.into_iter()
    }

    /// Returns an iterator over the mutable references to the components of the vector.
    #[inline(always)]
    pub fn iter_mut(&mut self) -> <&mut [T; N] as IntoIterator>::IntoIter {
        self.into_iter()
    }
}

impl<T: Scalar> Vector<2, T, NonSimd> {
    /// Returns a reference to the `x` (1st) component of `self`.
    #[inline(always)]
    pub const fn x_ref(&self) -> &T {
        &self.0[0]
    }

    /// Returns a reference to the `y` (2nd) component of `self`.
    #[inline(always)]
    pub const fn y_ref(&self) -> &T {
        &self.0[1]
    }

    /// Returns a mutable reference to the `x` (1st) component of `self`.
    #[inline(always)]
    pub const fn x_mut(&mut self) -> &mut T {
        &mut self.0[0]
    }

    /// Returns a mutable reference to the `y` (2nd) component of `self`.
    #[inline(always)]
    pub const fn y_mut(&mut self) -> &mut T {
        &mut self.0[1]
    }
}

impl<T: Scalar> Vector<3, T, NonSimd> {
    /// Returns a reference to the `x` (1st) component of `self`.
    #[inline(always)]
    pub const fn x_ref(&self) -> &T {
        &self.0[0]
    }

    /// Returns a reference to the `y` (2nd) component of `self`.
    #[inline(always)]
    pub const fn y_ref(&self) -> &T {
        &self.0[1]
    }

    /// Returns a reference to the `z` (3rd) component of `self`.
    #[inline(always)]
    pub const fn z_ref(&self) -> &T {
        &self.0[2]
    }

    /// Returns a mutable reference to the `x` (1st) component of `self`.
    #[inline(always)]
    pub const fn x_mut(&mut self) -> &mut T {
        &mut self.0[0]
    }

    /// Returns a mutable reference to the `y` (2nd) component of `self`.
    #[inline(always)]
    pub const fn y_mut(&mut self) -> &mut T {
        &mut self.0[1]
    }

    /// Returns a mutable reference to the `z` (3rd) component of `self`.
    #[inline(always)]
    pub const fn z_mut(&mut self) -> &mut T {
        &mut self.0[2]
    }
}

impl<T: Scalar> Vector<4, T, NonSimd> {
    /// Returns a reference to the `x` (1st) component of `self`.
    #[inline(always)]
    pub const fn x_ref(&self) -> &T {
        &self.0[0]
    }

    /// Returns a reference to the `y` (2nd) component of `self`.
    #[inline(always)]
    pub const fn y_ref(&self) -> &T {
        &self.0[1]
    }

    /// Returns a reference to the `z` (3rd) component of `self`.
    #[inline(always)]
    pub const fn z_ref(&self) -> &T {
        &self.0[2]
    }

    /// Returns a reference to the `w` (4th) component of `self`.
    #[inline(always)]
    pub const fn w_ref(&self) -> &T {
        &self.0[3]
    }

    /// Returns a mutable reference to the `x` (1st) component of `self`.
    #[inline(always)]
    pub const fn x_mut(&mut self) -> &mut T {
        &mut self.0[0]
    }

    /// Returns a mutable reference to the `y` (2nd) component of `self`.
    #[inline(always)]
    pub const fn y_mut(&mut self) -> &mut T {
        &mut self.0[1]
    }

    /// Returns a mutable reference to the `z` (3rd) component of `self`.
    #[inline(always)]
    pub const fn z_mut(&mut self) -> &mut T {
        &mut self.0[2]
    }

    /// Returns a mutable reference to the `w` (4th) component of `self`.
    #[inline(always)]
    pub const fn w_mut(&mut self) -> &mut T {
        &mut self.0[3]
    }
}

impl<const N: usize, T: Scalar, S: Simdness> Clone for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn clone(&self) -> Self {
        *self
    }
}

impl<const N: usize, T: Scalar, S: Simdness> Copy for Vector<N, T, S> where Usize<N>: VecLen {}

impl<const N: usize, T: Scalar, S: Simdness> IntoIterator for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Item = T;
    type IntoIter = <[T; N] as IntoIterator>::IntoIter;

    #[inline(always)]
    fn into_iter(self) -> Self::IntoIter {
        self.as_array().into_iter()
    }
}

impl<'a, const N: usize, T: Scalar> IntoIterator for &'a Vector<N, T, NonSimd>
where
    Usize<N>: VecLen,
{
    type Item = &'a T;
    type IntoIter = <&'a [T; N] as IntoIterator>::IntoIter;

    #[inline(always)]
    fn into_iter(self) -> Self::IntoIter {
        self.as_array_ref().into_iter()
    }
}

impl<'a, const N: usize, T: Scalar> IntoIterator for &'a mut Vector<N, T, NonSimd>
where
    Usize<N>: VecLen,
{
    type Item = &'a mut T;
    type IntoIter = <&'a mut [T; N] as IntoIterator>::IntoIter;

    #[inline(always)]
    fn into_iter(self) -> Self::IntoIter {
        self.as_mut_array().into_iter()
    }
}

impl<const N: usize, T: Scalar, I: SliceIndex<[T]>> Index<I> for Vector<N, T, NonSimd>
where
    Usize<N>: VecLen,
{
    type Output = I::Output;

    #[inline(always)]
    fn index(&self, index: I) -> &Self::Output {
        &self.0[index]
    }
}

impl<const N: usize, T: Scalar, I: SliceIndex<[T]>> IndexMut<I> for Vector<N, T, NonSimd>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn index_mut(&mut self, index: I) -> &mut Self::Output {
        &mut self.0[index]
    }
}

impl<const N: usize, T: Scalar + PartialEq<T2>, S: Simdness, T2: Scalar> PartialEq<Vector<N, T2, S>>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn eq(&self, other: &Vector<N, T2, S>) -> bool {
        specialize! {
            ((*self): Vector<N, T, S>, (*other): Vector<N, T2, S>) -> bool:

            for (Vector<N, T, Simd>, Vector<N, T2, Simd>) -> bool {
                |vec, other| T::vec_eq(vec, other)
            } else {
                self.iter().zip(*other).all(|(a, b)| a == b)
            }
        }
    }

    #[inline(always)]
    fn ne(&self, other: &Vector<N, T2, S>) -> bool {
        specialize! {
            ((*self): Vector<N, T, S>, (*other): Vector<N, T2, S>) -> bool:

            for (Vector<N, T, Simd>, Vector<N, T2, Simd>) -> bool {
                |vec, other| T::vec_ne(vec, other)
            } else {
                self.iter().zip(*other).any(|(a, b)| a != b)
            }
        }
    }
}

impl<const N: usize, T: Scalar + Eq, S: Simdness> Eq for Vector<N, T, S> where Usize<N>: VecLen {}

impl<const N: usize, T: Scalar + Hash, S: Simdness> Hash for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.as_array().hash(state)
    }
}

impl<const N: usize, T: Scalar + Default, S: Simdness> Default for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn default() -> Self {
        Self::splat(T::default())
    }
}

impl<const N: usize, T: Scalar + Debug, S: Simdness> Debug for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "(")?;

        for i in 0..N {
            if i != 0 {
                write!(f, ", ")?;
            }

            write!(f, "{:?}", self.index(i))?;
        }

        write!(f, ")")?;

        Ok(())
    }
}

impl<const N: usize, T: Scalar + Display, S: Simdness> Display for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "(")?;

        for i in 0..N {
            if i != 0 {
                write!(f, ", ")?;
            }

            write!(f, "{}", self.index(i))?;
        }

        write!(f, ")")?;

        Ok(())
    }
}
