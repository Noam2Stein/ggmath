// This file was automatically generated by ggmath's codegen tool.
// Do not modify this file directly!

use crate::{ElementOfVector, NonSimd, Simdness, Vector};

impl<const N: usize, S: Simdness> Vector<N, f64, S>
where
    f64: F64VectorApi<N, S>,
{
    /// Returns a vector with the largest integer less than or equal to each element of `self`.
    #[inline(always)]
    pub fn floor(self) -> Self {
        f64::vec_floor(self)
    }

    /// Returns a vector with the smallest integer greater than or equal to each element of `self`.
    #[inline(always)]
    pub fn ceil(self) -> Self {
        f64::vec_ceil(self)
    }

    /// Returns a vector with the nearest integer to each element of `self`.
    /// If an element is half-way between two integers, round away from `0.0`.
    #[inline(always)]
    pub fn round(self) -> Self {
        f64::vec_round(self)
    }

    /// Returns a vector with the integer part of each element of `self`.
    /// This means that each element is rounded towards zero.
    #[inline(always)]
    pub fn trunc(self) -> Self {
        f64::vec_trunc(self)
    }

    /// Returns a vector with the fractional part of each element of `self`.
    /// This is equivalent to `self - self.trunc()`.
    #[inline(always)]
    pub fn fract(self) -> Self {
        f64::vec_fract(self)
    }

    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error,
    /// yielding a more accurate result than an unfused multiply-add.
    ///
    /// Using `mul_add` *may* be more performant than an unfused multiply-add
    /// if the target architecture has a dedicated `fma` CPU instruction.
    /// However, this is not always true, and will be heavily dependent on designing
    /// algorithms with specific target hardware in mind.
    #[inline(always)]
    pub fn mul_add(self, a: Self, b: Self) -> Self {
        f64::vec_mul_add(self, a, b)
    }

    /// Calculates Euclidean division, the matching method for `rem_euclid`.
    #[inline(always)]
    pub fn div_euclid(self, rhs: Self) -> Self {
        f64::vec_div_euclid(self, rhs)
    }

    /// Calculates the least nonnegative remainder of `self (mod rhs)`.
    #[inline(always)]
    pub fn rem_euclid(self, rhs: Self) -> Self {
        f64::vec_rem_euclid(self, rhs)
    }

    /// Returns a vector with the square root of each element of `self`.
    ///
    /// Returns `NaN` for elements that are negative numbers other than `-0.0`,
    /// but only for those elements.
    #[inline(always)]
    pub fn sqrt(self) -> Self {
        f64::vec_sqrt(self)
    }

    /// Returns a vector with the sine of each element of `self`.
    #[inline(always)]
    pub fn sin(self) -> Self {
        f64::vec_sin(self)
    }

    /// Returns a vector with the cosine of each element of `self`.
    #[inline(always)]
    pub fn cos(self) -> Self {
        f64::vec_cos(self)
    }

    /// Returns a vector with the tangent of each element of `self`.
    #[inline(always)]
    pub fn tan(self) -> Self {
        f64::vec_tan(self)
    }

    /// Returns a vector with the arcsine of each element of `self`.
    #[inline(always)]
    pub fn asin(self) -> Self {
        f64::vec_asin(self)
    }

    /// Returns a vector with the arccosine of each element of `self`.
    #[inline(always)]
    pub fn acos(self) -> Self {
        f64::vec_acos(self)
    }

    /// Returns a vector with the arctangent of each element of `self`.
    #[inline(always)]
    pub fn atan(self) -> Self {
        f64::vec_atan(self)
    }

    /// Returns a vector with the reciprocal of each element of `self`, `1.0 / self`.
    #[inline(always)]
    pub fn recip(self) -> Self {
        f64::vec_recip(self)
    }

    /// Returns a vector with the maximum of each element of `self` and `other`.
    #[inline(always)]
    pub fn max(self, other: Self) -> Self {
        f64::vec_max(self, other)
    }

    /// Returns a vector with the minimum of each element of `self` and `other`.
    #[inline(always)]
    pub fn min(self, other: Self) -> Self {
        f64::vec_min(self, other)
    }

    /// Returns a vector with the midpoint of each element of `self` and `other`.
    #[inline(always)]
    pub fn midpoint(self, other: Self) -> Self {
        f64::vec_midpoint(self, other)
    }

    /// Returns a vector with the clamp of each element of `self` between each element of `min` and `max`.
    ///
    /// In release mode, semantics may differ if `min` is greater than `max` in any element,
    /// or if `min` or `max` is `NaN`.
    ///
    /// # Panics
    ///
    /// In debug mode, this will panic if `min` is greater than `max` in any element,
    /// or if `min` or `max` is `NaN`.
    #[inline(always)]
    pub fn clamp(self, min: Self, max: Self) -> Self {
        f64::vec_clamp(self, min, max)
    }

    /// Returns a vector with the absolute value of each element of `self`.
    #[inline(always)]
    pub fn abs(self) -> Self {
        f64::vec_abs(self)
    }

    /// Returns a vector with elements representing the sign of each element of `self`.
    ///
    /// - `1.0` if an element is positive, `+0.0` or `INFINITY`
    /// - `-1.0` if an element is negative, `-0.0` or `NEG_INFINITY`
    /// - `NaN` if the element is `NaN`.
    #[inline(always)]
    pub fn signum(self) -> Self {
        f64::vec_signum(self)
    }

    /// Returns a vector with the signs of `sign` and the magnitudes of `self`.
    ///
    /// Sign of `0.0` is considered positive.
    #[inline(always)]
    pub fn copysign(self, sign: Self) -> Self {
        f64::vec_copysign(self, sign)
    }

    /// Returns the sum of all elements of `self`.
    /// Equivalent to `self.x + self.y + ..`.
    #[inline(always)]
    pub fn sum(self) -> f64 {
        f64::vec_sum(self)
    }

    /// Returns the product of all elements of `self`.
    /// Equivalent to `self.x * self.y * ..`.
    #[inline(always)]
    pub fn product(self) -> f64 {
        f64::vec_product(self)
    }
}

/// TODO: make this pub(crate)
pub trait F64VectorApi<const N: usize, S: Simdness>
where
    f64: ElementOfVector<N, S>,
{
    /// TODO: make this pub(crate)
    fn vec_floor(vec: Vector<N, f64, S>) -> Vector<N, f64, S> {
        vec.map(f64::floor)
    }

    /// TODO: make this pub(crate)
    fn vec_ceil(vec: Vector<N, f64, S>) -> Vector<N, f64, S> {
        vec.map(f64::ceil)
    }

    /// TODO: make this pub(crate)
    fn vec_round(vec: Vector<N, f64, S>) -> Vector<N, f64, S> {
        vec.map(f64::round)
    }

    /// TODO: make this pub(crate)
    fn vec_trunc(vec: Vector<N, f64, S>) -> Vector<N, f64, S> {
        vec.map(f64::trunc)
    }

    /// TODO: make this pub(crate)
    fn vec_fract(vec: Vector<N, f64, S>) -> Vector<N, f64, S> {
        vec.map(f64::fract)
    }

    /// TODO: make this pub(crate)
    fn vec_mul_add(
        vec: Vector<N, f64, S>,
        a: Vector<N, f64, S>,
        b: Vector<N, f64, S>,
    ) -> Vector<N, f64, S> {
        vec.zip(a).zip(b).map(|((x, a), b)| f64::mul_add(x, a, b))
    }

    /// TODO: make this pub(crate)
    fn vec_div_euclid(vec: Vector<N, f64, S>, rhs: Vector<N, f64, S>) -> Vector<N, f64, S> {
        vec.zip(rhs).map(|(x, rhs)| f64::div_euclid(x, rhs))
    }

    /// TODO: make this pub(crate)
    fn vec_rem_euclid(vec: Vector<N, f64, S>, rhs: Vector<N, f64, S>) -> Vector<N, f64, S> {
        vec.zip(rhs).map(|(x, rhs)| f64::rem_euclid(x, rhs))
    }

    /// TODO: make this pub(crate)
    fn vec_sqrt(vec: Vector<N, f64, S>) -> Vector<N, f64, S> {
        vec.map(f64::sqrt)
    }

    /// TODO: make this pub(crate)
    fn vec_sin(vec: Vector<N, f64, S>) -> Vector<N, f64, S> {
        vec.map(f64::sin)
    }

    /// TODO: make this pub(crate)
    fn vec_cos(vec: Vector<N, f64, S>) -> Vector<N, f64, S> {
        vec.map(f64::cos)
    }

    /// TODO: make this pub(crate)
    fn vec_tan(vec: Vector<N, f64, S>) -> Vector<N, f64, S> {
        vec.map(f64::tan)
    }

    /// TODO: make this pub(crate)
    fn vec_asin(vec: Vector<N, f64, S>) -> Vector<N, f64, S> {
        vec.map(f64::asin)
    }

    /// TODO: make this pub(crate)
    fn vec_acos(vec: Vector<N, f64, S>) -> Vector<N, f64, S> {
        vec.map(f64::acos)
    }

    /// TODO: make this pub(crate)
    fn vec_atan(vec: Vector<N, f64, S>) -> Vector<N, f64, S> {
        vec.map(f64::atan)
    }

    /// TODO: make this pub(crate)
    fn vec_recip(vec: Vector<N, f64, S>) -> Vector<N, f64, S> {
        vec.map(f64::recip)
    }

    /// TODO: make this pub(crate)
    fn vec_max(vec: Vector<N, f64, S>, other: Vector<N, f64, S>) -> Vector<N, f64, S> {
        debug_assert!(vec.iter().all(|x| !x.is_nan()));
        debug_assert!(other.iter().all(|x| !x.is_nan()));

        vec.zip(other).map(|(x, other)| f64::max(x, other))
    }

    /// TODO: make this pub(crate)
    fn vec_min(vec: Vector<N, f64, S>, other: Vector<N, f64, S>) -> Vector<N, f64, S> {
        debug_assert!(vec.iter().all(|x| !x.is_nan()));
        debug_assert!(other.iter().all(|x| !x.is_nan()));

        vec.zip(other).map(|(x, other)| f64::min(x, other))
    }

    /// TODO: make this pub(crate)
    fn vec_midpoint(vec: Vector<N, f64, S>, other: Vector<N, f64, S>) -> Vector<N, f64, S> {
        vec.zip(other).map(|(x, other)| f64::midpoint(x, other))
    }

    /// TODO: make this pub(crate)
    fn vec_clamp(
        vec: Vector<N, f64, S>,
        min: Vector<N, f64, S>,
        max: Vector<N, f64, S>,
    ) -> Vector<N, f64, S> {
        debug_assert!(min.zip(max).iter().all(|(min, max)| min <= max));
        debug_assert!(min.iter().all(|x| !x.is_nan()));
        debug_assert!(max.iter().all(|x| !x.is_nan()));

        vec.zip(min)
            .zip(max)
            .map(|((x, min), max)| f64::clamp(x, min, max))
    }

    /// TODO: make this pub(crate)
    fn vec_abs(vec: Vector<N, f64, S>) -> Vector<N, f64, S> {
        vec.map(f64::abs)
    }

    /// TODO: make this pub(crate)
    fn vec_signum(vec: Vector<N, f64, S>) -> Vector<N, f64, S> {
        vec.map(f64::signum)
    }

    /// TODO: make this pub(crate)
    fn vec_copysign(vec: Vector<N, f64, S>, sign: Vector<N, f64, S>) -> Vector<N, f64, S> {
        vec.zip(sign).map(|(x, sign)| f64::copysign(x, sign))
    }

    /// TODO: make this pub(crate)
    fn vec_sum(vec: Vector<N, f64, S>) -> f64 {
        vec.iter().sum()
    }

    /// TODO: make this pub(crate)
    fn vec_product(vec: Vector<N, f64, S>) -> f64 {
        vec.iter().product()
    }
}

impl<const N: usize> F64ElementOfVector<N, NonSimd> for f64 {}
