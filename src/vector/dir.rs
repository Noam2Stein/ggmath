// This file was generated by a codegen tool.
// To modify this file, modify the source code of the codegen tool.

use core::mem::transmute_copy;

use crate::{NonSimd, Scalar, Simd, Simdness, Usize, Vec2, Vec3, Vec4, VecLen, Vector};

pub use crate::{scalar_neg_one_boilerplate, scalar_one_boilerplate, scalar_zero_boilerplate};

/// A trait for scalar types that have a `0` value.
pub trait ScalarZero: Scalar {
    /// `0`
    const ZERO: Self;

    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_zero_boilerplate`] to automatically implement this.
    const VEC2_ZERO: Vec2<Self>;
    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_zero_boilerplate`] to automatically implement this.
    const VEC3_ZERO: Vec3<Self>;
    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_zero_boilerplate`] to automatically implement this.
    const VEC4_ZERO: Vec4<Self>;
}

/// A trait for scalar types that have a `1` value.
pub trait ScalarOne: ScalarZero {
    /// `1`
    const ONE: Self;

    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_one_boilerplate`] to automatically implement this.
    const VEC2_ONE: Vec2<Self>;

    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_one_boilerplate`] to automatically implement this.
    const VEC2_X: Vec2<Self>;
    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_one_boilerplate`] to automatically implement this.
    const VEC2_Y: Vec2<Self>;

    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_one_boilerplate`] to automatically implement this.
    const VEC3_ONE: Vec3<Self>;

    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_one_boilerplate`] to automatically implement this.
    const VEC3_X: Vec3<Self>;
    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_one_boilerplate`] to automatically implement this.
    const VEC3_Y: Vec3<Self>;
    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_one_boilerplate`] to automatically implement this.
    const VEC3_Z: Vec3<Self>;

    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_one_boilerplate`] to automatically implement this.
    const VEC4_ONE: Vec4<Self>;

    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_one_boilerplate`] to automatically implement this.
    const VEC4_X: Vec4<Self>;
    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_one_boilerplate`] to automatically implement this.
    const VEC4_Y: Vec4<Self>;
    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_one_boilerplate`] to automatically implement this.
    const VEC4_Z: Vec4<Self>;
    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_one_boilerplate`] to automatically implement this.
    const VEC4_W: Vec4<Self>;
}

/// A trait for scalar types that have a `-1` value.
pub trait ScalarNegOne: ScalarZero {
    /// `-1`
    const NEG_ONE: Self;

    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_neg_one_boilerplate`] to automatically implement this.
    const VEC2_NEG_ONE: Vec2<Self>;

    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_neg_one_boilerplate`] to automatically implement this.
    const VEC2_NEG_X: Vec2<Self>;
    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_neg_one_boilerplate`] to automatically implement this.
    const VEC2_NEG_Y: Vec2<Self>;

    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_neg_one_boilerplate`] to automatically implement this.
    const VEC3_NEG_ONE: Vec3<Self>;

    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_neg_one_boilerplate`] to automatically implement this.
    const VEC3_NEG_X: Vec3<Self>;
    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_neg_one_boilerplate`] to automatically implement this.
    const VEC3_NEG_Y: Vec3<Self>;
    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_neg_one_boilerplate`] to automatically implement this.
    const VEC3_NEG_Z: Vec3<Self>;

    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_neg_one_boilerplate`] to automatically implement this.
    const VEC4_NEG_ONE: Vec4<Self>;

    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_neg_one_boilerplate`] to automatically implement this.
    const VEC4_NEG_X: Vec4<Self>;
    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_neg_one_boilerplate`] to automatically implement this.
    const VEC4_NEG_Y: Vec4<Self>;
    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_neg_one_boilerplate`] to automatically implement this.
    const VEC4_NEG_Z: Vec4<Self>;
    /// This is boilerplate that is required because of stable-Rust limitations.
    /// Use [`scalar_neg_one_boilerplate`] to automatically implement this.
    const VEC4_NEG_W: Vec4<Self>;
}

/// Automatically generates the boilerplate part of [`ScalarZero`] implementations.
/// This requires that `Vector<N, Self, S>` has a `const_from_array` function.
#[macro_export]
macro_rules! scalar_zero_boilerplate {
    {} => {
        const VEC2_ZERO: $crate::Vec2<Self> = $crate::Vec2::<Self>::const_from_array([Self::ZERO; 2]);
        const VEC3_ZERO: $crate::Vec3<Self> = $crate::Vec3::<Self>::const_from_array([Self::ZERO; 3]);
        const VEC4_ZERO: $crate::Vec4<Self> = $crate::Vec4::<Self>::const_from_array([Self::ZERO; 4]);
    }
}

/// Automatically generates the boilerplate part of [`ScalarOne`] implementations.
/// This requires that `Vector<N, Self, S>` has a `const_from_array` function.
#[macro_export]
macro_rules! scalar_one_boilerplate {
    {} => {
        const VEC2_ONE: $crate::Vec2<Self> = $crate::Vec2::<Self>::const_from_array([Self::ONE; 2]);

        const VEC2_X: $crate::Vec2<Self> = $crate::Vec2::<Self>::const_from_array([Self::ONE, Self::ZERO]);
        const VEC2_Y: $crate::Vec2<Self> = $crate::Vec2::<Self>::const_from_array([Self::ZERO, Self::ONE]);

        const VEC3_ONE: $crate::Vec3<Self> = $crate::Vec3::<Self>::const_from_array([Self::ONE; 3]);

        const VEC3_X: $crate::Vec3<Self> = $crate::Vec3::<Self>::const_from_array([Self::ONE, Self::ZERO, Self::ZERO]);
        const VEC3_Y: $crate::Vec3<Self> = $crate::Vec3::<Self>::const_from_array([Self::ZERO, Self::ONE, Self::ZERO]);
        const VEC3_Z: $crate::Vec3<Self> = $crate::Vec3::<Self>::const_from_array([Self::ZERO, Self::ZERO, Self::ONE]);

        const VEC4_ONE: $crate::Vec4<Self> = $crate::Vec4::<Self>::const_from_array([Self::ONE; 4]);

        const VEC4_X: $crate::Vec4<Self> = $crate::Vec4::<Self>::const_from_array([Self::ONE, Self::ZERO, Self::ZERO, Self::ZERO]);
        const VEC4_Y: $crate::Vec4<Self> = $crate::Vec4::<Self>::const_from_array([Self::ZERO, Self::ONE, Self::ZERO, Self::ZERO]);
        const VEC4_Z: $crate::Vec4<Self> = $crate::Vec4::<Self>::const_from_array([Self::ZERO, Self::ZERO, Self::ONE, Self::ZERO]);
        const VEC4_W: $crate::Vec4<Self> = $crate::Vec4::<Self>::const_from_array([Self::ZERO, Self::ZERO, Self::ZERO, Self::ONE]);
    }
}

/// Automatically generates the boilerplate part of [`ScalarNegOne`] implementations.
/// This requires that `Vector<N, Self, S>` has a `const_from_array` function.
#[macro_export]
macro_rules! scalar_neg_one_boilerplate {
    {} => {
        const VEC2_NEG_ONE: $crate::Vec2<Self> = $crate::Vec2::<Self>::const_from_array([Self::NEG_ONE; 2]);

        const VEC2_NEG_X: $crate::Vec2<Self> = $crate::Vec2::<Self>::const_from_array([Self::NEG_ONE, Self::ZERO]);
        const VEC2_NEG_Y: $crate::Vec2<Self> = $crate::Vec2::<Self>::const_from_array([Self::ZERO, Self::NEG_ONE]);

        const VEC3_NEG_ONE: $crate::Vec3<Self> = $crate::Vec3::<Self>::const_from_array([Self::NEG_ONE; 3]);

        const VEC3_NEG_X: $crate::Vec3<Self> = $crate::Vec3::<Self>::const_from_array([Self::NEG_ONE, Self::ZERO, Self::ZERO]);
        const VEC3_NEG_Y: $crate::Vec3<Self> = $crate::Vec3::<Self>::const_from_array([Self::ZERO, Self::NEG_ONE, Self::ZERO]);
        const VEC3_NEG_Z: $crate::Vec3<Self> = $crate::Vec3::<Self>::const_from_array([Self::ZERO, Self::ZERO, Self::NEG_ONE]);

        const VEC4_NEG_ONE: $crate::Vec4<Self> = $crate::Vec4::<Self>::const_from_array([Self::NEG_ONE; 4]);

        const VEC4_NEG_X: $crate::Vec4<Self> = $crate::Vec4::<Self>::const_from_array([Self::NEG_ONE, Self::ZERO, Self::ZERO, Self::ZERO]);
        const VEC4_NEG_Y: $crate::Vec4<Self> = $crate::Vec4::<Self>::const_from_array([Self::ZERO, Self::NEG_ONE, Self::ZERO, Self::ZERO]);
        const VEC4_NEG_Z: $crate::Vec4<Self> = $crate::Vec4::<Self>::const_from_array([Self::ZERO, Self::ZERO, Self::NEG_ONE, Self::ZERO]);
        const VEC4_NEG_W: $crate::Vec4<Self> = $crate::Vec4::<Self>::const_from_array([Self::ZERO, Self::ZERO, Self::ZERO, Self::NEG_ONE]);
    }
}

impl<const N: usize, T: ScalarZero, S: Simdness> Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    /// All `0`.
    pub const ZERO: Self = {
        unsafe {
            if S::IS_SIMD {
                match N {
                    2 => transmute_copy::<Vector<2, T, Simd>, Vector<N, T, S>>(&T::VEC2_ZERO),
                    3 => transmute_copy::<Vector<3, T, Simd>, Vector<N, T, S>>(&T::VEC3_ZERO),
                    4 => transmute_copy::<Vector<4, T, Simd>, Vector<N, T, S>>(&T::VEC4_ZERO),
                    _ => panic!("unusual vector type"),
                }
            } else {
                transmute_copy::<Vector<N, T, NonSimd>, Vector<N, T, S>>(&Vector([T::ZERO; N]))
            }
        }
    };
}

impl<const N: usize, T: ScalarOne, S: Simdness> Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    /// All `1`.
    pub const ONE: Self = {
        unsafe {
            if S::IS_SIMD {
                match N {
                    2 => transmute_copy::<Vector<2, T, Simd>, Vector<N, T, S>>(&T::VEC2_ONE),
                    3 => transmute_copy::<Vector<3, T, Simd>, Vector<N, T, S>>(&T::VEC3_ONE),
                    4 => transmute_copy::<Vector<4, T, Simd>, Vector<N, T, S>>(&T::VEC4_ONE),
                    _ => panic!("unusual vector type"),
                }
            } else {
                transmute_copy::<Vector<N, T, NonSimd>, Vector<N, T, S>>(&Vector([T::ONE; N]))
            }
        }
    };
}

impl<const N: usize, T: ScalarNegOne, S: Simdness> Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    /// All `-1`.
    pub const NEG_ONE: Self = {
        unsafe {
            if S::IS_SIMD {
                match N {
                    2 => transmute_copy::<Vector<2, T, Simd>, Vector<N, T, S>>(&T::VEC2_NEG_ONE),
                    3 => transmute_copy::<Vector<3, T, Simd>, Vector<N, T, S>>(&T::VEC3_NEG_ONE),
                    4 => transmute_copy::<Vector<4, T, Simd>, Vector<N, T, S>>(&T::VEC4_NEG_ONE),
                    _ => panic!("unusual vector type"),
                }
            } else {
                transmute_copy::<Vector<N, T, NonSimd>, Vector<N, T, S>>(&Vector([T::NEG_ONE; N]))
            }
        }
    };
}

impl<T: ScalarOne, S: Simdness> Vector<2, T, S> {
    /// A vector that points to the positive `x` direction with magnitude `1`.
    pub const X: Self = {
        unsafe {
            if S::IS_SIMD {
                transmute_copy::<Vector<2, T, Simd>, Vector<2, T, S>>(&T::VEC2_X)
            } else {
                transmute_copy::<Vector<2, T, NonSimd>, Vector<2, T, S>>(&Vector([T::ONE, T::ZERO]))
            }
        }
    };

    /// A vector that points to the positive `y` direction with magnitude `1`.
    pub const Y: Self = {
        unsafe {
            if S::IS_SIMD {
                transmute_copy::<Vector<2, T, Simd>, Vector<2, T, S>>(&T::VEC2_Y)
            } else {
                transmute_copy::<Vector<2, T, NonSimd>, Vector<2, T, S>>(&Vector([T::ZERO, T::ONE]))
            }
        }
    };
}

impl<T: ScalarOne, S: Simdness> Vector<3, T, S> {
    /// A vector that points to the positive `x` direction with magnitude `1`.
    pub const X: Self = {
        unsafe {
            if S::IS_SIMD {
                transmute_copy::<Vector<3, T, Simd>, Vector<3, T, S>>(&T::VEC3_X)
            } else {
                transmute_copy::<Vector<3, T, NonSimd>, Vector<3, T, S>>(&Vector([
                    T::ONE,
                    T::ZERO,
                    T::ZERO,
                ]))
            }
        }
    };

    /// A vector that points to the positive `y` direction with magnitude `1`.
    pub const Y: Self = {
        unsafe {
            if S::IS_SIMD {
                transmute_copy::<Vector<3, T, Simd>, Vector<3, T, S>>(&T::VEC3_Y)
            } else {
                transmute_copy::<Vector<3, T, NonSimd>, Vector<3, T, S>>(&Vector([
                    T::ZERO,
                    T::ONE,
                    T::ZERO,
                ]))
            }
        }
    };

    /// A vector that points to the positive `z` direction with magnitude `1`.
    pub const Z: Self = {
        unsafe {
            if S::IS_SIMD {
                transmute_copy::<Vector<3, T, Simd>, Vector<3, T, S>>(&T::VEC3_Z)
            } else {
                transmute_copy::<Vector<3, T, NonSimd>, Vector<3, T, S>>(&Vector([
                    T::ZERO,
                    T::ZERO,
                    T::ONE,
                ]))
            }
        }
    };
}

impl<T: ScalarOne, S: Simdness> Vector<4, T, S> {
    /// A vector that points to the positive `x` direction with magnitude `1`.
    pub const X: Self = {
        unsafe {
            if S::IS_SIMD {
                transmute_copy::<Vector<4, T, Simd>, Vector<4, T, S>>(&T::VEC4_X)
            } else {
                transmute_copy::<Vector<4, T, NonSimd>, Vector<4, T, S>>(&Vector([
                    T::ONE,
                    T::ZERO,
                    T::ZERO,
                    T::ZERO,
                ]))
            }
        }
    };

    /// A vector that points to the positive `y` direction with magnitude `1`.
    pub const Y: Self = {
        unsafe {
            if S::IS_SIMD {
                transmute_copy::<Vector<4, T, Simd>, Vector<4, T, S>>(&T::VEC4_Y)
            } else {
                transmute_copy::<Vector<4, T, NonSimd>, Vector<4, T, S>>(&Vector([
                    T::ZERO,
                    T::ONE,
                    T::ZERO,
                    T::ZERO,
                ]))
            }
        }
    };

    /// A vector that points to the positive `z` direction with magnitude `1`.
    pub const Z: Self = {
        unsafe {
            if S::IS_SIMD {
                transmute_copy::<Vector<4, T, Simd>, Vector<4, T, S>>(&T::VEC4_Z)
            } else {
                transmute_copy::<Vector<4, T, NonSimd>, Vector<4, T, S>>(&Vector([
                    T::ZERO,
                    T::ZERO,
                    T::ONE,
                    T::ZERO,
                ]))
            }
        }
    };

    /// A vector that points to the positive `w` direction with magnitude `1`.
    pub const W: Self = {
        unsafe {
            if S::IS_SIMD {
                transmute_copy::<Vector<4, T, Simd>, Vector<4, T, S>>(&T::VEC4_W)
            } else {
                transmute_copy::<Vector<4, T, NonSimd>, Vector<4, T, S>>(&Vector([
                    T::ZERO,
                    T::ZERO,
                    T::ZERO,
                    T::ONE,
                ]))
            }
        }
    };
}

impl<T: ScalarNegOne, S: Simdness> Vector<2, T, S> {
    /// A vector that points to the negative `x` direction with magnitude `1`.
    pub const NEG_X: Self = {
        unsafe {
            if S::IS_SIMD {
                transmute_copy::<Vector<2, T, Simd>, Vector<2, T, S>>(&T::VEC2_NEG_X)
            } else {
                transmute_copy::<Vector<2, T, NonSimd>, Vector<2, T, S>>(&Vector([
                    T::NEG_ONE,
                    T::ZERO,
                ]))
            }
        }
    };

    /// A vector that points to the negative `y` direction with magnitude `1`.
    pub const NEG_Y: Self = {
        unsafe {
            if S::IS_SIMD {
                transmute_copy::<Vector<2, T, Simd>, Vector<2, T, S>>(&T::VEC2_NEG_Y)
            } else {
                transmute_copy::<Vector<2, T, NonSimd>, Vector<2, T, S>>(&Vector([
                    T::ZERO,
                    T::NEG_ONE,
                ]))
            }
        }
    };
}

impl<T: ScalarNegOne, S: Simdness> Vector<3, T, S> {
    /// A vector that points to the negative `x` direction with magnitude `1`.
    pub const NEG_X: Self = {
        unsafe {
            if S::IS_SIMD {
                transmute_copy::<Vector<3, T, Simd>, Vector<3, T, S>>(&T::VEC3_NEG_X)
            } else {
                transmute_copy::<Vector<3, T, NonSimd>, Vector<3, T, S>>(&Vector([
                    T::NEG_ONE,
                    T::ZERO,
                    T::ZERO,
                ]))
            }
        }
    };

    /// A vector that points to the negative `y` direction with magnitude `1`.
    pub const NEG_Y: Self = {
        unsafe {
            if S::IS_SIMD {
                transmute_copy::<Vector<3, T, Simd>, Vector<3, T, S>>(&T::VEC3_NEG_Y)
            } else {
                transmute_copy::<Vector<3, T, NonSimd>, Vector<3, T, S>>(&Vector([
                    T::ZERO,
                    T::NEG_ONE,
                    T::ZERO,
                ]))
            }
        }
    };

    /// A vector that points to the negative `z` direction with magnitude `1`.
    pub const NEG_Z: Self = {
        unsafe {
            if S::IS_SIMD {
                transmute_copy::<Vector<3, T, Simd>, Vector<3, T, S>>(&T::VEC3_NEG_Z)
            } else {
                transmute_copy::<Vector<3, T, NonSimd>, Vector<3, T, S>>(&Vector([
                    T::ZERO,
                    T::ZERO,
                    T::NEG_ONE,
                ]))
            }
        }
    };
}

impl<T: ScalarNegOne, S: Simdness> Vector<4, T, S> {
    /// A vector that points to the negative `x` direction with magnitude `1`.
    pub const NEG_X: Self = {
        unsafe {
            if S::IS_SIMD {
                transmute_copy::<Vector<4, T, Simd>, Vector<4, T, S>>(&T::VEC4_NEG_X)
            } else {
                transmute_copy::<Vector<4, T, NonSimd>, Vector<4, T, S>>(&Vector([
                    T::NEG_ONE,
                    T::ZERO,
                    T::ZERO,
                    T::ZERO,
                ]))
            }
        }
    };

    /// A vector that points to the negative `y` direction with magnitude `1`.
    pub const NEG_Y: Self = {
        unsafe {
            if S::IS_SIMD {
                transmute_copy::<Vector<4, T, Simd>, Vector<4, T, S>>(&T::VEC4_NEG_Y)
            } else {
                transmute_copy::<Vector<4, T, NonSimd>, Vector<4, T, S>>(&Vector([
                    T::ZERO,
                    T::NEG_ONE,
                    T::ZERO,
                    T::ZERO,
                ]))
            }
        }
    };

    /// A vector that points to the negative `z` direction with magnitude `1`.
    pub const NEG_Z: Self = {
        unsafe {
            if S::IS_SIMD {
                transmute_copy::<Vector<4, T, Simd>, Vector<4, T, S>>(&T::VEC4_NEG_Z)
            } else {
                transmute_copy::<Vector<4, T, NonSimd>, Vector<4, T, S>>(&Vector([
                    T::ZERO,
                    T::ZERO,
                    T::NEG_ONE,
                    T::ZERO,
                ]))
            }
        }
    };

    /// A vector that points to the negative `w` direction with magnitude `1`.
    pub const NEG_W: Self = {
        unsafe {
            if S::IS_SIMD {
                transmute_copy::<Vector<4, T, Simd>, Vector<4, T, S>>(&T::VEC4_NEG_W)
            } else {
                transmute_copy::<Vector<4, T, NonSimd>, Vector<4, T, S>>(&Vector([
                    T::ZERO,
                    T::ZERO,
                    T::ZERO,
                    T::NEG_ONE,
                ]))
            }
        }
    };
}

/// `RIGHT` and `LEFT constants where right is positive and left is negative.
#[cfg(feature = "right")]
pub mod right {
    use crate::{Construct, ScalarNegOne, ScalarOne, Simdness, Vector};

    /// `RIGHT` constant where right is positive and left is negative.
    pub trait PositiveRight: Construct {
        /// A value that points right with a magnitude of one,
        /// where right is positive and left is negative.
        const RIGHT: Self;
    }

    /// `LEFT` constant where right is positive and left is negative.
    pub trait NegativeLeft: Construct {
        /// A value that points left with a magnitude of one,
        /// where right is positive and left is negative.
        const LEFT: Self;
    }

    impl<T: ScalarOne> PositiveRight for T {
        const RIGHT: Self = Self::ONE;
    }

    impl<T: ScalarNegOne> NegativeLeft for T {
        const LEFT: Self = Self::NEG_ONE;
    }

    impl<T: ScalarOne, S: Simdness> PositiveRight for Vector<2, T, S> {
        const RIGHT: Self = Self::X;
    }

    impl<T: ScalarNegOne, S: Simdness> NegativeLeft for Vector<2, T, S> {
        const LEFT: Self = Self::NEG_X;
    }

    impl<T: ScalarOne, S: Simdness> PositiveRight for Vector<3, T, S> {
        const RIGHT: Self = Self::X;
    }

    impl<T: ScalarNegOne, S: Simdness> NegativeLeft for Vector<3, T, S> {
        const LEFT: Self = Self::NEG_X;
    }

    impl<T: ScalarOne, S: Simdness> PositiveRight for Vector<4, T, S> {
        const RIGHT: Self = Self::X;
    }

    impl<T: ScalarNegOne, S: Simdness> NegativeLeft for Vector<4, T, S> {
        const LEFT: Self = Self::NEG_X;
    }
}

/// `LEFT` and `RIGHT constants where left is positive and right is negative.
#[cfg(feature = "left")]
pub mod left {
    use crate::{Construct, ScalarNegOne, ScalarOne, Simdness, Vector};

    /// `LEFT` constant where left is positive and right is negative.
    pub trait PositiveLeft: Construct {
        /// A value that points left with a magnitude of one,
        /// where left is positive and right is negative.
        const LEFT: Self;
    }

    /// `RIGHT` constant where left is positive and right is negative.
    pub trait NegativeRight: Construct {
        /// A value that points right with a magnitude of one,
        /// where left is positive and right is negative.
        const RIGHT: Self;
    }

    impl<T: ScalarOne> PositiveLeft for T {
        const LEFT: Self = Self::ONE;
    }

    impl<T: ScalarNegOne> NegativeRight for T {
        const RIGHT: Self = Self::NEG_ONE;
    }

    impl<T: ScalarOne, S: Simdness> PositiveLeft for Vector<2, T, S> {
        const LEFT: Self = Self::X;
    }

    impl<T: ScalarNegOne, S: Simdness> NegativeRight for Vector<2, T, S> {
        const RIGHT: Self = Self::NEG_X;
    }

    impl<T: ScalarOne, S: Simdness> PositiveLeft for Vector<3, T, S> {
        const LEFT: Self = Self::X;
    }

    impl<T: ScalarNegOne, S: Simdness> NegativeRight for Vector<3, T, S> {
        const RIGHT: Self = Self::NEG_X;
    }

    impl<T: ScalarOne, S: Simdness> PositiveLeft for Vector<4, T, S> {
        const LEFT: Self = Self::X;
    }

    impl<T: ScalarNegOne, S: Simdness> NegativeRight for Vector<4, T, S> {
        const RIGHT: Self = Self::NEG_X;
    }
}

/// `UP` and `DOWN constants where up is positive and down is negative.
#[cfg(feature = "up")]
pub mod up {
    use crate::{Construct, ScalarNegOne, ScalarOne, Simdness, Vector};

    /// `UP` constant where up is positive and down is negative.
    pub trait PositiveUp: Construct {
        /// A value that points up with a magnitude of one,
        /// where up is positive and down is negative.
        const UP: Self;
    }

    /// `DOWN` constant where up is positive and down is negative.
    pub trait NegativeDown: Construct {
        /// A value that points down with a magnitude of one,
        /// where up is positive and down is negative.
        const DOWN: Self;
    }

    impl<T: ScalarOne> PositiveUp for T {
        const UP: Self = Self::ONE;
    }

    impl<T: ScalarNegOne> NegativeDown for T {
        const DOWN: Self = Self::NEG_ONE;
    }

    impl<T: ScalarOne, S: Simdness> PositiveUp for Vector<2, T, S> {
        const UP: Self = Self::Y;
    }

    impl<T: ScalarNegOne, S: Simdness> NegativeDown for Vector<2, T, S> {
        const DOWN: Self = Self::NEG_Y;
    }

    impl<T: ScalarOne, S: Simdness> PositiveUp for Vector<3, T, S> {
        const UP: Self = Self::Y;
    }

    impl<T: ScalarNegOne, S: Simdness> NegativeDown for Vector<3, T, S> {
        const DOWN: Self = Self::NEG_Y;
    }

    impl<T: ScalarOne, S: Simdness> PositiveUp for Vector<4, T, S> {
        const UP: Self = Self::Y;
    }

    impl<T: ScalarNegOne, S: Simdness> NegativeDown for Vector<4, T, S> {
        const DOWN: Self = Self::NEG_Y;
    }
}

/// `DOWN` and `UP constants where down is positive and up is negative.
#[cfg(feature = "down")]
pub mod down {
    use crate::{Construct, ScalarNegOne, ScalarOne, Simdness, Vector};

    /// `DOWN` constant where down is positive and up is negative.
    pub trait PositiveDown: Construct {
        /// A value that points down with a magnitude of one,
        /// where down is positive and up is negative.
        const DOWN: Self;
    }

    /// `UP` constant where down is positive and up is negative.
    pub trait NegativeUp: Construct {
        /// A value that points up with a magnitude of one,
        /// where down is positive and up is negative.
        const UP: Self;
    }

    impl<T: ScalarOne> PositiveDown for T {
        const DOWN: Self = Self::ONE;
    }

    impl<T: ScalarNegOne> NegativeUp for T {
        const UP: Self = Self::NEG_ONE;
    }

    impl<T: ScalarOne, S: Simdness> PositiveDown for Vector<2, T, S> {
        const DOWN: Self = Self::Y;
    }

    impl<T: ScalarNegOne, S: Simdness> NegativeUp for Vector<2, T, S> {
        const UP: Self = Self::NEG_Y;
    }

    impl<T: ScalarOne, S: Simdness> PositiveDown for Vector<3, T, S> {
        const DOWN: Self = Self::Y;
    }

    impl<T: ScalarNegOne, S: Simdness> NegativeUp for Vector<3, T, S> {
        const UP: Self = Self::NEG_Y;
    }

    impl<T: ScalarOne, S: Simdness> PositiveDown for Vector<4, T, S> {
        const DOWN: Self = Self::Y;
    }

    impl<T: ScalarNegOne, S: Simdness> NegativeUp for Vector<4, T, S> {
        const UP: Self = Self::NEG_Y;
    }
}

/// `FORWARDS` and `BACKWARDS constants where forwards is positive and backwards is negative.
#[cfg(feature = "forwards")]
pub mod forwards {
    use crate::{Construct, ScalarNegOne, ScalarOne, Simdness, Vector};

    /// `FORWARDS` constant where forwards is positive and backwards is negative.
    pub trait PositiveForwards: Construct {
        /// A value that points forwards with a magnitude of one,
        /// where forwards is positive and backwards is negative.
        const FORWARDS: Self;
    }

    /// `BACKWARDS` constant where forwards is positive and backwards is negative.
    pub trait NegativeBackwards: Construct {
        /// A value that points backwards with a magnitude of one,
        /// where forwards is positive and backwards is negative.
        const BACKWARDS: Self;
    }

    impl<T: ScalarOne> PositiveForwards for T {
        const FORWARDS: Self = Self::ONE;
    }

    impl<T: ScalarNegOne> NegativeBackwards for T {
        const BACKWARDS: Self = Self::NEG_ONE;
    }

    impl<T: ScalarOne, S: Simdness> PositiveForwards for Vector<3, T, S> {
        const FORWARDS: Self = Self::Z;
    }

    impl<T: ScalarNegOne, S: Simdness> NegativeBackwards for Vector<3, T, S> {
        const BACKWARDS: Self = Self::NEG_Z;
    }

    impl<T: ScalarOne, S: Simdness> PositiveForwards for Vector<4, T, S> {
        const FORWARDS: Self = Self::Z;
    }

    impl<T: ScalarNegOne, S: Simdness> NegativeBackwards for Vector<4, T, S> {
        const BACKWARDS: Self = Self::NEG_Z;
    }
}

/// `BACKWARDS` and `FORWARDS constants where backwards is positive and forwards is negative.
#[cfg(feature = "backwards")]
pub mod backwards {
    use crate::{Construct, ScalarNegOne, ScalarOne, Simdness, Vector};

    /// `BACKWARDS` constant where backwards is positive and forwards is negative.
    pub trait PositiveBackwards: Construct {
        /// A value that points backwards with a magnitude of one,
        /// where backwards is positive and forwards is negative.
        const BACKWARDS: Self;
    }

    /// `FORWARDS` constant where backwards is positive and forwards is negative.
    pub trait NegativeForwards: Construct {
        /// A value that points forwards with a magnitude of one,
        /// where backwards is positive and forwards is negative.
        const FORWARDS: Self;
    }

    impl<T: ScalarOne> PositiveBackwards for T {
        const BACKWARDS: Self = Self::ONE;
    }

    impl<T: ScalarNegOne> NegativeForwards for T {
        const FORWARDS: Self = Self::NEG_ONE;
    }

    impl<T: ScalarOne, S: Simdness> PositiveBackwards for Vector<3, T, S> {
        const BACKWARDS: Self = Self::Z;
    }

    impl<T: ScalarNegOne, S: Simdness> NegativeForwards for Vector<3, T, S> {
        const FORWARDS: Self = Self::NEG_Z;
    }

    impl<T: ScalarOne, S: Simdness> PositiveBackwards for Vector<4, T, S> {
        const BACKWARDS: Self = Self::Z;
    }

    impl<T: ScalarNegOne, S: Simdness> NegativeForwards for Vector<4, T, S> {
        const FORWARDS: Self = Self::NEG_Z;
    }
}
