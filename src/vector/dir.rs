// This file was generated by a codegen tool.
// To modify this file, modify the source code of the codegen tool.

use crate::{Construct, ElementOfVector, Simdness, Vector};

/// Trait for element types that have a `ZERO` value.
pub trait ElementZero: Construct {
    /// `0` constant.
    const ZERO: Self;
}

/// Trait for element types that have a `ONE` value.
pub trait ElementOne: Construct {
    /// `1` constant.
    const ONE: Self;
}

/// Trait for element types that have a `NEG_ONE` value.
pub trait ElementNegOne: Construct {
    /// `-1` constant.
    const NEG_ONE: Self;
}

impl<const N: usize, T: ElementZero + ElementOfVector<N, S>, S: Simdness> Vector<N, T, S> {
    /// `0` vector.
    pub const ZERO: Self = Self::const_from_array([T::ZERO; N]);
}

impl<const N: usize, T: ElementOne + ElementOfVector<N, S>, S: Simdness> Vector<N, T, S> {
    /// Vector with all elements set to `1`.
    pub const ONE: Self = Self::const_from_array([T::ONE; N]);
}

impl<const N: usize, T: ElementNegOne + ElementOfVector<N, S>, S: Simdness> Vector<N, T, S> {
    /// Vector with all elements set to `-1`.
    pub const NEG_ONE: Self = Self::const_from_array([T::NEG_ONE; N]);
}

impl<T: ElementZero + ElementOne + ElementOfVector<2, S>, S: Simdness> Vector<2, T, S> {
    /// Vector pointing to the positive direction of the `x` (1st) axis with magnitude `1`.
    pub const X: Self = Self::const_from_array([T::ONE, T::ZERO]);

    /// Vector pointing to the positive direction of the `y` (2nd) axis with magnitude `1`.
    pub const Y: Self = Self::const_from_array([T::ZERO, T::ONE]);
}

impl<T: ElementZero + ElementOne + ElementOfVector<3, S>, S: Simdness> Vector<3, T, S> {
    /// Vector pointing to the positive direction of the `x` (1st) axis with magnitude `1`.
    pub const X: Self = Self::const_from_array([T::ONE, T::ZERO, T::ZERO]);

    /// Vector pointing to the positive direction of the `y` (2nd) axis with magnitude `1`.
    pub const Y: Self = Self::const_from_array([T::ZERO, T::ONE, T::ZERO]);

    /// Vector pointing to the positive direction of the `z` (3rd) axis with magnitude `1`.
    pub const Z: Self = Self::const_from_array([T::ZERO, T::ZERO, T::ONE]);
}

impl<T: ElementZero + ElementOne + ElementOfVector<4, S>, S: Simdness> Vector<4, T, S> {
    /// Vector pointing to the positive direction of the `x` (1st) axis with magnitude `1`.
    pub const X: Self = Self::const_from_array([T::ONE, T::ZERO, T::ZERO, T::ZERO]);

    /// Vector pointing to the positive direction of the `y` (2nd) axis with magnitude `1`.
    pub const Y: Self = Self::const_from_array([T::ZERO, T::ONE, T::ZERO, T::ZERO]);

    /// Vector pointing to the positive direction of the `z` (3rd) axis with magnitude `1`.
    pub const Z: Self = Self::const_from_array([T::ZERO, T::ZERO, T::ONE, T::ZERO]);

    /// Vector pointing to the positive direction of the `w` (4th) axis with magnitude `1`.
    pub const W: Self = Self::const_from_array([T::ZERO, T::ZERO, T::ZERO, T::ONE]);
}

impl<T: ElementZero + ElementNegOne + ElementOfVector<2, S>, S: Simdness> Vector<2, T, S> {
    /// Vector pointing to the negative direction of the `x` (1st) axis with magnitude `1`.
    pub const NEG_X: Self = Self::const_from_array([T::NEG_ONE, T::ZERO]);

    /// Vector pointing to the negative direction of the `y` (2nd) axis with magnitude `1`.
    pub const NEG_Y: Self = Self::const_from_array([T::ZERO, T::NEG_ONE]);
}

impl<T: ElementZero + ElementNegOne + ElementOfVector<3, S>, S: Simdness> Vector<3, T, S> {
    /// Vector pointing to the negative direction of the `x` (1st) axis with magnitude `1`.
    pub const NEG_X: Self = Self::const_from_array([T::NEG_ONE, T::ZERO, T::ZERO]);

    /// Vector pointing to the negative direction of the `y` (2nd) axis with magnitude `1`.
    pub const NEG_Y: Self = Self::const_from_array([T::ZERO, T::NEG_ONE, T::ZERO]);

    /// Vector pointing to the negative direction of the `z` (3rd) axis with magnitude `1`.
    pub const NEG_Z: Self = Self::const_from_array([T::ZERO, T::ZERO, T::NEG_ONE]);
}

impl<T: ElementZero + ElementNegOne + ElementOfVector<4, S>, S: Simdness> Vector<4, T, S> {
    /// Vector pointing to the negative direction of the `x` (1st) axis with magnitude `1`.
    pub const NEG_X: Self = Self::const_from_array([T::NEG_ONE, T::ZERO, T::ZERO, T::ZERO]);

    /// Vector pointing to the negative direction of the `y` (2nd) axis with magnitude `1`.
    pub const NEG_Y: Self = Self::const_from_array([T::ZERO, T::NEG_ONE, T::ZERO, T::ZERO]);

    /// Vector pointing to the negative direction of the `z` (3rd) axis with magnitude `1`.
    pub const NEG_Z: Self = Self::const_from_array([T::ZERO, T::ZERO, T::NEG_ONE, T::ZERO]);

    /// Vector pointing to the negative direction of the `w` (4th) axis with magnitude `1`.
    pub const NEG_W: Self = Self::const_from_array([T::ZERO, T::ZERO, T::ZERO, T::NEG_ONE]);
}

/// Module with `RIGHT` and `LEFT` constants where right is positive.
#[cfg(feature = "right")]
pub mod right {
    use crate::{
        Construct, ElementNegOne, ElementOfVector, ElementOne, ElementZero, Simdness, Vector,
    };

    /// Trait with a `RIGHT` constant where right is positive and left is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ElementOne`].
    pub trait PositiveRight: Construct {
        /// Points right with magnitude `1` (right is positive and left is negative).
        const RIGHT: Self;
    }

    /// Trait with a `LEFT` constant where right is positive and left is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ElementNegOne`].
    pub trait NegativeLeft: Construct {
        /// Points left with magnitude `1` (right is positive and left is negative).
        const LEFT: Self;
    }

    impl<T: ElementOne> PositiveRight for T {
        const RIGHT: Self = Self::ONE;
    }

    impl<T: ElementNegOne> NegativeLeft for T {
        const LEFT: Self = Self::NEG_ONE;
    }

    impl<T: ElementZero + ElementOne + ElementOfVector<2, S>, S: Simdness> PositiveRight
        for Vector<2, T, S>
    {
        const RIGHT: Self = Self::X;
    }

    impl<T: ElementZero + ElementOne + ElementOfVector<3, S>, S: Simdness> PositiveRight
        for Vector<3, T, S>
    {
        const RIGHT: Self = Self::X;
    }

    impl<T: ElementZero + ElementOne + ElementOfVector<4, S>, S: Simdness> PositiveRight
        for Vector<4, T, S>
    {
        const RIGHT: Self = Self::X;
    }

    impl<T: ElementZero + ElementNegOne + ElementOfVector<2, S>, S: Simdness> NegativeLeft
        for Vector<2, T, S>
    {
        const LEFT: Self = Self::NEG_X;
    }

    impl<T: ElementZero + ElementNegOne + ElementOfVector<3, S>, S: Simdness> NegativeLeft
        for Vector<3, T, S>
    {
        const LEFT: Self = Self::NEG_X;
    }

    impl<T: ElementZero + ElementNegOne + ElementOfVector<4, S>, S: Simdness> NegativeLeft
        for Vector<4, T, S>
    {
        const LEFT: Self = Self::NEG_X;
    }
}

/// Module with `LEFT` and `RIGHT` constants where left is positive.
#[cfg(feature = "left")]
pub mod left {
    use crate::{
        Construct, ElementNegOne, ElementOfVector, ElementOne, ElementZero, Simdness, Vector,
    };

    /// Trait with a `LEFT` constant where left is positive and right is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ElementOne`].
    pub trait PositiveLeft: Construct {
        /// Points left with magnitude `1` (left is positive and right is negative).
        const LEFT: Self;
    }

    /// Trait with a `RIGHT` constant where left is positive and right is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ElementNegOne`].
    pub trait NegativeRight: Construct {
        /// Points right with magnitude `1` (left is positive and right is negative).
        const RIGHT: Self;
    }

    impl<T: ElementOne> PositiveLeft for T {
        const LEFT: Self = Self::ONE;
    }

    impl<T: ElementNegOne> NegativeRight for T {
        const RIGHT: Self = Self::NEG_ONE;
    }

    impl<T: ElementZero + ElementOne + ElementOfVector<2, S>, S: Simdness> PositiveLeft
        for Vector<2, T, S>
    {
        const LEFT: Self = Self::X;
    }

    impl<T: ElementZero + ElementOne + ElementOfVector<3, S>, S: Simdness> PositiveLeft
        for Vector<3, T, S>
    {
        const LEFT: Self = Self::X;
    }

    impl<T: ElementZero + ElementOne + ElementOfVector<4, S>, S: Simdness> PositiveLeft
        for Vector<4, T, S>
    {
        const LEFT: Self = Self::X;
    }

    impl<T: ElementZero + ElementNegOne + ElementOfVector<2, S>, S: Simdness> NegativeRight
        for Vector<2, T, S>
    {
        const RIGHT: Self = Self::NEG_X;
    }

    impl<T: ElementZero + ElementNegOne + ElementOfVector<3, S>, S: Simdness> NegativeRight
        for Vector<3, T, S>
    {
        const RIGHT: Self = Self::NEG_X;
    }

    impl<T: ElementZero + ElementNegOne + ElementOfVector<4, S>, S: Simdness> NegativeRight
        for Vector<4, T, S>
    {
        const RIGHT: Self = Self::NEG_X;
    }
}

/// Module with `UP` and `DOWN` constants where up is positive.
#[cfg(feature = "up")]
pub mod up {
    use crate::{
        Construct, ElementNegOne, ElementOfVector, ElementOne, ElementZero, Simdness, Vector,
    };

    /// Trait with a `UP` constant where up is positive and down is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ElementOne`].
    pub trait PositiveUp: Construct {
        /// Points up with magnitude `1` (up is positive and down is negative).
        const UP: Self;
    }

    /// Trait with a `DOWN` constant where up is positive and down is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ElementNegOne`].
    pub trait NegativeDown: Construct {
        /// Points down with magnitude `1` (up is positive and down is negative).
        const DOWN: Self;
    }

    impl<T: ElementOne> PositiveUp for T {
        const UP: Self = Self::ONE;
    }

    impl<T: ElementNegOne> NegativeDown for T {
        const DOWN: Self = Self::NEG_ONE;
    }

    impl<T: ElementZero + ElementOne + ElementOfVector<2, S>, S: Simdness> PositiveUp
        for Vector<2, T, S>
    {
        const UP: Self = Self::Y;
    }

    impl<T: ElementZero + ElementOne + ElementOfVector<3, S>, S: Simdness> PositiveUp
        for Vector<3, T, S>
    {
        const UP: Self = Self::Y;
    }

    impl<T: ElementZero + ElementOne + ElementOfVector<4, S>, S: Simdness> PositiveUp
        for Vector<4, T, S>
    {
        const UP: Self = Self::Y;
    }

    impl<T: ElementZero + ElementNegOne + ElementOfVector<2, S>, S: Simdness> NegativeDown
        for Vector<2, T, S>
    {
        const DOWN: Self = Self::NEG_Y;
    }

    impl<T: ElementZero + ElementNegOne + ElementOfVector<3, S>, S: Simdness> NegativeDown
        for Vector<3, T, S>
    {
        const DOWN: Self = Self::NEG_Y;
    }

    impl<T: ElementZero + ElementNegOne + ElementOfVector<4, S>, S: Simdness> NegativeDown
        for Vector<4, T, S>
    {
        const DOWN: Self = Self::NEG_Y;
    }
}

/// Module with `DOWN` and `UP` constants where down is positive.
#[cfg(feature = "down")]
pub mod down {
    use crate::{
        Construct, ElementNegOne, ElementOfVector, ElementOne, ElementZero, Simdness, Vector,
    };

    /// Trait with a `DOWN` constant where down is positive and up is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ElementOne`].
    pub trait PositiveDown: Construct {
        /// Points down with magnitude `1` (down is positive and up is negative).
        const DOWN: Self;
    }

    /// Trait with a `UP` constant where down is positive and up is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ElementNegOne`].
    pub trait NegativeUp: Construct {
        /// Points up with magnitude `1` (down is positive and up is negative).
        const UP: Self;
    }

    impl<T: ElementOne> PositiveDown for T {
        const DOWN: Self = Self::ONE;
    }

    impl<T: ElementNegOne> NegativeUp for T {
        const UP: Self = Self::NEG_ONE;
    }

    impl<T: ElementZero + ElementOne + ElementOfVector<2, S>, S: Simdness> PositiveDown
        for Vector<2, T, S>
    {
        const DOWN: Self = Self::Y;
    }

    impl<T: ElementZero + ElementOne + ElementOfVector<3, S>, S: Simdness> PositiveDown
        for Vector<3, T, S>
    {
        const DOWN: Self = Self::Y;
    }

    impl<T: ElementZero + ElementOne + ElementOfVector<4, S>, S: Simdness> PositiveDown
        for Vector<4, T, S>
    {
        const DOWN: Self = Self::Y;
    }

    impl<T: ElementZero + ElementNegOne + ElementOfVector<2, S>, S: Simdness> NegativeUp
        for Vector<2, T, S>
    {
        const UP: Self = Self::NEG_Y;
    }

    impl<T: ElementZero + ElementNegOne + ElementOfVector<3, S>, S: Simdness> NegativeUp
        for Vector<3, T, S>
    {
        const UP: Self = Self::NEG_Y;
    }

    impl<T: ElementZero + ElementNegOne + ElementOfVector<4, S>, S: Simdness> NegativeUp
        for Vector<4, T, S>
    {
        const UP: Self = Self::NEG_Y;
    }
}

/// Module with `FORWARDS` and `BACKWARDS` constants where forwards is positive.
#[cfg(feature = "forwards")]
pub mod forwards {
    use crate::{
        Construct, ElementNegOne, ElementOfVector, ElementOne, ElementZero, Simdness, Vector,
    };

    /// Trait with a `FORWARDS` constant where forwards is positive and backwards is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ElementOne`].
    pub trait PositiveForwards: Construct {
        /// Points forwards with magnitude `1` (forwards is positive and backwards is negative).
        const FORWARDS: Self;
    }

    /// Trait with a `BACKWARDS` constant where forwards is positive and backwards is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ElementNegOne`].
    pub trait NegativeBackwards: Construct {
        /// Points backwards with magnitude `1` (forwards is positive and backwards is negative).
        const BACKWARDS: Self;
    }

    impl<T: ElementOne> PositiveForwards for T {
        const FORWARDS: Self = Self::ONE;
    }

    impl<T: ElementNegOne> NegativeBackwards for T {
        const BACKWARDS: Self = Self::NEG_ONE;
    }

    impl<T: ElementZero + ElementOne + ElementOfVector<3, S>, S: Simdness> PositiveForwards
        for Vector<3, T, S>
    {
        const FORWARDS: Self = Self::Z;
    }

    impl<T: ElementZero + ElementOne + ElementOfVector<4, S>, S: Simdness> PositiveForwards
        for Vector<4, T, S>
    {
        const FORWARDS: Self = Self::Z;
    }

    impl<T: ElementZero + ElementNegOne + ElementOfVector<3, S>, S: Simdness> NegativeBackwards
        for Vector<3, T, S>
    {
        const BACKWARDS: Self = Self::NEG_Z;
    }

    impl<T: ElementZero + ElementNegOne + ElementOfVector<4, S>, S: Simdness> NegativeBackwards
        for Vector<4, T, S>
    {
        const BACKWARDS: Self = Self::NEG_Z;
    }
}

/// Module with `BACKWARDS` and `FORWARDS` constants where backwards is positive.
#[cfg(feature = "backwards")]
pub mod backwards {
    use crate::{
        Construct, ElementNegOne, ElementOfVector, ElementOne, ElementZero, Simdness, Vector,
    };

    /// Trait with a `BACKWARDS` constant where backwards is positive and forwards is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ElementOne`].
    pub trait PositiveBackwards: Construct {
        /// Points backwards with magnitude `1` (backwards is positive and forwards is negative).
        const BACKWARDS: Self;
    }

    /// Trait with a `FORWARDS` constant where backwards is positive and forwards is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ElementNegOne`].
    pub trait NegativeForwards: Construct {
        /// Points forwards with magnitude `1` (backwards is positive and forwards is negative).
        const FORWARDS: Self;
    }

    impl<T: ElementOne> PositiveBackwards for T {
        const BACKWARDS: Self = Self::ONE;
    }

    impl<T: ElementNegOne> NegativeForwards for T {
        const FORWARDS: Self = Self::NEG_ONE;
    }

    impl<T: ElementZero + ElementOne + ElementOfVector<3, S>, S: Simdness> PositiveBackwards
        for Vector<3, T, S>
    {
        const BACKWARDS: Self = Self::Z;
    }

    impl<T: ElementZero + ElementOne + ElementOfVector<4, S>, S: Simdness> PositiveBackwards
        for Vector<4, T, S>
    {
        const BACKWARDS: Self = Self::Z;
    }

    impl<T: ElementZero + ElementNegOne + ElementOfVector<3, S>, S: Simdness> NegativeForwards
        for Vector<3, T, S>
    {
        const FORWARDS: Self = Self::NEG_Z;
    }

    impl<T: ElementZero + ElementNegOne + ElementOfVector<4, S>, S: Simdness> NegativeForwards
        for Vector<4, T, S>
    {
        const FORWARDS: Self = Self::NEG_Z;
    }
}
