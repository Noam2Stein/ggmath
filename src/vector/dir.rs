// This file was generated by an associated codegen crate.
// To modify this file, modify the source code of the associated codegen crate.

use core::mem::transmute_copy;

use crate::{
    Usize,
    vector::{Scalar, Vec2, Vec3, Vec4, VecAligned, VecAlignment, VecLen, VecPacked, Vector},
};

/// A trait for scalar types that have a `0` value.
///
/// This trait along with `ScalarOne` and `ScalarNegOne`
/// automatically enables direction constants like `RIGHT` if positive-direction features are enabled.
pub trait ScalarZero: Scalar {
    /// The zero value of the scalar type.
    const ZERO: Self;

    /// A vec2 of all `0`s.
    ///
    /// This is only required because `Vector::from_array` doesn't support const contexts.
    /// When Rust's const context capabilities increase, this will be removed.
    const VEC2_ZERO: Vec2<Self>;

    /// A vec3 of all `0`s.
    ///
    /// This is only required because `Vector::from_array` doesn't support const contexts.
    /// When Rust's const context capabilities increase, this will be removed.
    const VEC3_ZERO: Vec3<Self>;

    /// A vec4 of all `0`s.
    ///
    /// This is only required because `Vector::from_array` doesn't support const contexts.
    /// When Rust's const context capabilities increase, this will be removed.
    const VEC4_ZERO: Vec4<Self>;
}

/// A trait for scalar types that have a `1` value.
///
/// This trait along with `ScalarZero` and `ScalarNegOne`
/// automatically enables direction constants like `RIGHT` if positive-direction features are enabled.
pub trait ScalarOne: ScalarZero {
    /// The one value of the scalar type.
    const ONE: Self;

    /// A vec2 of all `1`s.
    ///
    /// This is only required because `Vector::from_array` doesn't support const contexts.
    /// When Rust's const context capabilities increase, this will be removed.
    const VEC2_ONE: Vec2<Self>;

    /// A vec2 that points to the positive `X` direction with magnitude `1`.
    const VEC2_X: Vec2<Self>;

    /// A vec2 that points to the positive `Y` direction with magnitude `1`.
    const VEC2_Y: Vec2<Self>;

    /// A vec3 of all `1`s.
    ///
    /// This is only required because `Vector::from_array` doesn't support const contexts.
    /// When Rust's const context capabilities increase, this will be removed.
    const VEC3_ONE: Vec3<Self>;

    /// A vec3 that points to the positive `X` direction with magnitude `1`.
    const VEC3_X: Vec3<Self>;

    /// A vec3 that points to the positive `Y` direction with magnitude `1`.
    const VEC3_Y: Vec3<Self>;

    /// A vec3 that points to the positive `Z` direction with magnitude `1`.
    const VEC3_Z: Vec3<Self>;

    /// A vec4 of all `1`s.
    ///
    /// This is only required because `Vector::from_array` doesn't support const contexts.
    /// When Rust's const context capabilities increase, this will be removed.
    const VEC4_ONE: Vec4<Self>;

    /// A vec4 that points to the positive `X` direction with magnitude `1`.
    const VEC4_X: Vec4<Self>;

    /// A vec4 that points to the positive `Y` direction with magnitude `1`.
    const VEC4_Y: Vec4<Self>;

    /// A vec4 that points to the positive `Z` direction with magnitude `1`.
    const VEC4_Z: Vec4<Self>;

    /// A vec4 that points to the positive `W` direction with magnitude `1`.
    const VEC4_W: Vec4<Self>;
}

/// A trait for scalar types that have a `-1` value.
///
/// This trait along with `ScalarZero` and `ScalarOne`
/// automatically enables direction constants like `RIGHT` if positive-direction features are enabled.
pub trait ScalarNegOne: ScalarZero {
    /// The negative one value of the scalar type.
    const NEG_ONE: Self;

    /// A vec2 of all `-1`s.
    ///
    /// This is only required because `Vector::from_array` doesn't support const contexts.
    /// When Rust's const context capabilities increase, this will be removed.
    const VEC2_NEG_ONE: Vec2<Self>;

    /// A vec2 that points to the negative `X` direction with magnitude `1`.
    const VEC2_NEG_X: Vec2<Self>;

    /// A vec2 that points to the negative `Y` direction with magnitude `1`.
    const VEC2_NEG_Y: Vec2<Self>;

    /// A vec3 of all `-1`s.
    ///
    /// This is only required because `Vector::from_array` doesn't support const contexts.
    /// When Rust's const context capabilities increase, this will be removed.
    const VEC3_NEG_ONE: Vec3<Self>;

    /// A vec3 that points to the negative `X` direction with magnitude `1`.
    const VEC3_NEG_X: Vec3<Self>;

    /// A vec3 that points to the negative `Y` direction with magnitude `1`.
    const VEC3_NEG_Y: Vec3<Self>;

    /// A vec3 that points to the negative `Z` direction with magnitude `1`.
    const VEC3_NEG_Z: Vec3<Self>;

    /// A vec4 of all `-1`s.
    ///
    /// This is only required because `Vector::from_array` doesn't support const contexts.
    /// When Rust's const context capabilities increase, this will be removed.
    const VEC4_NEG_ONE: Vec4<Self>;

    /// A vec4 that points to the negative `X` direction with magnitude `1`.
    const VEC4_NEG_X: Vec4<Self>;

    /// A vec4 that points to the negative `Y` direction with magnitude `1`.
    const VEC4_NEG_Y: Vec4<Self>;

    /// A vec4 that points to the negative `Z` direction with magnitude `1`.
    const VEC4_NEG_Z: Vec4<Self>;

    /// A vec4 that points to the negative `W` direction with magnitude `1`.
    const VEC4_NEG_W: Vec4<Self>;
}

impl<const N: usize, T: ScalarZero, A: VecAlignment> Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    /// A vector of all `0`s.
    pub const ZERO: Self = {
        unsafe {
            if A::IS_ALIGNED {
                match N {
                    2 => transmute_copy::<Vector<2, T, VecAligned>, Vector<N, T, A>>(T::VEC2_ZERO),
                    3 => transmute_copy::<Vector<3, T, VecAligned>, Vector<N, T, A>>(T::VEC3_ZERO),
                    4 => transmute_copy::<Vector<4, T, VecAligned>, Vector<N, T, A>>(T::VEC4_ZERO),
                }
            } else {
                return transmute_copy::<Vector<N, T, VecPacked>, Vector<N, T, A>>(Vector(
                    [T::ZERO; N],
                ));
            }
        }

        unreachable!("unusual vector type");
    };
}

impl<const N: usize, T: ScalarOne, A: VecAlignment> Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    /// A vector of all `1`s.
    pub const ONE: Self = {
        unsafe {
            if A::IS_ALIGNED {
                match N {
                    2 => transmute_copy::<Vector<2, T, VecAligned>, Vector<N, T, A>>(T::VEC2_ONE),
                    3 => transmute_copy::<Vector<3, T, VecAligned>, Vector<N, T, A>>(T::VEC3_ONE),
                    4 => transmute_copy::<Vector<4, T, VecAligned>, Vector<N, T, A>>(T::VEC4_ONE),
                }
            } else {
                return transmute_copy::<Vector<N, T, VecPacked>, Vector<N, T, A>>(Vector(
                    [T::ONE; N],
                ));
            }
        }

        unreachable!("unusual vector type");
    };
}

impl<const N: usize, T: ScalarNegOne, A: VecAlignment> Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    /// A vector of all `-1`s.
    pub const NEG_ONE: Self = {
        unsafe {
            if A::IS_ALIGNED {
                match N {
                    2 => {
                        transmute_copy::<Vector<2, T, VecAligned>, Vector<N, T, A>>(T::VEC2_NEG_ONE)
                    }
                    3 => {
                        transmute_copy::<Vector<3, T, VecAligned>, Vector<N, T, A>>(T::VEC3_NEG_ONE)
                    }
                    4 => {
                        transmute_copy::<Vector<4, T, VecAligned>, Vector<N, T, A>>(T::VEC4_NEG_ONE)
                    }
                }
            } else {
                return transmute_copy::<Vector<N, T, VecPacked>, Vector<N, T, A>>(Vector(
                    [T::NEG_ONE; N],
                ));
            }
        }

        unreachable!("unusual vector type");
    };
}

impl<T: ScalarOne, A: VecAlignment> Vector<2, T, A> {
    /// A vector that points to the positive `X` direction with magnitude `1`.
    pub const X: Self = {
        unsafe {
            if A::IS_ALIGNED {
                return transmute_copy::<Vector<2, T, VecAligned>, Vector<2, T, A>>(T::VEC2_X);
            } else {
                return transmute_copy::<Vector<2, T, VecPacked>, Vector<2, T, A>>(Vector(
                    [T::X; 2],
                ));
            }
        }

        unreachable!("unusual vector type");
    };

    /// A vector that points to the positive `Y` direction with magnitude `1`.
    pub const Y: Self = {
        unsafe {
            if A::IS_ALIGNED {
                return transmute_copy::<Vector<2, T, VecAligned>, Vector<2, T, A>>(T::VEC2_Y);
            } else {
                return transmute_copy::<Vector<2, T, VecPacked>, Vector<2, T, A>>(Vector(
                    [T::Y; 2],
                ));
            }
        }

        unreachable!("unusual vector type");
    };
}

impl<T: ScalarOne, A: VecAlignment> Vector<3, T, A> {
    /// A vector that points to the positive `X` direction with magnitude `1`.
    pub const X: Self = {
        unsafe {
            if A::IS_ALIGNED {
                return transmute_copy::<Vector<3, T, VecAligned>, Vector<3, T, A>>(T::VEC3_X);
            } else {
                return transmute_copy::<Vector<3, T, VecPacked>, Vector<3, T, A>>(Vector(
                    [T::X; 3],
                ));
            }
        }

        unreachable!("unusual vector type");
    };

    /// A vector that points to the positive `Y` direction with magnitude `1`.
    pub const Y: Self = {
        unsafe {
            if A::IS_ALIGNED {
                return transmute_copy::<Vector<3, T, VecAligned>, Vector<3, T, A>>(T::VEC3_Y);
            } else {
                return transmute_copy::<Vector<3, T, VecPacked>, Vector<3, T, A>>(Vector(
                    [T::Y; 3],
                ));
            }
        }

        unreachable!("unusual vector type");
    };

    /// A vector that points to the positive `Z` direction with magnitude `1`.
    pub const Z: Self = {
        unsafe {
            if A::IS_ALIGNED {
                return transmute_copy::<Vector<3, T, VecAligned>, Vector<3, T, A>>(T::VEC3_Z);
            } else {
                return transmute_copy::<Vector<3, T, VecPacked>, Vector<3, T, A>>(Vector(
                    [T::Z; 3],
                ));
            }
        }

        unreachable!("unusual vector type");
    };
}

impl<T: ScalarOne, A: VecAlignment> Vector<4, T, A> {
    /// A vector that points to the positive `X` direction with magnitude `1`.
    pub const X: Self = {
        unsafe {
            if A::IS_ALIGNED {
                return transmute_copy::<Vector<4, T, VecAligned>, Vector<4, T, A>>(T::VEC4_X);
            } else {
                return transmute_copy::<Vector<4, T, VecPacked>, Vector<4, T, A>>(Vector(
                    [T::X; 4],
                ));
            }
        }

        unreachable!("unusual vector type");
    };

    /// A vector that points to the positive `Y` direction with magnitude `1`.
    pub const Y: Self = {
        unsafe {
            if A::IS_ALIGNED {
                return transmute_copy::<Vector<4, T, VecAligned>, Vector<4, T, A>>(T::VEC4_Y);
            } else {
                return transmute_copy::<Vector<4, T, VecPacked>, Vector<4, T, A>>(Vector(
                    [T::Y; 4],
                ));
            }
        }

        unreachable!("unusual vector type");
    };

    /// A vector that points to the positive `Z` direction with magnitude `1`.
    pub const Z: Self = {
        unsafe {
            if A::IS_ALIGNED {
                return transmute_copy::<Vector<4, T, VecAligned>, Vector<4, T, A>>(T::VEC4_Z);
            } else {
                return transmute_copy::<Vector<4, T, VecPacked>, Vector<4, T, A>>(Vector(
                    [T::Z; 4],
                ));
            }
        }

        unreachable!("unusual vector type");
    };

    /// A vector that points to the positive `W` direction with magnitude `1`.
    pub const W: Self = {
        unsafe {
            if A::IS_ALIGNED {
                return transmute_copy::<Vector<4, T, VecAligned>, Vector<4, T, A>>(T::VEC4_W);
            } else {
                return transmute_copy::<Vector<4, T, VecPacked>, Vector<4, T, A>>(Vector(
                    [T::W; 4],
                ));
            }
        }

        unreachable!("unusual vector type");
    };
}

impl<T: ScalarNegOne, A: VecAlignment> Vector<2, T, A> {
    /// A vector that points to the negative `X` direction with magnitude `1`.
    pub const X: Self = {
        unsafe {
            if A::IS_ALIGNED {
                return transmute_copy::<Vector<2, T, VecAligned>, Vector<2, T, A>>(T::VEC2_NEG_X);
            } else {
                return transmute_copy::<Vector<2, T, VecPacked>, Vector<2, T, A>>(Vector(
                    [T::NEG_X; 2],
                ));
            }
        }

        unreachable!("unusual vector type");
    };
    /// A vector that points to the negative `Y` direction with magnitude `1`.
    pub const Y: Self = {
        unsafe {
            if A::IS_ALIGNED {
                return transmute_copy::<Vector<2, T, VecAligned>, Vector<2, T, A>>(T::VEC2_NEG_Y);
            } else {
                return transmute_copy::<Vector<2, T, VecPacked>, Vector<2, T, A>>(Vector(
                    [T::NEG_Y; 2],
                ));
            }
        }

        unreachable!("unusual vector type");
    };
}

impl<T: ScalarNegOne, A: VecAlignment> Vector<3, T, A> {
    /// A vector that points to the negative `X` direction with magnitude `1`.
    pub const X: Self = {
        unsafe {
            if A::IS_ALIGNED {
                return transmute_copy::<Vector<3, T, VecAligned>, Vector<3, T, A>>(T::VEC3_NEG_X);
            } else {
                return transmute_copy::<Vector<3, T, VecPacked>, Vector<3, T, A>>(Vector(
                    [T::NEG_X; 3],
                ));
            }
        }

        unreachable!("unusual vector type");
    };
    /// A vector that points to the negative `Y` direction with magnitude `1`.
    pub const Y: Self = {
        unsafe {
            if A::IS_ALIGNED {
                return transmute_copy::<Vector<3, T, VecAligned>, Vector<3, T, A>>(T::VEC3_NEG_Y);
            } else {
                return transmute_copy::<Vector<3, T, VecPacked>, Vector<3, T, A>>(Vector(
                    [T::NEG_Y; 3],
                ));
            }
        }

        unreachable!("unusual vector type");
    };
    /// A vector that points to the negative `Z` direction with magnitude `1`.
    pub const Z: Self = {
        unsafe {
            if A::IS_ALIGNED {
                return transmute_copy::<Vector<3, T, VecAligned>, Vector<3, T, A>>(T::VEC3_NEG_Z);
            } else {
                return transmute_copy::<Vector<3, T, VecPacked>, Vector<3, T, A>>(Vector(
                    [T::NEG_Z; 3],
                ));
            }
        }

        unreachable!("unusual vector type");
    };
}

impl<T: ScalarNegOne, A: VecAlignment> Vector<4, T, A> {
    /// A vector that points to the negative `X` direction with magnitude `1`.
    pub const X: Self = {
        unsafe {
            if A::IS_ALIGNED {
                return transmute_copy::<Vector<4, T, VecAligned>, Vector<4, T, A>>(T::VEC4_NEG_X);
            } else {
                return transmute_copy::<Vector<4, T, VecPacked>, Vector<4, T, A>>(Vector(
                    [T::NEG_X; 4],
                ));
            }
        }

        unreachable!("unusual vector type");
    };
    /// A vector that points to the negative `Y` direction with magnitude `1`.
    pub const Y: Self = {
        unsafe {
            if A::IS_ALIGNED {
                return transmute_copy::<Vector<4, T, VecAligned>, Vector<4, T, A>>(T::VEC4_NEG_Y);
            } else {
                return transmute_copy::<Vector<4, T, VecPacked>, Vector<4, T, A>>(Vector(
                    [T::NEG_Y; 4],
                ));
            }
        }

        unreachable!("unusual vector type");
    };
    /// A vector that points to the negative `Z` direction with magnitude `1`.
    pub const Z: Self = {
        unsafe {
            if A::IS_ALIGNED {
                return transmute_copy::<Vector<4, T, VecAligned>, Vector<4, T, A>>(T::VEC4_NEG_Z);
            } else {
                return transmute_copy::<Vector<4, T, VecPacked>, Vector<4, T, A>>(Vector(
                    [T::NEG_Z; 4],
                ));
            }
        }

        unreachable!("unusual vector type");
    };
    /// A vector that points to the negative `W` direction with magnitude `1`.
    pub const W: Self = {
        unsafe {
            if A::IS_ALIGNED {
                return transmute_copy::<Vector<4, T, VecAligned>, Vector<4, T, A>>(T::VEC4_NEG_W);
            } else {
                return transmute_copy::<Vector<4, T, VecPacked>, Vector<4, T, A>>(Vector(
                    [T::NEG_W; 4],
                ));
            }
        }

        unreachable!("unusual vector type");
    };
}

/// A module for traits with `RIGHT` and `LEFT` constants,
/// where right is the positive direction.
#[cfg(feature = "right")]
pub mod right {
    use crate::{Construct, ScalarNegOne, ScalarOne, ScalarZero, VecAlignment, Vector};

    /// A trait for a `RIGHT` constant where right is the positive direction.
    pub trait PositiveRight: Construct {
        /// A value that points right with magnitude `1` where right is the positive direction.
        const RIGHT: Self;
    }

    /// A trait for a `LEFT` constant where right is the positive direction.
    pub trait NegativeLeft: Construct {
        /// A value that points left with magnitude `1` where right is the positive direction.
        const LEFT: Self;
    }

    impl<T: ScalarOne> PositiveRight for T {
        const RIGHT: Self = Self::ONE;
    }

    impl<T: ScalarNegOne> NegativeLeft for T {
        const LEFT: Self = Self::NEG_ONE;
    }

    impl<T: ScalarZero + ScalarOne, A: VecAlignment> PositiveRight for Vector<2, T, A> {
        const RIGHT: Self = Self::X;
    }

    impl<T: ScalarZero + ScalarNegOne, A: VecAlignment> NegativeLeft for Vector<2, T, A> {
        const LEFT: Self = Self::NEG_X;
    }

    impl<T: ScalarZero + ScalarOne, A: VecAlignment> PositiveRight for Vector<3, T, A> {
        const RIGHT: Self = Self::X;
    }

    impl<T: ScalarZero + ScalarNegOne, A: VecAlignment> NegativeLeft for Vector<3, T, A> {
        const LEFT: Self = Self::NEG_X;
    }

    impl<T: ScalarZero + ScalarOne, A: VecAlignment> PositiveRight for Vector<4, T, A> {
        const RIGHT: Self = Self::X;
    }

    impl<T: ScalarZero + ScalarNegOne, A: VecAlignment> NegativeLeft for Vector<4, T, A> {
        const LEFT: Self = Self::NEG_X;
    }
}

/// A module for vectors with `RIGHT` and `LEFT` constants,
/// where left is the positive direction.
#[cfg(feature = "left")]
pub mod left {
    use crate::{Construct, ScalarNegOne, ScalarOne, ScalarZero, VecAlignment, Vector};

    /// A trait for a `RIGHT` constant where left is the positive direction.
    pub trait NegativeRight: Construct {
        /// A value that points right with magnitude `1` where left is the positive direction.
        const RIGHT: Self;
    }

    /// A trait for a `LEFT` constant where left is the positive direction.
    pub trait PositiveLeft: Construct {
        /// A value that points left with magnitude `1` where left is the positive direction.
        const LEFT: Self;
    }

    impl<T: ScalarOne> PositiveLeft for T {
        const LEFT: Self = Self::ONE;
    }

    impl<T: ScalarNegOne> NegativeRight for T {
        const RIGHT: Self = Self::NEG_ONE;
    }

    impl<T: ScalarZero + ScalarNegOne, A: VecAlignment> NegativeRight for Vector<2, T, A> {
        const RIGHT: Self = Self::NEG_X;
    }

    impl<T: ScalarZero + ScalarOne, A: VecAlignment> PositiveLeft for Vector<2, T, A> {
        const LEFT: Self = Self::X;
    }

    impl<T: ScalarZero + ScalarNegOne, A: VecAlignment> NegativeRight for Vector<3, T, A> {
        const RIGHT: Self = Self::NEG_X;
    }

    impl<T: ScalarZero + ScalarOne, A: VecAlignment> PositiveLeft for Vector<3, T, A> {
        const LEFT: Self = Self::X;
    }

    impl<T: ScalarZero + ScalarNegOne, A: VecAlignment> NegativeRight for Vector<4, T, A> {
        const RIGHT: Self = Self::NEG_X;
    }

    impl<T: ScalarZero + ScalarOne, A: VecAlignment> PositiveLeft for Vector<4, T, A> {
        const LEFT: Self = Self::X;
    }
}

/// A module for traits with `UP` and `DOWN` constants,
/// where up is the positive direction.
#[cfg(feature = "up")]
pub mod up {
    use crate::{Construct, ScalarNegOne, ScalarOne, ScalarZero, VecAlignment, Vector};

    /// A trait for a `UP` constant where up is the positive direction.
    pub trait PositiveUp: Construct {
        /// A value that points up with magnitude `1` where up is the positive direction.
        const UP: Self;
    }

    /// A trait for a `DOWN` constant where up is the positive direction.
    pub trait NegativeDown: Construct {
        /// A value that points down with magnitude `1` where up is the positive direction.
        const DOWN: Self;
    }

    impl<T: ScalarOne> PositiveUp for T {
        const UP: Self = Self::ONE;
    }

    impl<T: ScalarNegOne> NegativeDown for T {
        const DOWN: Self = Self::NEG_ONE;
    }

    impl<T: ScalarZero + ScalarOne, A: VecAlignment> PositiveUp for Vector<2, T, A> {
        const UP: Self = Self::Y;
    }

    impl<T: ScalarZero + ScalarNegOne, A: VecAlignment> NegativeDown for Vector<2, T, A> {
        const DOWN: Self = Self::NEG_Y;
    }

    impl<T: ScalarZero + ScalarOne, A: VecAlignment> PositiveUp for Vector<3, T, A> {
        const UP: Self = Self::Y;
    }

    impl<T: ScalarZero + ScalarNegOne, A: VecAlignment> NegativeDown for Vector<3, T, A> {
        const DOWN: Self = Self::NEG_Y;
    }

    impl<T: ScalarZero + ScalarOne, A: VecAlignment> PositiveUp for Vector<4, T, A> {
        const UP: Self = Self::Y;
    }

    impl<T: ScalarZero + ScalarNegOne, A: VecAlignment> NegativeDown for Vector<4, T, A> {
        const DOWN: Self = Self::NEG_Y;
    }
}

/// A module for vectors with `UP` and `DOWN` constants,
/// where down is the positive direction.
#[cfg(feature = "down")]
pub mod down {
    use crate::{Construct, ScalarNegOne, ScalarOne, ScalarZero, VecAlignment, Vector};

    /// A trait for a `UP` constant where down is the positive direction.
    pub trait NegativeUp: Construct {
        /// A value that points up with magnitude `1` where down is the positive direction.
        const UP: Self;
    }

    /// A trait for a `DOWN` constant where down is the positive direction.
    pub trait PositiveDown: Construct {
        /// A value that points down with magnitude `1` where down is the positive direction.
        const DOWN: Self;
    }

    impl<T: ScalarOne> PositiveDown for T {
        const DOWN: Self = Self::ONE;
    }

    impl<T: ScalarNegOne> NegativeUp for T {
        const UP: Self = Self::NEG_ONE;
    }

    impl<T: ScalarZero + ScalarNegOne, A: VecAlignment> NegativeUp for Vector<2, T, A> {
        const UP: Self = Self::NEG_Y;
    }

    impl<T: ScalarZero + ScalarOne, A: VecAlignment> PositiveDown for Vector<2, T, A> {
        const DOWN: Self = Self::Y;
    }

    impl<T: ScalarZero + ScalarNegOne, A: VecAlignment> NegativeUp for Vector<3, T, A> {
        const UP: Self = Self::NEG_Y;
    }

    impl<T: ScalarZero + ScalarOne, A: VecAlignment> PositiveDown for Vector<3, T, A> {
        const DOWN: Self = Self::Y;
    }

    impl<T: ScalarZero + ScalarNegOne, A: VecAlignment> NegativeUp for Vector<4, T, A> {
        const UP: Self = Self::NEG_Y;
    }

    impl<T: ScalarZero + ScalarOne, A: VecAlignment> PositiveDown for Vector<4, T, A> {
        const DOWN: Self = Self::Y;
    }
}

/// A module for traits with `FORWARD` and `BACKWARD` constants,
/// where forwards is the positive direction.
#[cfg(feature = "forwards")]
pub mod forwards {
    use crate::{Construct, ScalarNegOne, ScalarOne, ScalarZero, VecAlignment, Vector};

    /// A trait for a `FORWARD` constant where forwards is the positive direction.
    pub trait PositiveForward: Construct {
        /// A value that points forwards with magnitude `1` where forwards is the positive direction.
        const FORWARD: Self;
    }

    /// A trait for a `BACKWARD` constant where forwards is the positive direction.
    pub trait NegativeBackward: Construct {
        /// A value that points backwards with magnitude `1` where forwards is the positive direction.
        const BACKWARD: Self;
    }

    impl<T: ScalarOne> PositiveForward for T {
        const FORWARD: Self = Self::ONE;
    }

    impl<T: ScalarNegOne> NegativeBackward for T {
        const BACKWARD: Self = Self::NEG_ONE;
    }

    impl<T: ScalarZero + ScalarOne, A: VecAlignment> PositiveForward for Vector<3, T, A> {
        const FORWARD: Self = Self::Z;
    }

    impl<T: ScalarZero + ScalarNegOne, A: VecAlignment> NegativeBackward for Vector<3, T, A> {
        const BACKWARD: Self = Self::NEG_Z;
    }

    impl<T: ScalarZero + ScalarOne, A: VecAlignment> PositiveForward for Vector<4, T, A> {
        const FORWARD: Self = Self::Z;
    }

    impl<T: ScalarZero + ScalarNegOne, A: VecAlignment> NegativeBackward for Vector<4, T, A> {
        const BACKWARD: Self = Self::NEG_Z;
    }
}

/// A module for vectors with `FORWARD` and `BACKWARD` constants,
/// where backwards is the positive direction.
#[cfg(feature = "backwards")]
pub mod backwards {
    use crate::{Construct, ScalarNegOne, ScalarOne, ScalarZero, VecAlignment, Vector};

    /// A trait for a `FORWARD` constant where backwards is the positive direction.
    pub trait NegativeForward: Construct {
        /// A value that points forwards with magnitude `1` where backwards is the positive direction.
        const FORWARD: Self;
    }

    /// A trait for a `BACKWARD` constant where backwards is the positive direction.
    pub trait PositiveBackward: Construct {
        /// A value that points backwards with magnitude `1` where backwards is the positive direction.
        const BACKWARD: Self;
    }

    impl<T: ScalarOne> PositiveBackward for T {
        const BACKWARD: Self = Self::ONE;
    }

    impl<T: ScalarNegOne> NegativeForward for T {
        const FORWARD: Self = Self::NEG_ONE;
    }

    impl<T: ScalarZero + ScalarNegOne, A: VecAlignment> NegativeForward for Vector<3, T, A> {
        const FORWARD: Self = Self::NEG_Z;
    }

    impl<T: ScalarZero + ScalarOne, A: VecAlignment> PositiveBackward for Vector<3, T, A> {
        const BACKWARD: Self = Self::Z;
    }

    impl<T: ScalarZero + ScalarNegOne, A: VecAlignment> NegativeForward for Vector<4, T, A> {
        const FORWARD: Self = Self::NEG_Z;
    }

    impl<T: ScalarZero + ScalarOne, A: VecAlignment> PositiveBackward for Vector<4, T, A> {
        const BACKWARD: Self = Self::Z;
    }
}
