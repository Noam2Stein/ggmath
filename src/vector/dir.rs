// This file was generated by an associated codegen crate.
// To modify this file, modify the source code of the associated codegen crate.

use core::mem::transmute_copy;

use crate::{Scalar, Usize, Vec2, Vec3, Vec4, VecAligned, VecAlignment, VecLen, VecPacked, Vector};

/// A trait for scalar types that have a `0` value.
///
/// This trait along with `ScalarOne` and `ScalarNegOne`
/// automatically enables direction constants like `RIGHT`, `UP`, and `FORWARD` if direction cargo features are enabled.
pub trait ScalarZero: Scalar {
    /// `0`
    const ZERO: Self;

    /// A vec2 of all `0`s.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC2_ZERO: Vec2<Self>;
    /// A vec3 of all `0`s.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC3_ZERO: Vec3<Self>;
    /// A vec4 of all `0`s.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC4_ZERO: Vec4<Self>;
}

/// A trait for scalar types that have a `1` value.
///
/// This trait along with `ScalarZero` and `ScalarNegOne`
/// automatically enables direction constants like `RIGHT`, `UP`, and `FORWARD` if direction cargo features are enabled.
pub trait ScalarOne: ScalarZero {
    /// `1`
    const ONE: Self;

    /// A vec2 of all `1`s.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC2_ONE: Vec2<Self>;

    /// A vec2 that points to the positive `x` direction with magnitude `1`.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC2_X: Vec2<Self>;
    /// A vec2 that points to the positive `y` direction with magnitude `1`.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC2_Y: Vec2<Self>;

    /// A vec3 of all `1`s.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC3_ONE: Vec3<Self>;

    /// A vec3 that points to the positive `x` direction with magnitude `1`.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC3_X: Vec3<Self>;
    /// A vec3 that points to the positive `y` direction with magnitude `1`.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC3_Y: Vec3<Self>;
    /// A vec3 that points to the positive `z` direction with magnitude `1`.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC3_Z: Vec3<Self>;

    /// A vec4 of all `1`s.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC4_ONE: Vec4<Self>;

    /// A vec4 that points to the positive `x` direction with magnitude `1`.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC4_X: Vec4<Self>;
    /// A vec4 that points to the positive `y` direction with magnitude `1`.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC4_Y: Vec4<Self>;
    /// A vec4 that points to the positive `z` direction with magnitude `1`.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC4_Z: Vec4<Self>;
    /// A vec4 that points to the positive `w` direction with magnitude `1`.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC4_W: Vec4<Self>;
}

/// A trait for scalar types that have a `-1` value.
///
/// This trait along with `ScalarZero` and `ScalarOne`
/// automatically enables direction constants like `RIGHT`, `UP`, and `FORWARD` if direction cargo features are enabled.
pub trait ScalarNegOne: ScalarZero {
    /// `-1`
    const NEG_ONE: Self;

    /// A vec2 of all `-1`s.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC2_NEG_ONE: Vec2<Self>;

    /// A vec2 that points to the negative `x` direction with magnitude `1`.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC2_NEG_X: Vec2<Self>;
    /// A vec2 that points to the negative `y` direction with magnitude `1`.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC2_NEG_Y: Vec2<Self>;

    /// A vec3 of all `-1`s.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC3_NEG_ONE: Vec3<Self>;

    /// A vec3 that points to the negative `x` direction with magnitude `1`.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC3_NEG_X: Vec3<Self>;
    /// A vec3 that points to the negative `y` direction with magnitude `1`.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC3_NEG_Y: Vec3<Self>;
    /// A vec3 that points to the negative `z` direction with magnitude `1`.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC3_NEG_Z: Vec3<Self>;

    /// A vec4 of all `-1`s.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC4_NEG_ONE: Vec4<Self>;

    /// A vec4 that points to the negative `x` direction with magnitude `1`.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC4_NEG_X: Vec4<Self>;
    /// A vec4 that points to the negative `y` direction with magnitude `1`.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC4_NEG_Y: Vec4<Self>;
    /// A vec4 that points to the negative `z` direction with magnitude `1`.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC4_NEG_Z: Vec4<Self>;
    /// A vec4 that points to the negative `w` direction with magnitude `1`.
    /// This only exists because Rust const traits aren't stable yet.
    const VEC4_NEG_W: Vec4<Self>;
}

impl<const N: usize, T: ScalarZero, A: VecAlignment> Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    /// All `0`.
    pub const ZERO: Self = {
        unsafe {
            if A::IS_ALIGNED {
                match N {
                    2 => transmute_copy::<Vector<2, T, VecAligned>, Vector<N, T, A>>(&T::VEC2_ZERO),
                    3 => transmute_copy::<Vector<3, T, VecAligned>, Vector<N, T, A>>(&T::VEC3_ZERO),
                    4 => transmute_copy::<Vector<4, T, VecAligned>, Vector<N, T, A>>(&T::VEC4_ZERO),
                    _ => panic!("unusual vector type"),
                }
            } else {
                transmute_copy::<Vector<N, T, VecPacked>, Vector<N, T, A>>(&Vector([T::ZERO; N]))
            }
        }
    };
}

impl<const N: usize, T: ScalarOne, A: VecAlignment> Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    /// All `1`.
    pub const ONE: Self = {
        unsafe {
            if A::IS_ALIGNED {
                match N {
                    2 => transmute_copy::<Vector<2, T, VecAligned>, Vector<N, T, A>>(&T::VEC2_ONE),
                    3 => transmute_copy::<Vector<3, T, VecAligned>, Vector<N, T, A>>(&T::VEC3_ONE),
                    4 => transmute_copy::<Vector<4, T, VecAligned>, Vector<N, T, A>>(&T::VEC4_ONE),
                    _ => panic!("unusual vector type"),
                }
            } else {
                transmute_copy::<Vector<N, T, VecPacked>, Vector<N, T, A>>(&Vector([T::ONE; N]))
            }
        }
    };
}

impl<const N: usize, T: ScalarNegOne, A: VecAlignment> Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    /// All `-1`.
    pub const NEG_ONE: Self = {
        unsafe {
            if A::IS_ALIGNED {
                match N {
                    2 => transmute_copy::<Vector<2, T, VecAligned>, Vector<N, T, A>>(
                        &T::VEC2_NEG_ONE,
                    ),
                    3 => transmute_copy::<Vector<3, T, VecAligned>, Vector<N, T, A>>(
                        &T::VEC3_NEG_ONE,
                    ),
                    4 => transmute_copy::<Vector<4, T, VecAligned>, Vector<N, T, A>>(
                        &T::VEC4_NEG_ONE,
                    ),
                    _ => panic!("unusual vector type"),
                }
            } else {
                transmute_copy::<Vector<N, T, VecPacked>, Vector<N, T, A>>(&Vector([T::NEG_ONE; N]))
            }
        }
    };
}

impl<T: ScalarOne, A: VecAlignment> Vector<2, T, A> {
    /// A vector that points to the positive `x` direction with magnitude `1`.
    pub const X: Self = {
        unsafe {
            if A::IS_ALIGNED {
                transmute_copy::<Vector<2, T, VecAligned>, Vector<2, T, A>>(&T::VEC2_X)
            } else {
                transmute_copy::<Vector<2, T, VecPacked>, Vector<2, T, A>>(&Vector([
                    T::ONE,
                    T::ZERO,
                ]))
            }
        }
    };

    /// A vector that points to the positive `y` direction with magnitude `1`.
    pub const Y: Self = {
        unsafe {
            if A::IS_ALIGNED {
                transmute_copy::<Vector<2, T, VecAligned>, Vector<2, T, A>>(&T::VEC2_Y)
            } else {
                transmute_copy::<Vector<2, T, VecPacked>, Vector<2, T, A>>(&Vector([
                    T::ZERO,
                    T::ONE,
                ]))
            }
        }
    };
}

impl<T: ScalarOne, A: VecAlignment> Vector<3, T, A> {
    /// A vector that points to the positive `x` direction with magnitude `1`.
    pub const X: Self = {
        unsafe {
            if A::IS_ALIGNED {
                transmute_copy::<Vector<3, T, VecAligned>, Vector<3, T, A>>(&T::VEC3_X)
            } else {
                transmute_copy::<Vector<3, T, VecPacked>, Vector<3, T, A>>(&Vector([
                    T::ONE,
                    T::ZERO,
                    T::ZERO,
                ]))
            }
        }
    };

    /// A vector that points to the positive `y` direction with magnitude `1`.
    pub const Y: Self = {
        unsafe {
            if A::IS_ALIGNED {
                transmute_copy::<Vector<3, T, VecAligned>, Vector<3, T, A>>(&T::VEC3_Y)
            } else {
                transmute_copy::<Vector<3, T, VecPacked>, Vector<3, T, A>>(&Vector([
                    T::ZERO,
                    T::ONE,
                    T::ZERO,
                ]))
            }
        }
    };

    /// A vector that points to the positive `z` direction with magnitude `1`.
    pub const Z: Self = {
        unsafe {
            if A::IS_ALIGNED {
                transmute_copy::<Vector<3, T, VecAligned>, Vector<3, T, A>>(&T::VEC3_Z)
            } else {
                transmute_copy::<Vector<3, T, VecPacked>, Vector<3, T, A>>(&Vector([
                    T::ZERO,
                    T::ZERO,
                    T::ONE,
                ]))
            }
        }
    };
}

impl<T: ScalarOne, A: VecAlignment> Vector<4, T, A> {
    /// A vector that points to the positive `x` direction with magnitude `1`.
    pub const X: Self = {
        unsafe {
            if A::IS_ALIGNED {
                transmute_copy::<Vector<4, T, VecAligned>, Vector<4, T, A>>(&T::VEC4_X)
            } else {
                transmute_copy::<Vector<4, T, VecPacked>, Vector<4, T, A>>(&Vector([
                    T::ONE,
                    T::ZERO,
                    T::ZERO,
                    T::ZERO,
                ]))
            }
        }
    };

    /// A vector that points to the positive `y` direction with magnitude `1`.
    pub const Y: Self = {
        unsafe {
            if A::IS_ALIGNED {
                transmute_copy::<Vector<4, T, VecAligned>, Vector<4, T, A>>(&T::VEC4_Y)
            } else {
                transmute_copy::<Vector<4, T, VecPacked>, Vector<4, T, A>>(&Vector([
                    T::ZERO,
                    T::ONE,
                    T::ZERO,
                    T::ZERO,
                ]))
            }
        }
    };

    /// A vector that points to the positive `z` direction with magnitude `1`.
    pub const Z: Self = {
        unsafe {
            if A::IS_ALIGNED {
                transmute_copy::<Vector<4, T, VecAligned>, Vector<4, T, A>>(&T::VEC4_Z)
            } else {
                transmute_copy::<Vector<4, T, VecPacked>, Vector<4, T, A>>(&Vector([
                    T::ZERO,
                    T::ZERO,
                    T::ONE,
                    T::ZERO,
                ]))
            }
        }
    };

    /// A vector that points to the positive `w` direction with magnitude `1`.
    pub const W: Self = {
        unsafe {
            if A::IS_ALIGNED {
                transmute_copy::<Vector<4, T, VecAligned>, Vector<4, T, A>>(&T::VEC4_W)
            } else {
                transmute_copy::<Vector<4, T, VecPacked>, Vector<4, T, A>>(&Vector([
                    T::ZERO,
                    T::ZERO,
                    T::ZERO,
                    T::ONE,
                ]))
            }
        }
    };
}

impl<T: ScalarNegOne, A: VecAlignment> Vector<2, T, A> {
    /// A vector that points to the negative `x` direction with magnitude `1`.
    pub const NEG_X: Self = {
        unsafe {
            if A::IS_ALIGNED {
                transmute_copy::<Vector<2, T, VecAligned>, Vector<2, T, A>>(&T::VEC2_NEG_X)
            } else {
                transmute_copy::<Vector<2, T, VecPacked>, Vector<2, T, A>>(&Vector([
                    T::NEG_ONE,
                    T::ZERO,
                ]))
            }
        }
    };

    /// A vector that points to the negative `y` direction with magnitude `1`.
    pub const NEG_Y: Self = {
        unsafe {
            if A::IS_ALIGNED {
                transmute_copy::<Vector<2, T, VecAligned>, Vector<2, T, A>>(&T::VEC2_NEG_Y)
            } else {
                transmute_copy::<Vector<2, T, VecPacked>, Vector<2, T, A>>(&Vector([
                    T::ZERO,
                    T::NEG_ONE,
                ]))
            }
        }
    };
}

impl<T: ScalarNegOne, A: VecAlignment> Vector<3, T, A> {
    /// A vector that points to the negative `x` direction with magnitude `1`.
    pub const NEG_X: Self = {
        unsafe {
            if A::IS_ALIGNED {
                transmute_copy::<Vector<3, T, VecAligned>, Vector<3, T, A>>(&T::VEC3_NEG_X)
            } else {
                transmute_copy::<Vector<3, T, VecPacked>, Vector<3, T, A>>(&Vector([
                    T::NEG_ONE,
                    T::ZERO,
                    T::ZERO,
                ]))
            }
        }
    };

    /// A vector that points to the negative `y` direction with magnitude `1`.
    pub const NEG_Y: Self = {
        unsafe {
            if A::IS_ALIGNED {
                transmute_copy::<Vector<3, T, VecAligned>, Vector<3, T, A>>(&T::VEC3_NEG_Y)
            } else {
                transmute_copy::<Vector<3, T, VecPacked>, Vector<3, T, A>>(&Vector([
                    T::ZERO,
                    T::NEG_ONE,
                    T::ZERO,
                ]))
            }
        }
    };

    /// A vector that points to the negative `z` direction with magnitude `1`.
    pub const NEG_Z: Self = {
        unsafe {
            if A::IS_ALIGNED {
                transmute_copy::<Vector<3, T, VecAligned>, Vector<3, T, A>>(&T::VEC3_NEG_Z)
            } else {
                transmute_copy::<Vector<3, T, VecPacked>, Vector<3, T, A>>(&Vector([
                    T::ZERO,
                    T::ZERO,
                    T::NEG_ONE,
                ]))
            }
        }
    };
}

impl<T: ScalarNegOne, A: VecAlignment> Vector<4, T, A> {
    /// A vector that points to the negative `x` direction with magnitude `1`.
    pub const NEG_X: Self = {
        unsafe {
            if A::IS_ALIGNED {
                transmute_copy::<Vector<4, T, VecAligned>, Vector<4, T, A>>(&T::VEC4_NEG_X)
            } else {
                transmute_copy::<Vector<4, T, VecPacked>, Vector<4, T, A>>(&Vector([
                    T::NEG_ONE,
                    T::ZERO,
                    T::ZERO,
                    T::ZERO,
                ]))
            }
        }
    };

    /// A vector that points to the negative `y` direction with magnitude `1`.
    pub const NEG_Y: Self = {
        unsafe {
            if A::IS_ALIGNED {
                transmute_copy::<Vector<4, T, VecAligned>, Vector<4, T, A>>(&T::VEC4_NEG_Y)
            } else {
                transmute_copy::<Vector<4, T, VecPacked>, Vector<4, T, A>>(&Vector([
                    T::ZERO,
                    T::NEG_ONE,
                    T::ZERO,
                    T::ZERO,
                ]))
            }
        }
    };

    /// A vector that points to the negative `z` direction with magnitude `1`.
    pub const NEG_Z: Self = {
        unsafe {
            if A::IS_ALIGNED {
                transmute_copy::<Vector<4, T, VecAligned>, Vector<4, T, A>>(&T::VEC4_NEG_Z)
            } else {
                transmute_copy::<Vector<4, T, VecPacked>, Vector<4, T, A>>(&Vector([
                    T::ZERO,
                    T::ZERO,
                    T::NEG_ONE,
                    T::ZERO,
                ]))
            }
        }
    };

    /// A vector that points to the negative `w` direction with magnitude `1`.
    pub const NEG_W: Self = {
        unsafe {
            if A::IS_ALIGNED {
                transmute_copy::<Vector<4, T, VecAligned>, Vector<4, T, A>>(&T::VEC4_NEG_W)
            } else {
                transmute_copy::<Vector<4, T, VecPacked>, Vector<4, T, A>>(&Vector([
                    T::ZERO,
                    T::ZERO,
                    T::ZERO,
                    T::NEG_ONE,
                ]))
            }
        }
    };
}

/// `RIGHT` and `LEFT constants where right is positive and left is negative.
#[cfg(feature = "right")]
pub mod right {
    use crate::{Construct, ScalarNegOne, ScalarOne, VecAlignment, Vector};

    /// `RIGHT` constant where right is positive and left is negative.
    pub trait PositiveRight: Construct {
        /// A value that points right with a magnitude of one,
        /// where right is positive and left is negative.
        const RIGHT: Self;
    }

    /// `LEFT` constant where right is positive and left is negative.
    pub trait NegativeLeft: Construct {
        /// A value that points left with a magnitude of one,
        /// where right is positive and left is negative.
        const LEFT: Self;
    }

    impl<T: ScalarOne> PositiveRight for T {
        const RIGHT: Self = Self::ONE;
    }

    impl<T: ScalarNegOne> NegativeLeft for T {
        const LEFT: Self = Self::NEG_ONE;
    }

    impl<T: ScalarOne, A: VecAlignment> PositiveRight for Vector<2, T, A> {
        const RIGHT: Self = Self::X;
    }

    impl<T: ScalarNegOne, A: VecAlignment> NegativeLeft for Vector<2, T, A> {
        const LEFT: Self = Self::NEG_X;
    }

    impl<T: ScalarOne, A: VecAlignment> PositiveRight for Vector<3, T, A> {
        const RIGHT: Self = Self::X;
    }

    impl<T: ScalarNegOne, A: VecAlignment> NegativeLeft for Vector<3, T, A> {
        const LEFT: Self = Self::NEG_X;
    }

    impl<T: ScalarOne, A: VecAlignment> PositiveRight for Vector<4, T, A> {
        const RIGHT: Self = Self::X;
    }

    impl<T: ScalarNegOne, A: VecAlignment> NegativeLeft for Vector<4, T, A> {
        const LEFT: Self = Self::NEG_X;
    }
}

/// `RIGHT` and `LEFT constants where left is positive and right is negative.
#[cfg(feature = "left")]
pub mod left {
    use crate::{Construct, ScalarNegOne, ScalarOne, VecAlignment, Vector};

    /// `RIGHT` constant where left is positive and right is negative.
    pub trait NegativeRight: Construct {
        /// A value that points right with a magnitude of one,
        /// where left is positive and right is negative.
        const RIGHT: Self;
    }

    /// `LEFT` constant where left is positive and right is negative.
    pub trait PositiveLeft: Construct {
        /// A value that points left with a magnitude of one,
        /// where left is positive and right is negative.
        const LEFT: Self;
    }

    impl<T: ScalarNegOne> NegativeRight for T {
        const RIGHT: Self = Self::NEG_ONE;
    }

    impl<T: ScalarOne> PositiveLeft for T {
        const LEFT: Self = Self::ONE;
    }

    impl<T: ScalarNegOne, A: VecAlignment> NegativeRight for Vector<2, T, A> {
        const RIGHT: Self = Self::NEG_X;
    }

    impl<T: ScalarOne, A: VecAlignment> PositiveLeft for Vector<2, T, A> {
        const LEFT: Self = Self::X;
    }

    impl<T: ScalarNegOne, A: VecAlignment> NegativeRight for Vector<3, T, A> {
        const RIGHT: Self = Self::NEG_X;
    }

    impl<T: ScalarOne, A: VecAlignment> PositiveLeft for Vector<3, T, A> {
        const LEFT: Self = Self::X;
    }

    impl<T: ScalarNegOne, A: VecAlignment> NegativeRight for Vector<4, T, A> {
        const RIGHT: Self = Self::NEG_X;
    }

    impl<T: ScalarOne, A: VecAlignment> PositiveLeft for Vector<4, T, A> {
        const LEFT: Self = Self::X;
    }
}

/// `UP` and `DOWN constants where up is positive and down is negative.
#[cfg(feature = "up")]
pub mod up {
    use crate::{Construct, ScalarNegOne, ScalarOne, VecAlignment, Vector};

    /// `UP` constant where up is positive and down is negative.
    pub trait PositiveUp: Construct {
        /// A value that points up with a magnitude of one,
        /// where up is positive and down is negative.
        const UP: Self;
    }

    /// `DOWN` constant where up is positive and down is negative.
    pub trait NegativeDown: Construct {
        /// A value that points down with a magnitude of one,
        /// where up is positive and down is negative.
        const DOWN: Self;
    }

    impl<T: ScalarOne> PositiveUp for T {
        const UP: Self = Self::ONE;
    }

    impl<T: ScalarNegOne> NegativeDown for T {
        const DOWN: Self = Self::NEG_ONE;
    }

    impl<T: ScalarOne, A: VecAlignment> PositiveUp for Vector<2, T, A> {
        const UP: Self = Self::Y;
    }

    impl<T: ScalarNegOne, A: VecAlignment> NegativeDown for Vector<2, T, A> {
        const DOWN: Self = Self::NEG_Y;
    }

    impl<T: ScalarOne, A: VecAlignment> PositiveUp for Vector<3, T, A> {
        const UP: Self = Self::Y;
    }

    impl<T: ScalarNegOne, A: VecAlignment> NegativeDown for Vector<3, T, A> {
        const DOWN: Self = Self::NEG_Y;
    }

    impl<T: ScalarOne, A: VecAlignment> PositiveUp for Vector<4, T, A> {
        const UP: Self = Self::Y;
    }

    impl<T: ScalarNegOne, A: VecAlignment> NegativeDown for Vector<4, T, A> {
        const DOWN: Self = Self::NEG_Y;
    }
}

/// `UP` and `DOWN constants where down is positive and up is negative.
#[cfg(feature = "down")]
pub mod down {
    use crate::{Construct, ScalarNegOne, ScalarOne, VecAlignment, Vector};

    /// `UP` constant where down is positive and up is negative.
    pub trait NegativeUp: Construct {
        /// A value that points up with a magnitude of one,
        /// where down is positive and up is negative.
        const UP: Self;
    }

    /// `DOWN` constant where down is positive and up is negative.
    pub trait PositiveDown: Construct {
        /// A value that points down with a magnitude of one,
        /// where down is positive and up is negative.
        const DOWN: Self;
    }

    impl<T: ScalarNegOne> NegativeUp for T {
        const UP: Self = Self::NEG_ONE;
    }

    impl<T: ScalarOne> PositiveDown for T {
        const DOWN: Self = Self::ONE;
    }

    impl<T: ScalarNegOne, A: VecAlignment> NegativeUp for Vector<2, T, A> {
        const UP: Self = Self::NEG_Y;
    }

    impl<T: ScalarOne, A: VecAlignment> PositiveDown for Vector<2, T, A> {
        const DOWN: Self = Self::Y;
    }

    impl<T: ScalarNegOne, A: VecAlignment> NegativeUp for Vector<3, T, A> {
        const UP: Self = Self::NEG_Y;
    }

    impl<T: ScalarOne, A: VecAlignment> PositiveDown for Vector<3, T, A> {
        const DOWN: Self = Self::Y;
    }

    impl<T: ScalarNegOne, A: VecAlignment> NegativeUp for Vector<4, T, A> {
        const UP: Self = Self::NEG_Y;
    }

    impl<T: ScalarOne, A: VecAlignment> PositiveDown for Vector<4, T, A> {
        const DOWN: Self = Self::Y;
    }
}

/// `FORWARDS` and `BACKWARDS constants where forwards is positive and backwards is negative.
#[cfg(feature = "forwards")]
pub mod forwards {
    use crate::{Construct, ScalarNegOne, ScalarOne, VecAlignment, Vector};

    /// `FORWARDS` constant where forwards is positive and backwards is negative.
    pub trait PositiveForwards: Construct {
        /// A value that points forwards with a magnitude of one,
        /// where forwards is positive and backwards is negative.
        const FORWARDS: Self;
    }

    /// `BACKWARDS` constant where forwards is positive and backwards is negative.
    pub trait NegativeBackwards: Construct {
        /// A value that points backwards with a magnitude of one,
        /// where forwards is positive and backwards is negative.
        const BACKWARDS: Self;
    }

    impl<T: ScalarOne> PositiveForwards for T {
        const FORWARDS: Self = Self::ONE;
    }

    impl<T: ScalarNegOne> NegativeBackwards for T {
        const BACKWARDS: Self = Self::NEG_ONE;
    }

    impl<T: ScalarOne, A: VecAlignment> PositiveForwards for Vector<3, T, A> {
        const FORWARDS: Self = Self::Z;
    }

    impl<T: ScalarNegOne, A: VecAlignment> NegativeBackwards for Vector<3, T, A> {
        const BACKWARDS: Self = Self::NEG_Z;
    }

    impl<T: ScalarOne, A: VecAlignment> PositiveForwards for Vector<4, T, A> {
        const FORWARDS: Self = Self::Z;
    }

    impl<T: ScalarNegOne, A: VecAlignment> NegativeBackwards for Vector<4, T, A> {
        const BACKWARDS: Self = Self::NEG_Z;
    }
}

/// `FORWARDS` and `BACKWARDS constants where backwards is positive and forwards is negative.
#[cfg(feature = "backwards")]
pub mod backwards {
    use crate::{Construct, ScalarNegOne, ScalarOne, VecAlignment, Vector};

    /// `FORWARDS` constant where backwards is positive and forwards is negative.
    pub trait NegativeForwards: Construct {
        /// A value that points forwards with a magnitude of one,
        /// where backwards is positive and forwards is negative.
        const FORWARDS: Self;
    }

    /// `BACKWARDS` constant where backwards is positive and forwards is negative.
    pub trait PositiveBackwards: Construct {
        /// A value that points backwards with a magnitude of one,
        /// where backwards is positive and forwards is negative.
        const BACKWARDS: Self;
    }

    impl<T: ScalarNegOne> NegativeForwards for T {
        const FORWARDS: Self = Self::NEG_ONE;
    }

    impl<T: ScalarOne> PositiveBackwards for T {
        const BACKWARDS: Self = Self::ONE;
    }

    impl<T: ScalarNegOne, A: VecAlignment> NegativeForwards for Vector<3, T, A> {
        const FORWARDS: Self = Self::NEG_Z;
    }

    impl<T: ScalarOne, A: VecAlignment> PositiveBackwards for Vector<3, T, A> {
        const BACKWARDS: Self = Self::Z;
    }

    impl<T: ScalarNegOne, A: VecAlignment> NegativeForwards for Vector<4, T, A> {
        const FORWARDS: Self = Self::NEG_Z;
    }

    impl<T: ScalarOne, A: VecAlignment> PositiveBackwards for Vector<4, T, A> {
        const BACKWARDS: Self = Self::Z;
    }
}
