// This file was generated by a codegen tool.
// To modify this file, modify the source code of the codegen tool.

use crate::{Construct, ElementOfVector, Simdness, Vector};

/// Trait for scalar types that have a `ZERO` value.
/// "scalar" means a single-dimensional number, not a vector.
pub trait ScalarZero: Construct {
    /// `0` constant.
    const ZERO: Self;
}

/// Trait for scalar types that have a `ONE` value.
/// "scalar" means a single-dimensional number, not a vector.
pub trait ScalarOne: Construct {
    /// `1` constant.
    const ONE: Self;
}

/// Trait for scalar types that have a `NEG_ONE` value.
/// "scalar" means a single-dimensional number, not a vector.
pub trait ScalarNegOne: Construct {
    /// `-1` constant.
    const NEG_ONE: Self;
}

macro_rules! impl_for_float {
    ($T:ty) => {
        impl ScalarZero for $T {
            const ZERO: Self = 0.0;
        }

        impl ScalarOne for $T {
            const ONE: Self = 1.0;
        }

        impl ScalarNegOne for $T {
            const NEG_ONE: Self = -1.0;
        }
    };
}
impl_for_float!(f32);
impl_for_float!(f64);

macro_rules! impl_for_sint {
    ($T:ty) => {
        impl ScalarZero for $T {
            const ZERO: Self = 0;
        }

        impl ScalarOne for $T {
            const ONE: Self = 1;
        }

        impl ScalarNegOne for $T {
            const NEG_ONE: Self = -1;
        }
    };
}
impl_for_sint!(i8);
impl_for_sint!(i16);
impl_for_sint!(i32);
impl_for_sint!(i64);
impl_for_sint!(i128);
impl_for_sint!(isize);

macro_rules! impl_for_uint {
    ($T:ty) => {
        impl ScalarZero for $T {
            const ZERO: Self = 0;
        }

        impl ScalarOne for $T {
            const ONE: Self = 1;
        }
    };
}
impl_for_uint!(u8);
impl_for_uint!(u16);
impl_for_uint!(u32);
impl_for_uint!(u64);
impl_for_uint!(u128);
impl_for_uint!(usize);

impl<const N: usize, T: ScalarZero + ElementOfVector<N, S>, S: Simdness> Vector<N, T, S> {
    /// Vector with all elements set to `0`.
    pub const ZERO: Self = Self::const_from_array([T::ZERO; N]);
}

impl<const N: usize, T: ScalarOne + ElementOfVector<N, S>, S: Simdness> Vector<N, T, S> {
    /// Vector with all elements set to `1`.
    pub const ONE: Self = Self::const_from_array([T::ONE; N]);
}

impl<const N: usize, T: ScalarNegOne + ElementOfVector<N, S>, S: Simdness> Vector<N, T, S> {
    /// Vector with all elements set to `-1`.
    pub const NEG_ONE: Self = Self::const_from_array([T::NEG_ONE; N]);
}

impl<T: ScalarZero + ScalarOne + ElementOfVector<2, S>, S: Simdness> Vector<2, T, S> {
    /// Vector pointing to the positive direction of the `x` (1st) axis with magnitude `1`.
    pub const X: Self = Self::const_from_array([T::ONE, T::ZERO]);

    /// Vector pointing to the positive direction of the `y` (2nd) axis with magnitude `1`.
    pub const Y: Self = Self::const_from_array([T::ZERO, T::ONE]);
}

impl<T: ScalarZero + ScalarOne + ElementOfVector<3, S>, S: Simdness> Vector<3, T, S> {
    /// Vector pointing to the positive direction of the `x` (1st) axis with magnitude `1`.
    pub const X: Self = Self::const_from_array([T::ONE, T::ZERO, T::ZERO]);

    /// Vector pointing to the positive direction of the `y` (2nd) axis with magnitude `1`.
    pub const Y: Self = Self::const_from_array([T::ZERO, T::ONE, T::ZERO]);

    /// Vector pointing to the positive direction of the `z` (3rd) axis with magnitude `1`.
    pub const Z: Self = Self::const_from_array([T::ZERO, T::ZERO, T::ONE]);
}

impl<T: ScalarZero + ScalarOne + ElementOfVector<4, S>, S: Simdness> Vector<4, T, S> {
    /// Vector pointing to the positive direction of the `x` (1st) axis with magnitude `1`.
    pub const X: Self = Self::const_from_array([T::ONE, T::ZERO, T::ZERO, T::ZERO]);

    /// Vector pointing to the positive direction of the `y` (2nd) axis with magnitude `1`.
    pub const Y: Self = Self::const_from_array([T::ZERO, T::ONE, T::ZERO, T::ZERO]);

    /// Vector pointing to the positive direction of the `z` (3rd) axis with magnitude `1`.
    pub const Z: Self = Self::const_from_array([T::ZERO, T::ZERO, T::ONE, T::ZERO]);

    /// Vector pointing to the positive direction of the `w` (4th) axis with magnitude `1`.
    pub const W: Self = Self::const_from_array([T::ZERO, T::ZERO, T::ZERO, T::ONE]);
}

impl<T: ScalarZero + ScalarNegOne + ElementOfVector<2, S>, S: Simdness> Vector<2, T, S> {
    /// Vector pointing to the negative direction of the `x` (1st) axis with magnitude `1`.
    pub const NEG_X: Self = Self::const_from_array([T::NEG_ONE, T::ZERO]);

    /// Vector pointing to the negative direction of the `y` (2nd) axis with magnitude `1`.
    pub const NEG_Y: Self = Self::const_from_array([T::ZERO, T::NEG_ONE]);
}

impl<T: ScalarZero + ScalarNegOne + ElementOfVector<3, S>, S: Simdness> Vector<3, T, S> {
    /// Vector pointing to the negative direction of the `x` (1st) axis with magnitude `1`.
    pub const NEG_X: Self = Self::const_from_array([T::NEG_ONE, T::ZERO, T::ZERO]);

    /// Vector pointing to the negative direction of the `y` (2nd) axis with magnitude `1`.
    pub const NEG_Y: Self = Self::const_from_array([T::ZERO, T::NEG_ONE, T::ZERO]);

    /// Vector pointing to the negative direction of the `z` (3rd) axis with magnitude `1`.
    pub const NEG_Z: Self = Self::const_from_array([T::ZERO, T::ZERO, T::NEG_ONE]);
}

impl<T: ScalarZero + ScalarNegOne + ElementOfVector<4, S>, S: Simdness> Vector<4, T, S> {
    /// Vector pointing to the negative direction of the `x` (1st) axis with magnitude `1`.
    pub const NEG_X: Self = Self::const_from_array([T::NEG_ONE, T::ZERO, T::ZERO, T::ZERO]);

    /// Vector pointing to the negative direction of the `y` (2nd) axis with magnitude `1`.
    pub const NEG_Y: Self = Self::const_from_array([T::ZERO, T::NEG_ONE, T::ZERO, T::ZERO]);

    /// Vector pointing to the negative direction of the `z` (3rd) axis with magnitude `1`.
    pub const NEG_Z: Self = Self::const_from_array([T::ZERO, T::ZERO, T::NEG_ONE, T::ZERO]);

    /// Vector pointing to the negative direction of the `w` (4th) axis with magnitude `1`.
    pub const NEG_W: Self = Self::const_from_array([T::ZERO, T::ZERO, T::ZERO, T::NEG_ONE]);
}

/// Module with `RIGHT` and `LEFT` constants where right is positive.
#[cfg(feature = "right")]
pub mod right {
    use crate::{
        Construct, ElementOfVector, ScalarNegOne, ScalarOne, ScalarZero, Simdness, Vector,
    };

    /// Trait with a `RIGHT` constant where right is positive and left is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ScalarOne`].
    pub trait PositiveRight: Construct {
        /// Points right with magnitude `1` (where right is positive and left is negative).
        const RIGHT: Self;
    }

    /// Trait with a `LEFT` constant where right is positive and left is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ScalarNegOne`].
    pub trait NegativeLeft: Construct {
        /// Points left with magnitude `1` (where right is positive and left is negative).
        const LEFT: Self;
    }

    impl<T: ScalarOne> PositiveRight for T {
        const RIGHT: Self = Self::ONE;
    }

    impl<T: ScalarNegOne> NegativeLeft for T {
        const LEFT: Self = Self::NEG_ONE;
    }

    impl<T: ScalarZero + ScalarOne + ElementOfVector<2, S>, S: Simdness> PositiveRight
        for Vector<2, T, S>
    {
        const RIGHT: Self = Self::X;
    }

    impl<T: ScalarZero + ScalarOne + ElementOfVector<3, S>, S: Simdness> PositiveRight
        for Vector<3, T, S>
    {
        const RIGHT: Self = Self::X;
    }

    impl<T: ScalarZero + ScalarOne + ElementOfVector<4, S>, S: Simdness> PositiveRight
        for Vector<4, T, S>
    {
        const RIGHT: Self = Self::X;
    }

    impl<T: ScalarZero + ScalarNegOne + ElementOfVector<2, S>, S: Simdness> NegativeLeft
        for Vector<2, T, S>
    {
        const LEFT: Self = Self::NEG_X;
    }

    impl<T: ScalarZero + ScalarNegOne + ElementOfVector<3, S>, S: Simdness> NegativeLeft
        for Vector<3, T, S>
    {
        const LEFT: Self = Self::NEG_X;
    }

    impl<T: ScalarZero + ScalarNegOne + ElementOfVector<4, S>, S: Simdness> NegativeLeft
        for Vector<4, T, S>
    {
        const LEFT: Self = Self::NEG_X;
    }
}

/// Module with `LEFT` and `RIGHT` constants where left is positive.
#[cfg(feature = "left")]
pub mod left {
    use crate::{
        Construct, ElementOfVector, ScalarNegOne, ScalarOne, ScalarZero, Simdness, Vector,
    };

    /// Trait with a `LEFT` constant where left is positive and right is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ScalarOne`].
    pub trait PositiveLeft: Construct {
        /// Points left with magnitude `1` (where left is positive and right is negative).
        const LEFT: Self;
    }

    /// Trait with a `RIGHT` constant where left is positive and right is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ScalarNegOne`].
    pub trait NegativeRight: Construct {
        /// Points right with magnitude `1` (where left is positive and right is negative).
        const RIGHT: Self;
    }

    impl<T: ScalarOne> PositiveLeft for T {
        const LEFT: Self = Self::ONE;
    }

    impl<T: ScalarNegOne> NegativeRight for T {
        const RIGHT: Self = Self::NEG_ONE;
    }

    impl<T: ScalarZero + ScalarOne + ElementOfVector<2, S>, S: Simdness> PositiveLeft
        for Vector<2, T, S>
    {
        const LEFT: Self = Self::X;
    }

    impl<T: ScalarZero + ScalarOne + ElementOfVector<3, S>, S: Simdness> PositiveLeft
        for Vector<3, T, S>
    {
        const LEFT: Self = Self::X;
    }

    impl<T: ScalarZero + ScalarOne + ElementOfVector<4, S>, S: Simdness> PositiveLeft
        for Vector<4, T, S>
    {
        const LEFT: Self = Self::X;
    }

    impl<T: ScalarZero + ScalarNegOne + ElementOfVector<2, S>, S: Simdness> NegativeRight
        for Vector<2, T, S>
    {
        const RIGHT: Self = Self::NEG_X;
    }

    impl<T: ScalarZero + ScalarNegOne + ElementOfVector<3, S>, S: Simdness> NegativeRight
        for Vector<3, T, S>
    {
        const RIGHT: Self = Self::NEG_X;
    }

    impl<T: ScalarZero + ScalarNegOne + ElementOfVector<4, S>, S: Simdness> NegativeRight
        for Vector<4, T, S>
    {
        const RIGHT: Self = Self::NEG_X;
    }
}

/// Module with `UP` and `DOWN` constants where up is positive.
#[cfg(feature = "up")]
pub mod up {
    use crate::{
        Construct, ElementOfVector, ScalarNegOne, ScalarOne, ScalarZero, Simdness, Vector,
    };

    /// Trait with a `UP` constant where up is positive and down is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ScalarOne`].
    pub trait PositiveUp: Construct {
        /// Points up with magnitude `1` (where up is positive and down is negative).
        const UP: Self;
    }

    /// Trait with a `DOWN` constant where up is positive and down is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ScalarNegOne`].
    pub trait NegativeDown: Construct {
        /// Points down with magnitude `1` (where up is positive and down is negative).
        const DOWN: Self;
    }

    impl<T: ScalarOne> PositiveUp for T {
        const UP: Self = Self::ONE;
    }

    impl<T: ScalarNegOne> NegativeDown for T {
        const DOWN: Self = Self::NEG_ONE;
    }

    impl<T: ScalarZero + ScalarOne + ElementOfVector<2, S>, S: Simdness> PositiveUp
        for Vector<2, T, S>
    {
        const UP: Self = Self::Y;
    }

    impl<T: ScalarZero + ScalarOne + ElementOfVector<3, S>, S: Simdness> PositiveUp
        for Vector<3, T, S>
    {
        const UP: Self = Self::Y;
    }

    impl<T: ScalarZero + ScalarOne + ElementOfVector<4, S>, S: Simdness> PositiveUp
        for Vector<4, T, S>
    {
        const UP: Self = Self::Y;
    }

    impl<T: ScalarZero + ScalarNegOne + ElementOfVector<2, S>, S: Simdness> NegativeDown
        for Vector<2, T, S>
    {
        const DOWN: Self = Self::NEG_Y;
    }

    impl<T: ScalarZero + ScalarNegOne + ElementOfVector<3, S>, S: Simdness> NegativeDown
        for Vector<3, T, S>
    {
        const DOWN: Self = Self::NEG_Y;
    }

    impl<T: ScalarZero + ScalarNegOne + ElementOfVector<4, S>, S: Simdness> NegativeDown
        for Vector<4, T, S>
    {
        const DOWN: Self = Self::NEG_Y;
    }
}

/// Module with `DOWN` and `UP` constants where down is positive.
#[cfg(feature = "down")]
pub mod down {
    use crate::{
        Construct, ElementOfVector, ScalarNegOne, ScalarOne, ScalarZero, Simdness, Vector,
    };

    /// Trait with a `DOWN` constant where down is positive and up is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ScalarOne`].
    pub trait PositiveDown: Construct {
        /// Points down with magnitude `1` (where down is positive and up is negative).
        const DOWN: Self;
    }

    /// Trait with a `UP` constant where down is positive and up is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ScalarNegOne`].
    pub trait NegativeUp: Construct {
        /// Points up with magnitude `1` (where down is positive and up is negative).
        const UP: Self;
    }

    impl<T: ScalarOne> PositiveDown for T {
        const DOWN: Self = Self::ONE;
    }

    impl<T: ScalarNegOne> NegativeUp for T {
        const UP: Self = Self::NEG_ONE;
    }

    impl<T: ScalarZero + ScalarOne + ElementOfVector<2, S>, S: Simdness> PositiveDown
        for Vector<2, T, S>
    {
        const DOWN: Self = Self::Y;
    }

    impl<T: ScalarZero + ScalarOne + ElementOfVector<3, S>, S: Simdness> PositiveDown
        for Vector<3, T, S>
    {
        const DOWN: Self = Self::Y;
    }

    impl<T: ScalarZero + ScalarOne + ElementOfVector<4, S>, S: Simdness> PositiveDown
        for Vector<4, T, S>
    {
        const DOWN: Self = Self::Y;
    }

    impl<T: ScalarZero + ScalarNegOne + ElementOfVector<2, S>, S: Simdness> NegativeUp
        for Vector<2, T, S>
    {
        const UP: Self = Self::NEG_Y;
    }

    impl<T: ScalarZero + ScalarNegOne + ElementOfVector<3, S>, S: Simdness> NegativeUp
        for Vector<3, T, S>
    {
        const UP: Self = Self::NEG_Y;
    }

    impl<T: ScalarZero + ScalarNegOne + ElementOfVector<4, S>, S: Simdness> NegativeUp
        for Vector<4, T, S>
    {
        const UP: Self = Self::NEG_Y;
    }
}

/// Module with `FORWARDS` and `BACKWARDS` constants where forwards is positive.
#[cfg(feature = "forwards")]
pub mod forwards {
    use crate::{
        Construct, ElementOfVector, ScalarNegOne, ScalarOne, ScalarZero, Simdness, Vector,
    };

    /// Trait with a `FORWARDS` constant where forwards is positive and backwards is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ScalarOne`].
    pub trait PositiveForwards: Construct {
        /// Points forwards with magnitude `1` (where forwards is positive and backwards is negative).
        const FORWARDS: Self;
    }

    /// Trait with a `BACKWARDS` constant where forwards is positive and backwards is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ScalarNegOne`].
    pub trait NegativeBackwards: Construct {
        /// Points backwards with magnitude `1` (where forwards is positive and backwards is negative).
        const BACKWARDS: Self;
    }

    impl<T: ScalarOne> PositiveForwards for T {
        const FORWARDS: Self = Self::ONE;
    }

    impl<T: ScalarNegOne> NegativeBackwards for T {
        const BACKWARDS: Self = Self::NEG_ONE;
    }

    impl<T: ScalarZero + ScalarOne + ElementOfVector<3, S>, S: Simdness> PositiveForwards
        for Vector<3, T, S>
    {
        const FORWARDS: Self = Self::Z;
    }

    impl<T: ScalarZero + ScalarOne + ElementOfVector<4, S>, S: Simdness> PositiveForwards
        for Vector<4, T, S>
    {
        const FORWARDS: Self = Self::Z;
    }

    impl<T: ScalarZero + ScalarNegOne + ElementOfVector<3, S>, S: Simdness> NegativeBackwards
        for Vector<3, T, S>
    {
        const BACKWARDS: Self = Self::NEG_Z;
    }

    impl<T: ScalarZero + ScalarNegOne + ElementOfVector<4, S>, S: Simdness> NegativeBackwards
        for Vector<4, T, S>
    {
        const BACKWARDS: Self = Self::NEG_Z;
    }
}

/// Module with `BACKWARDS` and `FORWARDS` constants where backwards is positive.
#[cfg(feature = "backwards")]
pub mod backwards {
    use crate::{
        Construct, ElementOfVector, ScalarNegOne, ScalarOne, ScalarZero, Simdness, Vector,
    };

    /// Trait with a `BACKWARDS` constant where backwards is positive and forwards is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ScalarOne`].
    pub trait PositiveBackwards: Construct {
        /// Points backwards with magnitude `1` (where backwards is positive and forwards is negative).
        const BACKWARDS: Self;
    }

    /// Trait with a `FORWARDS` constant where backwards is positive and forwards is negative.
    /// This trait is automatically implemented for vectors, and types that are [`ScalarNegOne`].
    pub trait NegativeForwards: Construct {
        /// Points forwards with magnitude `1` (where backwards is positive and forwards is negative).
        const FORWARDS: Self;
    }

    impl<T: ScalarOne> PositiveBackwards for T {
        const BACKWARDS: Self = Self::ONE;
    }

    impl<T: ScalarNegOne> NegativeForwards for T {
        const FORWARDS: Self = Self::NEG_ONE;
    }

    impl<T: ScalarZero + ScalarOne + ElementOfVector<3, S>, S: Simdness> PositiveBackwards
        for Vector<3, T, S>
    {
        const BACKWARDS: Self = Self::Z;
    }

    impl<T: ScalarZero + ScalarOne + ElementOfVector<4, S>, S: Simdness> PositiveBackwards
        for Vector<4, T, S>
    {
        const BACKWARDS: Self = Self::Z;
    }

    impl<T: ScalarZero + ScalarNegOne + ElementOfVector<3, S>, S: Simdness> NegativeForwards
        for Vector<3, T, S>
    {
        const FORWARDS: Self = Self::NEG_Z;
    }

    impl<T: ScalarZero + ScalarNegOne + ElementOfVector<4, S>, S: Simdness> NegativeForwards
        for Vector<4, T, S>
    {
        const FORWARDS: Self = Self::NEG_Z;
    }
}
