// This file was generated by an associated codegen crate.
// To modify this file, modify the source code of the associated codegen crate.

use crate::{Scalar, VecAlignment, Vector};

pub use crate::vec2;
pub use crate::vec2g;
pub use crate::vec2p;
pub use crate::vec3;
pub use crate::vec3g;
pub use crate::vec3p;
pub use crate::vec4;
pub use crate::vec4g;
pub use crate::vec4p;

#[macro_export]
macro_rules! vec2 {
    ($($field:expr),* $(,)?) => {
        $crate::Vec2::from(($($field,)*))
    }
}

#[macro_export]
macro_rules! vec3 {
    ($($field:expr),* $(,)?) => {
        $crate::Vec3::from(($($field,)*))
    }
}

#[macro_export]
macro_rules! vec4 {
    ($($field:expr),* $(,)?) => {
        $crate::Vec4::from(($($field,)*))
    }
}

#[macro_export]
macro_rules! vec2p {
    ($($field:expr),* $(,)?) => {
        $crate::Vec2P::from(($($field,)*))
    }
}

#[macro_export]
macro_rules! vec3p {
    ($($field:expr),* $(,)?) => {
        $crate::Vec3P::from(($($field,)*))
    }
}

#[macro_export]
macro_rules! vec4p {
    ($($field:expr),* $(,)?) => {
        $crate::Vec4P::from(($($field,)*))
    }
}

#[macro_export]
macro_rules! vec2g {
    ($($field:expr),* $(,)?) => {
        $crate::Vector::<2, _, _>::from(($($field,)*))
    }
}

#[macro_export]
macro_rules! vec3g {
    ($($field:expr),* $(,)?) => {
        $crate::Vector::<3, _, _>::from(($($field,)*))
    }
}

#[macro_export]
macro_rules! vec4g {
    ($($field:expr),* $(,)?) => {
        $crate::Vector::<4, _, _>::from(($($field,)*))
    }
}

impl<T: Scalar, A: VecAlignment, A0: VecAlignment> From<(Vector<2, T, A0>,)> for Vector<2, T, A> {
    fn from(value: (Vector<2, T, A0>,)) -> Self {
        Self::from_array([value.0.x(), value.0.y()])
    }
}

impl<T: Scalar, A: VecAlignment> From<(T, T)> for Vector<2, T, A> {
    fn from(value: (T, T)) -> Self {
        Self::from_array([value.0, value.1])
    }
}

impl<T: Scalar, A: VecAlignment, A0: VecAlignment> From<(Vector<3, T, A0>,)> for Vector<3, T, A> {
    fn from(value: (Vector<3, T, A0>,)) -> Self {
        Self::from_array([value.0.x(), value.0.y(), value.0.z()])
    }
}

impl<T: Scalar, A: VecAlignment, A1: VecAlignment> From<(T, Vector<2, T, A1>)> for Vector<3, T, A> {
    fn from(value: (T, Vector<2, T, A1>)) -> Self {
        Self::from_array([value.0, value.1.x(), value.1.y()])
    }
}

impl<T: Scalar, A: VecAlignment, A0: VecAlignment> From<(Vector<2, T, A0>, T)> for Vector<3, T, A> {
    fn from(value: (Vector<2, T, A0>, T)) -> Self {
        Self::from_array([value.0.x(), value.0.y(), value.1])
    }
}

impl<T: Scalar, A: VecAlignment> From<(T, T, T)> for Vector<3, T, A> {
    fn from(value: (T, T, T)) -> Self {
        Self::from_array([value.0, value.1, value.2])
    }
}

impl<T: Scalar, A: VecAlignment, A0: VecAlignment> From<(Vector<4, T, A0>,)> for Vector<4, T, A> {
    fn from(value: (Vector<4, T, A0>,)) -> Self {
        Self::from_array([value.0.x(), value.0.y(), value.0.z(), value.0.w()])
    }
}

impl<T: Scalar, A: VecAlignment, A1: VecAlignment> From<(T, Vector<3, T, A1>)> for Vector<4, T, A> {
    fn from(value: (T, Vector<3, T, A1>)) -> Self {
        Self::from_array([value.0, value.1.x(), value.1.y(), value.1.z()])
    }
}

impl<T: Scalar, A: VecAlignment, A0: VecAlignment, A1: VecAlignment>
    From<(Vector<2, T, A0>, Vector<2, T, A1>)> for Vector<4, T, A>
{
    fn from(value: (Vector<2, T, A0>, Vector<2, T, A1>)) -> Self {
        Self::from_array([value.0.x(), value.0.y(), value.1.x(), value.1.y()])
    }
}

impl<T: Scalar, A: VecAlignment, A2: VecAlignment> From<(T, T, Vector<2, T, A2>)>
    for Vector<4, T, A>
{
    fn from(value: (T, T, Vector<2, T, A2>)) -> Self {
        Self::from_array([value.0, value.1, value.2.x(), value.2.y()])
    }
}

impl<T: Scalar, A: VecAlignment, A0: VecAlignment> From<(Vector<3, T, A0>, T)> for Vector<4, T, A> {
    fn from(value: (Vector<3, T, A0>, T)) -> Self {
        Self::from_array([value.0.x(), value.0.y(), value.0.z(), value.1])
    }
}

impl<T: Scalar, A: VecAlignment, A1: VecAlignment> From<(T, Vector<2, T, A1>, T)>
    for Vector<4, T, A>
{
    fn from(value: (T, Vector<2, T, A1>, T)) -> Self {
        Self::from_array([value.0, value.1.x(), value.1.y(), value.2])
    }
}

impl<T: Scalar, A: VecAlignment, A0: VecAlignment> From<(Vector<2, T, A0>, T, T)>
    for Vector<4, T, A>
{
    fn from(value: (Vector<2, T, A0>, T, T)) -> Self {
        Self::from_array([value.0.x(), value.0.y(), value.1, value.2])
    }
}

impl<T: Scalar, A: VecAlignment> From<(T, T, T, T)> for Vector<4, T, A> {
    fn from(value: (T, T, T, T)) -> Self {
        Self::from_array([value.0, value.1, value.2, value.3])
    }
}
