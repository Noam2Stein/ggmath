// This file was generated by an associated codegen crate.
// To modify this file, modify the source code of the associated codegen crate.

use crate::{Scalar, VecAlignment, Vector};

pub use crate::vec2;
pub use crate::vec2g;
pub use crate::vec2p;
pub use crate::vec3;
pub use crate::vec3g;
pub use crate::vec3p;
pub use crate::vec4;
pub use crate::vec4g;
pub use crate::vec4p;

/// Creates a `Vec2<_>` from the given components and vectors.
///
/// # Example
/// ```
/// use ggmath::*;
///
/// fn example() -> Vec2<f32> {
///     vec2!(1.0, 2.0)
/// }
/// ```
#[macro_export]
macro_rules! vec2 {
    ($($field:expr),* $(,)?) => {
        $crate::Vec2::from(($($field,)*))
    }
}

/// Creates a `Vec3<_>` from the given components and vectors.
///
/// # Example
/// ```
/// use ggmath::*;
///
/// fn example() -> Vec3<f32> {
///     vec3!(1.0, vec2!(2.0, 3.0))
/// }
/// ```
#[macro_export]
macro_rules! vec3 {
    ($($field:expr),* $(,)?) => {
        $crate::Vec3::from(($($field,)*))
    }
}

/// Creates a `Vec4<_>` from the given components and vectors.
///
/// # Example
/// ```
/// use ggmath::*;
///
/// fn example() -> Vec4<f32> {
///     vec4!(1.0, vec2!(2.0, 3.0), 4.0)
/// }
/// ```
#[macro_export]
macro_rules! vec4 {
    ($($field:expr),* $(,)?) => {
        $crate::Vec4::from(($($field,)*))
    }
}

/// Creates a `Vec2P<_>` from the given components and vectors.
///
/// # Example
/// ```
/// use ggmath::*;
///
/// fn example() -> Vec2P<f32> {
///     vec2p!(1.0, 2.0)
/// }
/// ```
#[macro_export]
macro_rules! vec2p {
    ($($field:expr),* $(,)?) => {
        $crate::Vec2P::from(($($field,)*))
    }
}

/// Creates a `Vec3P<_>` from the given components and vectors.
///
/// # Example
/// ```
/// use ggmath::*;
///
/// fn example() -> Vec3P<f32> {
///     vec3p!(1.0, vec2p!(2.0, 3.0))
/// }
/// ```
#[macro_export]
macro_rules! vec3p {
    ($($field:expr),* $(,)?) => {
        $crate::Vec3P::from(($($field,)*))
    }
}

/// Creates a `Vec4P<_>` from the given components and vectors.
///
/// # Example
/// ```
/// use ggmath::*;
///
/// fn example() -> Vec4P<f32> {
///     vec4p!(1.0, vec2p!(2.0, 3.0), 4.0)
/// }
/// ```
#[macro_export]
macro_rules! vec4p {
    ($($field:expr),* $(,)?) => {
        $crate::Vec4P::from(($($field,)*))
    }
}

/// Creates a `Vector<2, _, _>` from the given components and vectors.
/// This macro needs type inference to decide the alignment of the vector.
///
/// # Example
/// ```
/// use ggmath::*;
///
/// fn example<A: VecAlignment>() -> Vector<2, f32, A> {
///     vec2g!(1.0, 2.0)
/// }
/// ```
#[macro_export]
macro_rules! vec2g {
    ($($field:expr),* $(,)?) => {
        $crate::Vector::<2, _, _>::from(($($field,)*))
    }
}

/// Creates a `Vector<3, _, _>` from the given components and vectors.
/// This macro needs type inference to decide the alignment of the vector.
///
/// # Example
/// ```
/// use ggmath::*;
///
/// fn example<A: VecAlignment>() -> Vector<3, f32, A> {
///     vec3g!(1.0, vec2g!(2.0, 3.0))
/// }
/// ```
#[macro_export]
macro_rules! vec3g {
    ($($field:expr),* $(,)?) => {
        $crate::Vector::<3, _, _>::from(($($field,)*))
    }
}

/// Creates a `Vector<4, _, _>` from the given components and vectors.
/// This macro needs type inference to decide the alignment of the vector.
///
/// # Example
/// ```
/// use ggmath::*;
///
/// fn example<A: VecAlignment>() -> Vector<4, f32, A> {
///     vec4g!(1.0, vec2g!(2.0, 3.0), 4.0)
/// }
/// ```
#[macro_export]
macro_rules! vec4g {
    ($($field:expr),* $(,)?) => {
        $crate::Vector::<4, _, _>::from(($($field,)*))
    }
}

impl<T: Scalar, A: VecAlignment, A0: VecAlignment> From<(Vector<2, T, A0>,)> for Vector<2, T, A> {
    fn from(value: (Vector<2, T, A0>,)) -> Self {
        Self::from_array([value.0.x(), value.0.y()])
    }
}

impl<T: Scalar, A: VecAlignment> From<(T, T)> for Vector<2, T, A> {
    fn from(value: (T, T)) -> Self {
        Self::from_array([value.0, value.1])
    }
}

impl<T: Scalar, A: VecAlignment, A0: VecAlignment> From<(Vector<3, T, A0>,)> for Vector<3, T, A> {
    fn from(value: (Vector<3, T, A0>,)) -> Self {
        Self::from_array([value.0.x(), value.0.y(), value.0.z()])
    }
}

impl<T: Scalar, A: VecAlignment, A1: VecAlignment> From<(T, Vector<2, T, A1>)> for Vector<3, T, A> {
    fn from(value: (T, Vector<2, T, A1>)) -> Self {
        Self::from_array([value.0, value.1.x(), value.1.y()])
    }
}

impl<T: Scalar, A: VecAlignment, A0: VecAlignment> From<(Vector<2, T, A0>, T)> for Vector<3, T, A> {
    fn from(value: (Vector<2, T, A0>, T)) -> Self {
        Self::from_array([value.0.x(), value.0.y(), value.1])
    }
}

impl<T: Scalar, A: VecAlignment> From<(T, T, T)> for Vector<3, T, A> {
    fn from(value: (T, T, T)) -> Self {
        Self::from_array([value.0, value.1, value.2])
    }
}

impl<T: Scalar, A: VecAlignment, A0: VecAlignment> From<(Vector<4, T, A0>,)> for Vector<4, T, A> {
    fn from(value: (Vector<4, T, A0>,)) -> Self {
        Self::from_array([value.0.x(), value.0.y(), value.0.z(), value.0.w()])
    }
}

impl<T: Scalar, A: VecAlignment, A1: VecAlignment> From<(T, Vector<3, T, A1>)> for Vector<4, T, A> {
    fn from(value: (T, Vector<3, T, A1>)) -> Self {
        Self::from_array([value.0, value.1.x(), value.1.y(), value.1.z()])
    }
}

impl<T: Scalar, A: VecAlignment, A0: VecAlignment, A1: VecAlignment>
    From<(Vector<2, T, A0>, Vector<2, T, A1>)> for Vector<4, T, A>
{
    fn from(value: (Vector<2, T, A0>, Vector<2, T, A1>)) -> Self {
        Self::from_array([value.0.x(), value.0.y(), value.1.x(), value.1.y()])
    }
}

impl<T: Scalar, A: VecAlignment, A2: VecAlignment> From<(T, T, Vector<2, T, A2>)>
    for Vector<4, T, A>
{
    fn from(value: (T, T, Vector<2, T, A2>)) -> Self {
        Self::from_array([value.0, value.1, value.2.x(), value.2.y()])
    }
}

impl<T: Scalar, A: VecAlignment, A0: VecAlignment> From<(Vector<3, T, A0>, T)> for Vector<4, T, A> {
    fn from(value: (Vector<3, T, A0>, T)) -> Self {
        Self::from_array([value.0.x(), value.0.y(), value.0.z(), value.1])
    }
}

impl<T: Scalar, A: VecAlignment, A1: VecAlignment> From<(T, Vector<2, T, A1>, T)>
    for Vector<4, T, A>
{
    fn from(value: (T, Vector<2, T, A1>, T)) -> Self {
        Self::from_array([value.0, value.1.x(), value.1.y(), value.2])
    }
}

impl<T: Scalar, A: VecAlignment, A0: VecAlignment> From<(Vector<2, T, A0>, T, T)>
    for Vector<4, T, A>
{
    fn from(value: (Vector<2, T, A0>, T, T)) -> Self {
        Self::from_array([value.0.x(), value.0.y(), value.1, value.2])
    }
}

impl<T: Scalar, A: VecAlignment> From<(T, T, T, T)> for Vector<4, T, A> {
    fn from(value: (T, T, T, T)) -> Self {
        Self::from_array([value.0, value.1, value.2, value.3])
    }
}
