// This file was generated by a codegen tool.
// To modify this file, modify the source code of the codegen tool.

use std::ops::*;

use crate::{Construct, Simd, Usize, VecLen, Vector};

/// Trait for [`Vector`] element types.
///
/// This trait is intended for *scalar* types like `f32`, `i32`, or custom number-like types.
/// It is not intended for higher-level mathamatical structures like vectors or matrices.
/// Meaning you cannot do things like `Vec2<Vec2<f32>>`.
///
/// Each [`Scalar`] implementation specifies its own inner [`Simd`] vector types,
/// and how to convert them to and from arrays.
///
/// Additionally, each [`Scalar`] implementation can override the implementation of [`Simd`] vector functions to make optimizations.
///
/// ## Examples
///
/// Non SIMD-accelerated implementation:
/// ```
/// use core::ops::*;
///
/// use ggmath::*;
///
/// #[derive(Clone, Copy)]
/// struct U256([u128; 2]);
///
/// // Because U256 is Add, Vector<_, U256, _> is automatically Add as well.
/// impl Add for U256 {
///     type Output = U256;
///
///     fn add(self, other: U256) -> U256 {
///         todo!()
///     }
/// }
///
///
/// impl Scalar for U256 {
///     type InnerSimdVec2 = [U256; 2];
///     type InnerSimdVec3 = [U256; 3];
///     type InnerSimdVec4 = [U256; 4];
///
///     #[inline(always)]
///     fn vec2_from_array(array: [U256; 2]) -> Vec2<U256> {
///         Vector(array)
///     }
///
///     #[inline(always)]
///     fn vec3_from_array(array: [U256; 3]) -> Vec3<U256> {
///         Vector(array)
///     }
///
///     #[inline(always)]
///     fn vec4_from_array(array: [U256; 4]) -> Vec4<U256> {
///         Vector(array)
///     }
///
///     #[inline(always)]
///     fn vec2_as_array(vec: Vec2<U256>) -> [U256; 2] {
///         vec.0
///     }
///
///     #[inline(always)]
///     fn vec3_as_array(vec: Vec3<U256>) -> [U256; 3] {
///         vec.0
///     }
///
///     #[inline(always)]
///     fn vec4_as_array(vec: Vec4<U256>) -> [U256; 4] {
///         vec.0
///     }
/// }
/// ```
///
/// SIMD-accelerated implementation:
/// ```
/// use core::ops::*;
///
/// use ggmath::*;
///
/// #[repr(transparent)]
/// #[derive(Clone, Copy)]
/// struct CustomInt(i32);
///
/// // Because CustomInt is Add, Vector<_, CustomInt, _> is automatically Add as well.
/// // This time we will override the implementation of vector addition to make SIMD optimizations.
/// impl Add for CustomInt {
///     type Output = CustomInt;
///
///     fn add(self, other: CustomInt) -> CustomInt {
///         CustomInt(self.0 + other.0)
///     }
/// }
///
/// impl Scalar for CustomInt {
///     type InnerSimdVec2 = Vec2<i32>;
///     type InnerSimdVec3 = Vec3<i32>;
///     type InnerSimdVec4 = Vec4<i32>;
///
///     #[inline(always)]
///     fn vec2_from_array(array: [CustomInt; 2]) -> Vec2<CustomInt> {
///         Vector(Vec2::<i32>::from_array(array))
///     }
///
///     #[inline(always)]
///     fn vec3_from_array(array: [CustomInt; 3]) -> Vec3<CustomInt> {
///         Vector(Vec3::<i32>::from_array(array))
///     }
///
///     #[inline(always)]
///     fn vec4_from_array(array: [CustomInt; 4]) -> Vec4<CustomInt> {
///         Vector(Vec4::<i32>::from_array(array))
///     }
///
///     #[inline(always)]
///     fn vec2_as_array(vec: Vec2<CustomInt>) -> [CustomInt; 2] {
///         vec.0.as_array()
///     }
///
///     #[inline(always)]
///     fn vec3_as_array(vec: Vec3<CustomInt>) -> [CustomInt; 3] {
///         vec.0.as_array()
///     }
///
///     #[inline(always)]
///     fn vec4_as_array(vec: Vec4<CustomInt>) -> [CustomInt; 4] {
///         vec.0.as_array()
///     }
///
///     #[inline(always)]
///     fn vec2_add<T2: Scalar>(vec: Vec2<CustomInt>, rhs: Vec2<T2>) -> Vec2<CustomInt::Output>
///     where
///         CustomInt: Add<T2, Output: Scalar>,
///     {
///         specialize! {
///             (vec: Vec2<CustomInt>, rhs: Vec2<T2>) -> Vec2<CustomInt::Output>:
///             
///             for (Vec2<CustomInt>, Vec2<CustomInt>) -> Vec2<CustomInt> {
///                 |vec, rhs| Vector(vec.0 + rhs.0)
///             } else {
///                 Vector::from_fn(|i| vec.index(i).add(rhs.index(i)))
///             }
///         }
///     }
///
///     #[inline(always)]
///     fn vec3_add<T2: Scalar>(vec: Vec3<CustomInt>, rhs: Vec3<T2>) -> Vec3<CustomInt::Output>
///     where
///         CustomInt: Add<T2, Output: Scalar>,
///     {
///         specialize! {
///             (vec: Vec3<CustomInt>, rhs: Vec3<T2>) -> Vec3<CustomInt::Output>:
///             
///             for (Vec3<CustomInt>, Vec3<CustomInt>) -> Vec3<CustomInt> {
///                 |vec, rhs| Vector(vec.0 + rhs.0)
///             } else {
///                 Vector::from_fn(|i| vec.index(i).add(rhs.index(i)))
///             }
///         }
///     }
///
///     #[inline(always)]
///     fn vec4_add<T2: Scalar>(vec: Vec4<CustomInt>, rhs: Vec4<T2>) -> Vec4<CustomInt::Output>
///     where
///         CustomInt: Add<T2, Output: Scalar>,
///     {
///         specialize! {
///             (vec: Vec4<CustomInt>, rhs: Vec4<T2>) -> Vec4<CustomInt::Output>:
///             
///             for (Vec4<CustomInt>, Vec4<CustomInt>) -> Vec4<CustomInt> {
///                 |vec, rhs| Vector(vec.0 + rhs.0)
///             } else {
///                 Vector::from_fn(|i| vec.index(i).add(rhs.index(i)))
///             }
///         }
///     }
/// }
/// ```
pub trait Scalar: Construct {
    /// The inner type contained inside [`Simd`] vectors.
    ///
    /// To choose a seperate type for each length, use [`Usize<N>::Match`][VecLen::Match].
    type SimdVectorStorage<const N: usize>: Construct
    where
        Usize<N>: VecLen;

    /// Converts an array to a [`Simd`] vector.
    fn vec_from_array<const N: usize>(array: [Self; N]) -> Vector<N, Self, Simd>
    where
        Usize<N>: VecLen;

    /// Converts a [`Simd`] vector to an array.
    fn vec_as_array<const N: usize>(vec: Vector<N, Self, Simd>) -> [Self; N]
    where
        Usize<N>: VecLen;

    /// Overridable implementation of [`Simd`] [`Vector::splat`].
    #[inline(always)]
    fn vec_splat<const N: usize>(value: Self) -> Vector<N, Self, Simd>
    where
        Usize<N>: VecLen,
    {
        Vector::from_array([value; N])
    }

    /// Overridable implementation of [`Simd`] [`Vector::get_unchecked`].
    #[inline(always)]
    unsafe fn vec_get_unchecked<const N: usize>(vec: Vector<N, Self, Simd>, index: usize) -> Self
    where
        Usize<N>: VecLen,
    {
        unsafe { *vec.as_array().get_unchecked(index) }
    }

    /// Overridable implementation of [`Simd`] [`Vector::with_unchecked`].
    #[inline(always)]
    unsafe fn vec_with_unchecked<const N: usize>(
        vec: Vector<N, Self, Simd>,
        index: usize,
        value: Self,
    ) -> Vector<N, Self, Simd>
    where
        Usize<N>: VecLen,
    {
        let mut array = vec.as_array();
        unsafe {
            *array.get_unchecked_mut(index) = value;
        }

        Vector::from_array(array)
    }

    /// Overridable implementation of [`Simd`] [`Vector::shuffle_2`].
    #[inline(always)]
    fn vec_shuffle_2<const N: usize, const X_SRC: usize, const Y_SRC: usize>(
        vec: Vector<N, Self, Simd>,
    ) -> Vector<2, Self, Simd>
    where
        Usize<N>: VecLen,
    {
        Vector::<2, Self, Simd>::from_array([vec.index(X_SRC), vec.index(Y_SRC)])
    }

    /// Overridable implementation of [`Simd`] [`Vector::shuffle_3`].
    #[inline(always)]
    fn vec_shuffle_3<const N: usize, const X_SRC: usize, const Y_SRC: usize, const Z_SRC: usize>(
        vec: Vector<N, Self, Simd>,
    ) -> Vector<3, Self, Simd>
    where
        Usize<N>: VecLen,
    {
        Vector::<3, Self, Simd>::from_array([vec.index(X_SRC), vec.index(Y_SRC), vec.index(Z_SRC)])
    }

    /// Overridable implementation of [`Simd`] [`Vector::shuffle_4`].
    #[inline(always)]
    fn vec_shuffle_4<
        const N: usize,
        const X_SRC: usize,
        const Y_SRC: usize,
        const Z_SRC: usize,
        const W_SRC: usize,
    >(
        vec: Vector<N, Self, Simd>,
    ) -> Vector<4, Self, Simd>
    where
        Usize<N>: VecLen,
    {
        Vector::<4, Self, Simd>::from_array([
            vec.index(X_SRC),
            vec.index(Y_SRC),
            vec.index(Z_SRC),
            vec.index(W_SRC),
        ])
    }

    /// Overridable implementation of [`Simd`] [`Vector::with_shuffle_2`].
    #[inline(always)]
    fn vec_with_shuffle_2<const N: usize, const X_DST: usize, const Y_DST: usize>(
        vec: Vector<N, Self, Simd>,
        value: Vector<2, Self, Simd>,
    ) -> Vector<N, Self, Simd>
    where
        Usize<N>: VecLen,
    {
        let mut output = vec;
        output.set(X_DST, value.index(0));
        output.set(Y_DST, value.index(1));

        output
    }

    /// Overridable implementation of [`Simd`] [`Vector::with_shuffle_3`].
    #[inline(always)]
    fn vec_with_shuffle_3<
        const N: usize,
        const X_DST: usize,
        const Y_DST: usize,
        const Z_DST: usize,
    >(
        vec: Vector<N, Self, Simd>,
        value: Vector<3, Self, Simd>,
    ) -> Vector<N, Self, Simd>
    where
        Usize<N>: VecLen,
    {
        let mut output = vec;
        output.set(X_DST, value.index(0));
        output.set(Y_DST, value.index(1));
        output.set(Z_DST, value.index(2));

        output
    }

    /// Overridable implementation of [`Simd`] [`Vector::with_shuffle_4`].
    #[inline(always)]
    fn vec_with_shuffle_4<
        const N: usize,
        const X_DST: usize,
        const Y_DST: usize,
        const Z_DST: usize,
        const W_DST: usize,
    >(
        vec: Vector<N, Self, Simd>,
        value: Vector<4, Self, Simd>,
    ) -> Vector<N, Self, Simd>
    where
        Usize<N>: VecLen,
    {
        let mut output = vec;
        output.set(X_DST, value.index(0));
        output.set(Y_DST, value.index(1));
        output.set(Z_DST, value.index(2));
        output.set(W_DST, value.index(3));

        output
    }

    /// Overridable implementation of [`Simd`] [`Vector::eq`].
    #[inline(always)]
    fn vec_eq<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> bool
    where
        Usize<N>: VecLen,
        Self: PartialEq<T2>,
    {
        (0..N).all(|i| vec.index(i) == other.index(i))
    }

    /// Overridable implementation of [`Simd`] [`Vector::ne`].
    #[inline(always)]
    fn vec_ne<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> bool
    where
        Usize<N>: VecLen,
        Self: PartialEq<T2>,
    {
        (0..N).any(|i| vec.index(i) != other.index(i))
    }

    /// Overridable implementation of [`Simd`] [`Vector::neg`].
    #[inline(always)]
    fn vec_neg<const N: usize>(vec: Vector<N, Self, Simd>) -> Vector<N, <Self as Neg>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: Neg<Output: Scalar>,
    {
        vec.map(|v| v.neg())
    }

    /// Overridable implementation of [`Simd`] [`Vector::not`].
    #[inline(always)]
    fn vec_not<const N: usize>(vec: Vector<N, Self, Simd>) -> Vector<N, <Self as Not>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: Not<Output: Scalar>,
    {
        vec.map(|v| v.not())
    }

    /// Overridable implementation of [`Simd`] [`Vector::add`].
    #[inline(always)]
    fn vec_add<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, <Self as Add<T2>>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: Add<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).add(other.index(i)))
    }

    /// Overridable implementation of [`Simd`] [`Vector::sub`].
    #[inline(always)]
    fn vec_sub<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, <Self as Sub<T2>>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: Sub<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).sub(other.index(i)))
    }

    /// Overridable implementation of [`Simd`] [`Vector::mul`].
    #[inline(always)]
    fn vec_mul<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, <Self as Mul<T2>>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: Mul<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).mul(other.index(i)))
    }

    /// Overridable implementation of [`Simd`] [`Vector::div`].
    #[inline(always)]
    fn vec_div<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, <Self as Div<T2>>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: Div<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).div(other.index(i)))
    }

    /// Overridable implementation of [`Simd`] [`Vector::rem`].
    #[inline(always)]
    fn vec_rem<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, <Self as Rem<T2>>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: Rem<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).rem(other.index(i)))
    }

    /// Overridable implementation of [`Simd`] [`Vector::shl`].
    #[inline(always)]
    fn vec_shl<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, <Self as Shl<T2>>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: Shl<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).shl(other.index(i)))
    }

    /// Overridable implementation of [`Simd`] [`Vector::shr`].
    #[inline(always)]
    fn vec_shr<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, <Self as Shr<T2>>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: Shr<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).shr(other.index(i)))
    }

    /// Overridable implementation of [`Simd`] [`Vector::bitand`].
    #[inline(always)]
    fn vec_bitand<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, <Self as BitAnd<T2>>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: BitAnd<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitand(other.index(i)))
    }

    /// Overridable implementation of [`Simd`] [`Vector::bitor`].
    #[inline(always)]
    fn vec_bitor<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, <Self as BitOr<T2>>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: BitOr<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitor(other.index(i)))
    }

    /// Overridable implementation of [`Simd`] [`Vector::bitxor`].
    #[inline(always)]
    fn vec_bitxor<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, <Self as BitXor<T2>>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: BitXor<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitxor(other.index(i)))
    }

    /// Overridable implementation of [`Simd`] [`Vector::eq_mask`].
    #[inline(always)]
    fn vec_eq_mask<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, bool, Simd>
    where
        Usize<N>: VecLen,
        Self: PartialEq<T2>,
    {
        Vector::from_fn(|i| vec.index(i) == other.index(i))
    }

    /// Overridable implementation of [`Simd`] [`Vector::ne_mask`].
    #[inline(always)]
    fn vec_ne_mask<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, bool, Simd>
    where
        Usize<N>: VecLen,
        Self: PartialEq<T2>,
    {
        Vector::from_fn(|i| vec.index(i) != other.index(i))
    }

    /// Overridable implementation of [`Simd`] [`Vector::lt_mask`].
    #[inline(always)]
    fn vec_lt_mask<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, bool, Simd>
    where
        Usize<N>: VecLen,
        Self: PartialOrd<T2>,
    {
        Vector::from_fn(|i| vec.index(i) < other.index(i))
    }

    /// Overridable implementation of [`Simd`] [`Vector::le_mask`].
    #[inline(always)]
    fn vec_le_mask<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, bool, Simd>
    where
        Usize<N>: VecLen,
        Self: PartialOrd<T2>,
    {
        Vector::from_fn(|i| vec.index(i) <= other.index(i))
    }

    /// Overridable implementation of [`Simd`] [`Vector::gt_mask`].
    #[inline(always)]
    fn vec_gt_mask<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, bool, Simd>
    where
        Usize<N>: VecLen,
        Self: PartialOrd<T2>,
    {
        Vector::from_fn(|i| vec.index(i) > other.index(i))
    }

    /// Overridable implementation of [`Simd`] [`Vector::ge_mask`].
    #[inline(always)]
    fn vec_ge_mask<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, bool, Simd>
    where
        Usize<N>: VecLen,
        Self: PartialOrd<T2>,
    {
        Vector::from_fn(|i| vec.index(i) >= other.index(i))
    }

    /// Overridable implementation of [`Simd`] [`Vector::sum`].
    #[inline(always)]
    fn vec_sum<const N: usize>(vec: Vector<N, Self, Simd>) -> Self
    where
        Usize<N>: VecLen,
        Self: Add<Output = Self>,
    {
        vec.reduce(|a, b| a + b)
    }

    /// Overridable implementation of [`Simd`] [`Vector::product`].
    #[inline(always)]
    fn vec_product<const N: usize>(vec: Vector<N, Self, Simd>) -> Self
    where
        Usize<N>: VecLen,
        Self: Mul<Output = Self>,
    {
        vec.reduce(|a, b| a * b)
    }
}
