// This file was generated by a codegen tool.
// To modify this file, modify the source code of the codegen tool.

use std::ops::*;

use crate::{Construct, Simd, Usize, VecLen, Vector};

/// Trait for [`Vector`] element types.
///
/// To enable SIMD optimizations in a [`Scalar`] implementation,
/// you need to specify [`Simd`] vector representation,
/// and override the implementation of [`Simd`] vector functions to use SIMD operations.
///
/// To implement [`Scalar`] without SIMD optimizations, use the [`default_scalar_boilerplate!`] macro.
///
/// ## Example
///
/// ```
/// use ggmath::*;
///
/// #[derive(Clone, Copy)]
/// struct U256([u128; 2]);
///
/// impl Scalar for U256 {
///     default_scalar_boilerplate! {}
/// }
/// ```
///
/// ## SIMD Example
///
/// ```
/// use core::ops::Add;
///
/// use ggmath::*;
///
/// #[repr(transparent)]
/// #[derive(Clone, Copy)]
/// struct Int(i32);
///
/// // Implement `Add` for `Int` which automatically makes `Vector<N, Int, S>` `Add`.
/// impl Add for Int {
///     type Output = Int;
///
///     fn add(self, other: Int) -> Int {
///         Int(self.0 + other.0)
///     }
/// }
///
/// impl Scalar for Int {
///     // Because `Int` wraps `i32`, we can store `Int` SIMD vectors as high-level `i32` SIMD vectors,
///     // instead of low-level SIMD types like `__m128i`.
///     type SimdVectorStorage<const N: usize> = Vector<N, i32, Simd> where Usize<N>: VecLen;
///
///     #[inline(always)]
///     fn vec_from_array<const N: usize>(array: [Int; N]) -> Vector<N, Int, Simd> {
///         let array = core::mem::transmute_copy::<[Int; N], [i32; N]>(&array);
///         Vector(Vector::from_array(array))
///     }
///
///     #[inline(always)]
///     fn vec_as_array<const N: usize>(vec: Vector<N, Int, Simd>) -> [Int; N] {
///         let array = vec.0.as_array();
///         core::mem::transmute_copy::<[i32; N], [Int; N]>(&array)
///     }
///
///     // Override vector addition to use SIMD operations.
///     #[inline(always)]
///     fn vec_add<const N: usize, T2: Scalar>(vec: Vector<N, Int, Simd>, rhs: Vector<N, T2, Simd>) -> Vector<N, Int::Output, Simd> {
///     where
///         Int: Add<T2, Output: Scalar>,
///     {
///         specialize! {
///             (vec: Vector<N, Int, Simd>, rhs: Vector<N, T2, Simd>) -> Vector<N, Int::Output, Simd>:
///
///             for (Vector<N, Int, Simd>, Vector<N, Int, Simd>) -> Vector<N, Int, Simd> {
///                 |vec, rhs| Vector(vec.0 + rhs.0)
///             } else {
///                 Vector::from_fn(|i| vec.index(i).add(rhs.index(i)))
///             }
///         }
///     }
/// }
/// ```
///
pub trait Scalar: Construct {
    /// The inner type contained inside [`Simd`] vectors.
    ///
    /// To choose a seperate type for each length, use [`Usize<N>::Match`][VecLen::Match].
    type SimdVectorStorage<const N: usize>: Construct
    where
        Usize<N>: VecLen;

    /// Converts an array to a [`Simd`] vector.
    fn vec_from_array<const N: usize>(array: [Self; N]) -> Vector<N, Self, Simd>
    where
        Usize<N>: VecLen;

    /// Converts a [`Simd`] vector to an array.
    fn vec_as_array<const N: usize>(vec: Vector<N, Self, Simd>) -> [Self; N]
    where
        Usize<N>: VecLen;

    /// Overridable implementation of [`Simd`] [`Vector::splat`].
    #[inline(always)]
    fn vec_splat<const N: usize>(value: Self) -> Vector<N, Self, Simd>
    where
        Usize<N>: VecLen,
    {
        Vector::from_array([value; N])
    }

    /// Overridable implementation of [`Simd`] [`Vector::get_unchecked`].
    #[inline(always)]
    unsafe fn vec_get_unchecked<const N: usize>(vec: Vector<N, Self, Simd>, index: usize) -> Self
    where
        Usize<N>: VecLen,
    {
        unsafe { *vec.as_array().get_unchecked(index) }
    }

    /// Overridable implementation of [`Simd`] [`Vector::with_unchecked`].
    #[inline(always)]
    unsafe fn vec_with_unchecked<const N: usize>(
        vec: Vector<N, Self, Simd>,
        index: usize,
        value: Self,
    ) -> Vector<N, Self, Simd>
    where
        Usize<N>: VecLen,
    {
        let mut array = vec.as_array();
        unsafe {
            *array.get_unchecked_mut(index) = value;
        }

        Vector::from_array(array)
    }

    /// Overridable implementation of [`Simd`] [`Vector::shuffle_2`].
    #[inline(always)]
    fn vec_shuffle_2<const N: usize, const X_SRC: usize, const Y_SRC: usize>(
        vec: Vector<N, Self, Simd>,
    ) -> Vector<2, Self, Simd>
    where
        Usize<N>: VecLen,
    {
        Vector::<2, Self, Simd>::from_array([vec.index(X_SRC), vec.index(Y_SRC)])
    }

    /// Overridable implementation of [`Simd`] [`Vector::shuffle_3`].
    #[inline(always)]
    fn vec_shuffle_3<const N: usize, const X_SRC: usize, const Y_SRC: usize, const Z_SRC: usize>(
        vec: Vector<N, Self, Simd>,
    ) -> Vector<3, Self, Simd>
    where
        Usize<N>: VecLen,
    {
        Vector::<3, Self, Simd>::from_array([vec.index(X_SRC), vec.index(Y_SRC), vec.index(Z_SRC)])
    }

    /// Overridable implementation of [`Simd`] [`Vector::shuffle_4`].
    #[inline(always)]
    fn vec_shuffle_4<
        const N: usize,
        const X_SRC: usize,
        const Y_SRC: usize,
        const Z_SRC: usize,
        const W_SRC: usize,
    >(
        vec: Vector<N, Self, Simd>,
    ) -> Vector<4, Self, Simd>
    where
        Usize<N>: VecLen,
    {
        Vector::<4, Self, Simd>::from_array([
            vec.index(X_SRC),
            vec.index(Y_SRC),
            vec.index(Z_SRC),
            vec.index(W_SRC),
        ])
    }

    /// Overridable implementation of [`Simd`] [`Vector::with_shuffle_2`].
    #[inline(always)]
    fn vec_with_shuffle_2<const N: usize, const X_DST: usize, const Y_DST: usize>(
        vec: Vector<N, Self, Simd>,
        value: Vector<2, Self, Simd>,
    ) -> Vector<N, Self, Simd>
    where
        Usize<N>: VecLen,
    {
        let mut output = vec;
        output.set(X_DST, value.index(0));
        output.set(Y_DST, value.index(1));

        output
    }

    /// Overridable implementation of [`Simd`] [`Vector::with_shuffle_3`].
    #[inline(always)]
    fn vec_with_shuffle_3<
        const N: usize,
        const X_DST: usize,
        const Y_DST: usize,
        const Z_DST: usize,
    >(
        vec: Vector<N, Self, Simd>,
        value: Vector<3, Self, Simd>,
    ) -> Vector<N, Self, Simd>
    where
        Usize<N>: VecLen,
    {
        let mut output = vec;
        output.set(X_DST, value.index(0));
        output.set(Y_DST, value.index(1));
        output.set(Z_DST, value.index(2));

        output
    }

    /// Overridable implementation of [`Simd`] [`Vector::with_shuffle_4`].
    #[inline(always)]
    fn vec_with_shuffle_4<
        const N: usize,
        const X_DST: usize,
        const Y_DST: usize,
        const Z_DST: usize,
        const W_DST: usize,
    >(
        vec: Vector<N, Self, Simd>,
        value: Vector<4, Self, Simd>,
    ) -> Vector<N, Self, Simd>
    where
        Usize<N>: VecLen,
    {
        let mut output = vec;
        output.set(X_DST, value.index(0));
        output.set(Y_DST, value.index(1));
        output.set(Z_DST, value.index(2));
        output.set(W_DST, value.index(3));

        output
    }

    /// Overridable implementation of [`Simd`] [`Vector::eq`].
    #[inline(always)]
    fn vec_eq<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> bool
    where
        Usize<N>: VecLen,
        Self: PartialEq<T2>,
    {
        (0..N).all(|i| vec.index(i) == other.index(i))
    }

    /// Overridable implementation of [`Simd`] [`Vector::ne`].
    #[inline(always)]
    fn vec_ne<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> bool
    where
        Usize<N>: VecLen,
        Self: PartialEq<T2>,
    {
        (0..N).any(|i| vec.index(i) != other.index(i))
    }

    /// Overridable implementation of [`Simd`] [`Vector::neg`].
    #[inline(always)]
    fn vec_neg<const N: usize>(vec: Vector<N, Self, Simd>) -> Vector<N, <Self as Neg>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: Neg<Output: Scalar>,
    {
        vec.map(|v| v.neg())
    }

    /// Overridable implementation of [`Simd`] [`Vector::not`].
    #[inline(always)]
    fn vec_not<const N: usize>(vec: Vector<N, Self, Simd>) -> Vector<N, <Self as Not>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: Not<Output: Scalar>,
    {
        vec.map(|v| v.not())
    }

    /// Overridable implementation of [`Simd`] [`Vector::add`].
    #[inline(always)]
    fn vec_add<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, <Self as Add<T2>>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: Add<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).add(other.index(i)))
    }

    /// Overridable implementation of [`Simd`] [`Vector::sub`].
    #[inline(always)]
    fn vec_sub<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, <Self as Sub<T2>>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: Sub<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).sub(other.index(i)))
    }

    /// Overridable implementation of [`Simd`] [`Vector::mul`].
    #[inline(always)]
    fn vec_mul<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, <Self as Mul<T2>>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: Mul<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).mul(other.index(i)))
    }

    /// Overridable implementation of [`Simd`] [`Vector::div`].
    #[inline(always)]
    fn vec_div<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, <Self as Div<T2>>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: Div<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).div(other.index(i)))
    }

    /// Overridable implementation of [`Simd`] [`Vector::rem`].
    #[inline(always)]
    fn vec_rem<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, <Self as Rem<T2>>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: Rem<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).rem(other.index(i)))
    }

    /// Overridable implementation of [`Simd`] [`Vector::shl`].
    #[inline(always)]
    fn vec_shl<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, <Self as Shl<T2>>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: Shl<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).shl(other.index(i)))
    }

    /// Overridable implementation of [`Simd`] [`Vector::shr`].
    #[inline(always)]
    fn vec_shr<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, <Self as Shr<T2>>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: Shr<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).shr(other.index(i)))
    }

    /// Overridable implementation of [`Simd`] [`Vector::bitand`].
    #[inline(always)]
    fn vec_bitand<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, <Self as BitAnd<T2>>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: BitAnd<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitand(other.index(i)))
    }

    /// Overridable implementation of [`Simd`] [`Vector::bitor`].
    #[inline(always)]
    fn vec_bitor<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, <Self as BitOr<T2>>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: BitOr<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitor(other.index(i)))
    }

    /// Overridable implementation of [`Simd`] [`Vector::bitxor`].
    #[inline(always)]
    fn vec_bitxor<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, <Self as BitXor<T2>>::Output, Simd>
    where
        Usize<N>: VecLen,
        Self: BitXor<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitxor(other.index(i)))
    }

    /// Overridable implementation of [`Simd`] [`Vector::eq_mask`].
    #[inline(always)]
    fn vec_eq_mask<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, bool, Simd>
    where
        Usize<N>: VecLen,
        Self: PartialEq<T2>,
    {
        Vector::from_fn(|i| vec.index(i) == other.index(i))
    }

    /// Overridable implementation of [`Simd`] [`Vector::ne_mask`].
    #[inline(always)]
    fn vec_ne_mask<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, bool, Simd>
    where
        Usize<N>: VecLen,
        Self: PartialEq<T2>,
    {
        Vector::from_fn(|i| vec.index(i) != other.index(i))
    }

    /// Overridable implementation of [`Simd`] [`Vector::lt_mask`].
    #[inline(always)]
    fn vec_lt_mask<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, bool, Simd>
    where
        Usize<N>: VecLen,
        Self: PartialOrd<T2>,
    {
        Vector::from_fn(|i| vec.index(i) < other.index(i))
    }

    /// Overridable implementation of [`Simd`] [`Vector::le_mask`].
    #[inline(always)]
    fn vec_le_mask<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, bool, Simd>
    where
        Usize<N>: VecLen,
        Self: PartialOrd<T2>,
    {
        Vector::from_fn(|i| vec.index(i) <= other.index(i))
    }

    /// Overridable implementation of [`Simd`] [`Vector::gt_mask`].
    #[inline(always)]
    fn vec_gt_mask<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, bool, Simd>
    where
        Usize<N>: VecLen,
        Self: PartialOrd<T2>,
    {
        Vector::from_fn(|i| vec.index(i) > other.index(i))
    }

    /// Overridable implementation of [`Simd`] [`Vector::ge_mask`].
    #[inline(always)]
    fn vec_ge_mask<const N: usize, T2: Scalar>(
        vec: Vector<N, Self, Simd>,
        other: Vector<N, T2, Simd>,
    ) -> Vector<N, bool, Simd>
    where
        Usize<N>: VecLen,
        Self: PartialOrd<T2>,
    {
        Vector::from_fn(|i| vec.index(i) >= other.index(i))
    }

    /// Overridable implementation of [`Simd`] [`Vector::sum`].
    #[inline(always)]
    fn vec_sum<const N: usize>(vec: Vector<N, Self, Simd>) -> Self
    where
        Usize<N>: VecLen,
        Self: Add<Output = Self>,
    {
        vec.reduce(|a, b| a + b)
    }

    /// Overridable implementation of [`Simd`] [`Vector::product`].
    #[inline(always)]
    fn vec_product<const N: usize>(vec: Vector<N, Self, Simd>) -> Self
    where
        Usize<N>: VecLen,
        Self: Mul<Output = Self>,
    {
        vec.reduce(|a, b| a * b)
    }
}

/// Macro for generating the boilerplate of default [`Scalar`] implementations.
/// "default" means no SIMD optimizations.
#[macro_export]
macro_rules! default_scalar_boilerplate {
    () => {
        type SimdVectorStorage<const N: usize>
            = [Self; N]
        where
            Usize<N>: VecLen;

        #[inline(always)]
        fn vec_from_array<const N: usize>(array: [Self; N]) -> Vector<N, Self, Simd>
        where
            Usize<N>: VecLen,
        {
            Vector(array)
        }

        #[inline(always)]
        fn vec_as_array<const N: usize>(vec: Vector<N, Self, Simd>) -> [Self; N]
        where
            Usize<N>: VecLen,
        {
            vec.0
        }
    };
}
