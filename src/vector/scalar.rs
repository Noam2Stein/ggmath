// This file was generated by an associated codegen crate.
// To modify this file, modify the source code of the associated codegen crate.

use std::ops::*;

use crate::{Construct, Vec2, Vec3, Vec4, Vector};

/// Trait for types that can be put inside [`Vector`].
/// This is only implemented for actual scalar types (e.g., `f32`),
/// not vectors, matrices, etc.
///
/// When implementing this trait you need to specify the inner types of [`VecAligned`] vectors.
/// You can also override the implementation of vector functions to make optimizations.
///
/// For an example of an optimized `Scalar` implementation,
/// look at the `f32` implementation.
///
/// ## Example
/// ```
/// use ggmath::*;
///
/// #[derive(Clone, Copy)]
/// struct MyInt(i32);
///
/// impl Scalar for MyInt {
///     // If we wanted to SIMD-accelerate this scalar type,
///     // we would use another SIMD type like from `std::arch`, `ggmath`, `glam`, etc.
///     type InnerAlignedVec2 = [MyInt; 2];
///     type InnerAlignedVec3 = [MyInt; 3];
///     type InnerAlignedVec4 = [MyInt; 4];
///
///     #[inline(always)]
///     fn vec2_from_array(array: [MyInt; 2]) -> Vec2<MyInt> {
///         Vector(array)
///     }
///
///     #[inline(always)]
///     fn vec3_from_array(array: [MyInt; 3]) -> Vec3<MyInt> {
///         Vector(array)
///     }
///
///     #[inline(always)]
///     fn vec4_from_array(array: [MyInt; 4]) -> Vec4<MyInt> {
///         Vector(array)
///     }
///
///     #[inline(always)]
///     fn vec2_as_array(vec: Vec2<MyInt>) -> [MyInt; 2] {
///         vec.0
///     }
///
///     #[inline(always)]
///     fn vec3_as_array(vec: Vec3<MyInt>) -> [MyInt; 3] {
///         vec.0
///     }
///
///     #[inline(always)]
///     fn vec4_as_array(vec: Vec4<MyInt>) -> [MyInt; 4] {
///         vec.0
///     }
/// }
/// ```
pub trait Scalar: Construct {
    /// The inner type contained inside `Vector<2, Self, VecAligned>`.
    type InnerAlignedVec2: Construct;

    /// The inner type contained inside `Vector<3, Self, VecAligned>`.
    type InnerAlignedVec3: Construct;

    /// The inner type contained inside `Vector<4, Self, VecAligned>`.
    type InnerAlignedVec4: Construct;

    /// Constructs an aligned vec2 from an array.
    fn vec2_from_array(array: [Self; 2]) -> Vec2<Self>;

    /// Converts an aligned vec2 to an array.
    fn vec2_as_array(vec: Vec2<Self>) -> [Self; 2];

    /// Constructs an aligned vec3 from an array.
    fn vec3_from_array(array: [Self; 3]) -> Vec3<Self>;

    /// Converts an aligned vec3 to an array.
    fn vec3_as_array(vec: Vec3<Self>) -> [Self; 3];

    /// Constructs an aligned vec4 from an array.
    fn vec4_from_array(array: [Self; 4]) -> Vec4<Self>;

    /// Converts an aligned vec4 to an array.
    fn vec4_as_array(vec: Vec4<Self>) -> [Self; 4];

    /// Overridable implementation of `Vector::splat` for aligned vec2s.
    #[inline(always)]
    fn vec2_splat(value: Self) -> Vec2<Self> {
        Vec2::from_array([value; 2])
    }

    /// Overridable implementation of `Vector::get_unchecked` for aligned vec2s.
    #[inline(always)]
    unsafe fn vec2_get_unchecked(vec: Vec2<Self>, index: usize) -> Self {
        unsafe { *vec.as_array().get_unchecked(index) }
    }

    /// Overridable implementation of `Vector::set_unchecked` for aligned vec2s.
    #[inline(always)]
    unsafe fn vec2_with_unchecked(vec: Vec2<Self>, index: usize, value: Self) -> Vec2<Self> {
        let mut array = vec.as_array();
        unsafe {
            *array.get_unchecked_mut(index) = value;
        }

        Vec2::from_array(array)
    }

    /// Overridable implementation of `Vector::shuffle_2` for aligned vec2s.
    #[inline(always)]
    fn vec2_shuffle_2<const X_SRC: usize, const Y_SRC: usize>(vec: Vec2<Self>) -> Vec2<Self> {
        Vec2::from_array([vec.index(X_SRC), vec.index(Y_SRC)])
    }

    /// Overridable implementation of `Vector::shuffle_3` for aligned vec2s.
    #[inline(always)]
    fn vec2_shuffle_3<const X_SRC: usize, const Y_SRC: usize, const Z_SRC: usize>(
        vec: Vec2<Self>,
    ) -> Vec3<Self> {
        Vec3::from_array([vec.index(X_SRC), vec.index(Y_SRC), vec.index(Z_SRC)])
    }

    /// Overridable implementation of `Vector::shuffle_4` for aligned vec2s.
    #[inline(always)]
    fn vec2_shuffle_4<
        const X_SRC: usize,
        const Y_SRC: usize,
        const Z_SRC: usize,
        const W_SRC: usize,
    >(
        vec: Vec2<Self>,
    ) -> Vec4<Self> {
        Vec4::from_array([
            vec.index(X_SRC),
            vec.index(Y_SRC),
            vec.index(Z_SRC),
            vec.index(W_SRC),
        ])
    }

    /// Overridable implementation of `Vector::with_2` for aligned vec2s.
    #[inline(always)]
    fn vec2_with_shuffle_2<const X_DST: usize, const Y_DST: usize>(
        vec: Vec2<Self>,
        value: Vec2<Self>,
    ) -> Vec2<Self> {
        let mut output = vec;
        output.set(X_DST, value.index(0));
        output.set(Y_DST, value.index(1));

        output
    }

    /// Overridable implementation of `Vector::eq` for aligned vec2s.
    #[inline(always)]
    fn vec2_eq<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> bool
    where
        Self: PartialEq<T2>,
    {
        (0..2).all(|i| vec.index(i) == other.index(i))
    }

    /// Overridable implementation of `Vector::ne` for aligned vec2s.
    #[inline(always)]
    fn vec2_ne<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> bool
    where
        Self: PartialEq<T2>,
    {
        (0..2).any(|i| vec.index(i) != other.index(i))
    }

    /// Overridable implementation of `Vector::neg` for aligned vec2s.
    #[inline(always)]
    fn vec2_neg(vec: Vec2<Self>) -> Vec2<<Self as Neg>::Output>
    where
        Self: Neg<Output: Scalar>,
    {
        vec.map(|v| v.neg())
    }

    /// Overridable implementation of `Vector::not` for aligned vec2s.
    #[inline(always)]
    fn vec2_not(vec: Vec2<Self>) -> Vec2<<Self as Not>::Output>
    where
        Self: Not<Output: Scalar>,
    {
        vec.map(|v| v.not())
    }

    /// Overridable implementation of `Vector::add` for aligned vec2s.
    #[inline(always)]
    fn vec2_add<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> Vec2<<Self as Add<T2>>::Output>
    where
        Self: Add<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).add(other.index(i)))
    }

    /// Overridable implementation of `Vector::sub` for aligned vec2s.
    #[inline(always)]
    fn vec2_sub<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> Vec2<<Self as Sub<T2>>::Output>
    where
        Self: Sub<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).sub(other.index(i)))
    }

    /// Overridable implementation of `Vector::mul` for aligned vec2s.
    #[inline(always)]
    fn vec2_mul<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> Vec2<<Self as Mul<T2>>::Output>
    where
        Self: Mul<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).mul(other.index(i)))
    }

    /// Overridable implementation of `Vector::div` for aligned vec2s.
    #[inline(always)]
    fn vec2_div<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> Vec2<<Self as Div<T2>>::Output>
    where
        Self: Div<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).div(other.index(i)))
    }

    /// Overridable implementation of `Vector::rem` for aligned vec2s.
    #[inline(always)]
    fn vec2_rem<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> Vec2<<Self as Rem<T2>>::Output>
    where
        Self: Rem<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).rem(other.index(i)))
    }

    /// Overridable implementation of `Vector::shl` for aligned vec2s.
    #[inline(always)]
    fn vec2_shl<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> Vec2<<Self as Shl<T2>>::Output>
    where
        Self: Shl<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).shl(other.index(i)))
    }

    /// Overridable implementation of `Vector::shr` for aligned vec2s.
    #[inline(always)]
    fn vec2_shr<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> Vec2<<Self as Shr<T2>>::Output>
    where
        Self: Shr<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).shr(other.index(i)))
    }

    /// Overridable implementation of `Vector::bitand` for aligned vec2s.
    #[inline(always)]
    fn vec2_bitand<T2: Scalar>(
        vec: Vec2<Self>,
        other: Vec2<T2>,
    ) -> Vec2<<Self as BitAnd<T2>>::Output>
    where
        Self: BitAnd<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitand(other.index(i)))
    }

    /// Overridable implementation of `Vector::bitor` for aligned vec2s.
    #[inline(always)]
    fn vec2_bitor<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> Vec2<<Self as BitOr<T2>>::Output>
    where
        Self: BitOr<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitor(other.index(i)))
    }

    /// Overridable implementation of `Vector::bitxor` for aligned vec2s.
    #[inline(always)]
    fn vec2_bitxor<T2: Scalar>(
        vec: Vec2<Self>,
        other: Vec2<T2>,
    ) -> Vec2<<Self as BitXor<T2>>::Output>
    where
        Self: BitXor<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitxor(other.index(i)))
    }

    /// Overridable implementation of `Vector::eq_mask` for aligned vec2s.
    #[inline(always)]
    fn vec2_eq_mask<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> Vec2<bool>
    where
        Self: PartialEq<T2>,
    {
        Vector::from_fn(|i| vec.index(i) == other.index(i))
    }

    /// Overridable implementation of `Vector::ne_mask` for aligned vec2s.
    #[inline(always)]
    fn vec2_ne_mask<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> Vec2<bool>
    where
        Self: PartialEq<T2>,
    {
        Vector::from_fn(|i| vec.index(i) != other.index(i))
    }

    /// Overridable implementation of `Vector::lt_mask` for aligned vec2s.
    #[inline(always)]
    fn vec2_lt_mask<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> Vec2<bool>
    where
        Self: PartialOrd<T2>,
    {
        Vector::from_fn(|i| vec.index(i) < other.index(i))
    }

    /// Overridable implementation of `Vector::le_mask` for aligned vec2s.
    #[inline(always)]
    fn vec2_le_mask<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> Vec2<bool>
    where
        Self: PartialOrd<T2>,
    {
        Vector::from_fn(|i| vec.index(i) <= other.index(i))
    }

    /// Overridable implementation of `Vector::gt_mask` for aligned vec2s.
    #[inline(always)]
    fn vec2_gt_mask<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> Vec2<bool>
    where
        Self: PartialOrd<T2>,
    {
        Vector::from_fn(|i| vec.index(i) > other.index(i))
    }

    /// Overridable implementation of `Vector::ge_mask` for aligned vec2s.
    #[inline(always)]
    fn vec2_ge_mask<T2: Scalar>(vec: Vec2<Self>, other: Vec2<T2>) -> Vec2<bool>
    where
        Self: PartialOrd<T2>,
    {
        Vector::from_fn(|i| vec.index(i) >= other.index(i))
    }

    /// Overridable implementation of `Vector::sum` for aligned vec2s.
    #[inline(always)]
    fn vec2_sum(vec: Vec2<Self>) -> Self
    where
        Self: Add<Output = Self>,
    {
        vec.reduce(|a, b| a + b)
    }

    /// Overridable implementation of `Vector::product` for aligned vec2s.
    #[inline(always)]
    fn vec2_product(vec: Vec2<Self>) -> Self
    where
        Self: Mul<Output = Self>,
    {
        vec.reduce(|a, b| a * b)
    }

    /// Overridable implementation of `Vector::splat` for aligned vec3s.
    #[inline(always)]
    fn vec3_splat(value: Self) -> Vec3<Self> {
        Vec3::from_array([value; 3])
    }

    /// Overridable implementation of `Vector::get_unchecked` for aligned vec3s.
    #[inline(always)]
    unsafe fn vec3_get_unchecked(vec: Vec3<Self>, index: usize) -> Self {
        unsafe { *vec.as_array().get_unchecked(index) }
    }

    /// Overridable implementation of `Vector::set_unchecked` for aligned vec3s.
    #[inline(always)]
    unsafe fn vec3_with_unchecked(vec: Vec3<Self>, index: usize, value: Self) -> Vec3<Self> {
        let mut array = vec.as_array();
        unsafe {
            *array.get_unchecked_mut(index) = value;
        }

        Vec3::from_array(array)
    }

    /// Overridable implementation of `Vector::shuffle_2` for aligned vec3s.
    #[inline(always)]
    fn vec3_shuffle_2<const X_SRC: usize, const Y_SRC: usize>(vec: Vec3<Self>) -> Vec2<Self> {
        Vec2::from_array([vec.index(X_SRC), vec.index(Y_SRC)])
    }

    /// Overridable implementation of `Vector::shuffle_3` for aligned vec3s.
    #[inline(always)]
    fn vec3_shuffle_3<const X_SRC: usize, const Y_SRC: usize, const Z_SRC: usize>(
        vec: Vec3<Self>,
    ) -> Vec3<Self> {
        Vec3::from_array([vec.index(X_SRC), vec.index(Y_SRC), vec.index(Z_SRC)])
    }

    /// Overridable implementation of `Vector::shuffle_4` for aligned vec3s.
    #[inline(always)]
    fn vec3_shuffle_4<
        const X_SRC: usize,
        const Y_SRC: usize,
        const Z_SRC: usize,
        const W_SRC: usize,
    >(
        vec: Vec3<Self>,
    ) -> Vec4<Self> {
        Vec4::from_array([
            vec.index(X_SRC),
            vec.index(Y_SRC),
            vec.index(Z_SRC),
            vec.index(W_SRC),
        ])
    }

    /// Overridable implementation of `Vector::with_2` for aligned vec3s.
    #[inline(always)]
    fn vec3_with_shuffle_2<const X_DST: usize, const Y_DST: usize>(
        vec: Vec3<Self>,
        value: Vec2<Self>,
    ) -> Vec3<Self> {
        let mut output = vec;
        output.set(X_DST, value.index(0));
        output.set(Y_DST, value.index(1));

        output
    }

    /// Overridable implementation of `Vector::with_3` for aligned vec3s.
    #[inline(always)]
    fn vec3_with_shuffle_3<const X_DST: usize, const Y_DST: usize, const Z_DST: usize>(
        vec: Vec3<Self>,
        value: Vec3<Self>,
    ) -> Vec3<Self> {
        let mut output = vec;
        output.set(X_DST, value.index(0));
        output.set(Y_DST, value.index(1));
        output.set(Z_DST, value.index(2));

        output
    }

    /// Overridable implementation of `Vector::eq` for aligned vec3s.
    #[inline(always)]
    fn vec3_eq<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> bool
    where
        Self: PartialEq<T2>,
    {
        (0..3).all(|i| vec.index(i) == other.index(i))
    }

    /// Overridable implementation of `Vector::ne` for aligned vec3s.
    #[inline(always)]
    fn vec3_ne<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> bool
    where
        Self: PartialEq<T2>,
    {
        (0..3).any(|i| vec.index(i) != other.index(i))
    }

    /// Overridable implementation of `Vector::neg` for aligned vec3s.
    #[inline(always)]
    fn vec3_neg(vec: Vec3<Self>) -> Vec3<<Self as Neg>::Output>
    where
        Self: Neg<Output: Scalar>,
    {
        vec.map(|v| v.neg())
    }

    /// Overridable implementation of `Vector::not` for aligned vec3s.
    #[inline(always)]
    fn vec3_not(vec: Vec3<Self>) -> Vec3<<Self as Not>::Output>
    where
        Self: Not<Output: Scalar>,
    {
        vec.map(|v| v.not())
    }

    /// Overridable implementation of `Vector::add` for aligned vec3s.
    #[inline(always)]
    fn vec3_add<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> Vec3<<Self as Add<T2>>::Output>
    where
        Self: Add<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).add(other.index(i)))
    }

    /// Overridable implementation of `Vector::sub` for aligned vec3s.
    #[inline(always)]
    fn vec3_sub<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> Vec3<<Self as Sub<T2>>::Output>
    where
        Self: Sub<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).sub(other.index(i)))
    }

    /// Overridable implementation of `Vector::mul` for aligned vec3s.
    #[inline(always)]
    fn vec3_mul<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> Vec3<<Self as Mul<T2>>::Output>
    where
        Self: Mul<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).mul(other.index(i)))
    }

    /// Overridable implementation of `Vector::div` for aligned vec3s.
    #[inline(always)]
    fn vec3_div<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> Vec3<<Self as Div<T2>>::Output>
    where
        Self: Div<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).div(other.index(i)))
    }

    /// Overridable implementation of `Vector::rem` for aligned vec3s.
    #[inline(always)]
    fn vec3_rem<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> Vec3<<Self as Rem<T2>>::Output>
    where
        Self: Rem<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).rem(other.index(i)))
    }

    /// Overridable implementation of `Vector::shl` for aligned vec3s.
    #[inline(always)]
    fn vec3_shl<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> Vec3<<Self as Shl<T2>>::Output>
    where
        Self: Shl<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).shl(other.index(i)))
    }

    /// Overridable implementation of `Vector::shr` for aligned vec3s.
    #[inline(always)]
    fn vec3_shr<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> Vec3<<Self as Shr<T2>>::Output>
    where
        Self: Shr<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).shr(other.index(i)))
    }

    /// Overridable implementation of `Vector::bitand` for aligned vec3s.
    #[inline(always)]
    fn vec3_bitand<T2: Scalar>(
        vec: Vec3<Self>,
        other: Vec3<T2>,
    ) -> Vec3<<Self as BitAnd<T2>>::Output>
    where
        Self: BitAnd<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitand(other.index(i)))
    }

    /// Overridable implementation of `Vector::bitor` for aligned vec3s.
    #[inline(always)]
    fn vec3_bitor<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> Vec3<<Self as BitOr<T2>>::Output>
    where
        Self: BitOr<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitor(other.index(i)))
    }

    /// Overridable implementation of `Vector::bitxor` for aligned vec3s.
    #[inline(always)]
    fn vec3_bitxor<T2: Scalar>(
        vec: Vec3<Self>,
        other: Vec3<T2>,
    ) -> Vec3<<Self as BitXor<T2>>::Output>
    where
        Self: BitXor<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitxor(other.index(i)))
    }

    /// Overridable implementation of `Vector::eq_mask` for aligned vec3s.
    #[inline(always)]
    fn vec3_eq_mask<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> Vec3<bool>
    where
        Self: PartialEq<T2>,
    {
        Vector::from_fn(|i| vec.index(i) == other.index(i))
    }

    /// Overridable implementation of `Vector::ne_mask` for aligned vec3s.
    #[inline(always)]
    fn vec3_ne_mask<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> Vec3<bool>
    where
        Self: PartialEq<T2>,
    {
        Vector::from_fn(|i| vec.index(i) != other.index(i))
    }

    /// Overridable implementation of `Vector::lt_mask` for aligned vec3s.
    #[inline(always)]
    fn vec3_lt_mask<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> Vec3<bool>
    where
        Self: PartialOrd<T2>,
    {
        Vector::from_fn(|i| vec.index(i) < other.index(i))
    }

    /// Overridable implementation of `Vector::le_mask` for aligned vec3s.
    #[inline(always)]
    fn vec3_le_mask<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> Vec3<bool>
    where
        Self: PartialOrd<T2>,
    {
        Vector::from_fn(|i| vec.index(i) <= other.index(i))
    }

    /// Overridable implementation of `Vector::gt_mask` for aligned vec3s.
    #[inline(always)]
    fn vec3_gt_mask<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> Vec3<bool>
    where
        Self: PartialOrd<T2>,
    {
        Vector::from_fn(|i| vec.index(i) > other.index(i))
    }

    /// Overridable implementation of `Vector::ge_mask` for aligned vec3s.
    #[inline(always)]
    fn vec3_ge_mask<T2: Scalar>(vec: Vec3<Self>, other: Vec3<T2>) -> Vec3<bool>
    where
        Self: PartialOrd<T2>,
    {
        Vector::from_fn(|i| vec.index(i) >= other.index(i))
    }

    /// Overridable implementation of `Vector::sum` for aligned vec3s.
    #[inline(always)]
    fn vec3_sum(vec: Vec3<Self>) -> Self
    where
        Self: Add<Output = Self>,
    {
        vec.reduce(|a, b| a + b)
    }

    /// Overridable implementation of `Vector::product` for aligned vec3s.
    #[inline(always)]
    fn vec3_product(vec: Vec3<Self>) -> Self
    where
        Self: Mul<Output = Self>,
    {
        vec.reduce(|a, b| a * b)
    }

    /// Overridable implementation of `Vector::splat` for aligned vec4s.
    #[inline(always)]
    fn vec4_splat(value: Self) -> Vec4<Self> {
        Vec4::from_array([value; 4])
    }

    /// Overridable implementation of `Vector::get_unchecked` for aligned vec4s.
    #[inline(always)]
    unsafe fn vec4_get_unchecked(vec: Vec4<Self>, index: usize) -> Self {
        unsafe { *vec.as_array().get_unchecked(index) }
    }

    /// Overridable implementation of `Vector::set_unchecked` for aligned vec4s.
    #[inline(always)]
    unsafe fn vec4_with_unchecked(vec: Vec4<Self>, index: usize, value: Self) -> Vec4<Self> {
        let mut array = vec.as_array();
        unsafe {
            *array.get_unchecked_mut(index) = value;
        }

        Vec4::from_array(array)
    }

    /// Overridable implementation of `Vector::shuffle_2` for aligned vec4s.
    #[inline(always)]
    fn vec4_shuffle_2<const X_SRC: usize, const Y_SRC: usize>(vec: Vec4<Self>) -> Vec2<Self> {
        Vec2::from_array([vec.index(X_SRC), vec.index(Y_SRC)])
    }

    /// Overridable implementation of `Vector::shuffle_3` for aligned vec4s.
    #[inline(always)]
    fn vec4_shuffle_3<const X_SRC: usize, const Y_SRC: usize, const Z_SRC: usize>(
        vec: Vec4<Self>,
    ) -> Vec3<Self> {
        Vec3::from_array([vec.index(X_SRC), vec.index(Y_SRC), vec.index(Z_SRC)])
    }

    /// Overridable implementation of `Vector::shuffle_4` for aligned vec4s.
    #[inline(always)]
    fn vec4_shuffle_4<
        const X_SRC: usize,
        const Y_SRC: usize,
        const Z_SRC: usize,
        const W_SRC: usize,
    >(
        vec: Vec4<Self>,
    ) -> Vec4<Self> {
        Vec4::from_array([
            vec.index(X_SRC),
            vec.index(Y_SRC),
            vec.index(Z_SRC),
            vec.index(W_SRC),
        ])
    }

    /// Overridable implementation of `Vector::with_2` for aligned vec4s.
    #[inline(always)]
    fn vec4_with_shuffle_2<const X_DST: usize, const Y_DST: usize>(
        vec: Vec4<Self>,
        value: Vec2<Self>,
    ) -> Vec4<Self> {
        let mut output = vec;
        output.set(X_DST, value.index(0));
        output.set(Y_DST, value.index(1));

        output
    }

    /// Overridable implementation of `Vector::with_3` for aligned vec4s.
    #[inline(always)]
    fn vec4_with_shuffle_3<const X_DST: usize, const Y_DST: usize, const Z_DST: usize>(
        vec: Vec4<Self>,
        value: Vec3<Self>,
    ) -> Vec4<Self> {
        let mut output = vec;
        output.set(X_DST, value.index(0));
        output.set(Y_DST, value.index(1));
        output.set(Z_DST, value.index(2));

        output
    }

    /// Overridable implementation of `Vector::with_4` for aligned vec4s.
    #[inline(always)]
    fn vec4_with_shuffle_4<
        const X_DST: usize,
        const Y_DST: usize,
        const Z_DST: usize,
        const W_DST: usize,
    >(
        vec: Vec4<Self>,
        value: Vec4<Self>,
    ) -> Vec4<Self> {
        let mut output = vec;
        output.set(X_DST, value.index(0));
        output.set(Y_DST, value.index(1));
        output.set(Z_DST, value.index(2));
        output.set(W_DST, value.index(3));

        output
    }

    /// Overridable implementation of `Vector::eq` for aligned vec4s.
    #[inline(always)]
    fn vec4_eq<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> bool
    where
        Self: PartialEq<T2>,
    {
        (0..4).all(|i| vec.index(i) == other.index(i))
    }

    /// Overridable implementation of `Vector::ne` for aligned vec4s.
    #[inline(always)]
    fn vec4_ne<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> bool
    where
        Self: PartialEq<T2>,
    {
        (0..4).any(|i| vec.index(i) != other.index(i))
    }

    /// Overridable implementation of `Vector::neg` for aligned vec4s.
    #[inline(always)]
    fn vec4_neg(vec: Vec4<Self>) -> Vec4<<Self as Neg>::Output>
    where
        Self: Neg<Output: Scalar>,
    {
        vec.map(|v| v.neg())
    }

    /// Overridable implementation of `Vector::not` for aligned vec4s.
    #[inline(always)]
    fn vec4_not(vec: Vec4<Self>) -> Vec4<<Self as Not>::Output>
    where
        Self: Not<Output: Scalar>,
    {
        vec.map(|v| v.not())
    }

    /// Overridable implementation of `Vector::add` for aligned vec4s.
    #[inline(always)]
    fn vec4_add<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> Vec4<<Self as Add<T2>>::Output>
    where
        Self: Add<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).add(other.index(i)))
    }

    /// Overridable implementation of `Vector::sub` for aligned vec4s.
    #[inline(always)]
    fn vec4_sub<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> Vec4<<Self as Sub<T2>>::Output>
    where
        Self: Sub<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).sub(other.index(i)))
    }

    /// Overridable implementation of `Vector::mul` for aligned vec4s.
    #[inline(always)]
    fn vec4_mul<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> Vec4<<Self as Mul<T2>>::Output>
    where
        Self: Mul<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).mul(other.index(i)))
    }

    /// Overridable implementation of `Vector::div` for aligned vec4s.
    #[inline(always)]
    fn vec4_div<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> Vec4<<Self as Div<T2>>::Output>
    where
        Self: Div<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).div(other.index(i)))
    }

    /// Overridable implementation of `Vector::rem` for aligned vec4s.
    #[inline(always)]
    fn vec4_rem<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> Vec4<<Self as Rem<T2>>::Output>
    where
        Self: Rem<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).rem(other.index(i)))
    }

    /// Overridable implementation of `Vector::shl` for aligned vec4s.
    #[inline(always)]
    fn vec4_shl<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> Vec4<<Self as Shl<T2>>::Output>
    where
        Self: Shl<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).shl(other.index(i)))
    }

    /// Overridable implementation of `Vector::shr` for aligned vec4s.
    #[inline(always)]
    fn vec4_shr<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> Vec4<<Self as Shr<T2>>::Output>
    where
        Self: Shr<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).shr(other.index(i)))
    }

    /// Overridable implementation of `Vector::bitand` for aligned vec4s.
    #[inline(always)]
    fn vec4_bitand<T2: Scalar>(
        vec: Vec4<Self>,
        other: Vec4<T2>,
    ) -> Vec4<<Self as BitAnd<T2>>::Output>
    where
        Self: BitAnd<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitand(other.index(i)))
    }

    /// Overridable implementation of `Vector::bitor` for aligned vec4s.
    #[inline(always)]
    fn vec4_bitor<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> Vec4<<Self as BitOr<T2>>::Output>
    where
        Self: BitOr<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitor(other.index(i)))
    }

    /// Overridable implementation of `Vector::bitxor` for aligned vec4s.
    #[inline(always)]
    fn vec4_bitxor<T2: Scalar>(
        vec: Vec4<Self>,
        other: Vec4<T2>,
    ) -> Vec4<<Self as BitXor<T2>>::Output>
    where
        Self: BitXor<T2, Output: Scalar>,
    {
        Vector::from_fn(|i| vec.index(i).bitxor(other.index(i)))
    }

    /// Overridable implementation of `Vector::eq_mask` for aligned vec4s.
    #[inline(always)]
    fn vec4_eq_mask<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> Vec4<bool>
    where
        Self: PartialEq<T2>,
    {
        Vector::from_fn(|i| vec.index(i) == other.index(i))
    }

    /// Overridable implementation of `Vector::ne_mask` for aligned vec4s.
    #[inline(always)]
    fn vec4_ne_mask<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> Vec4<bool>
    where
        Self: PartialEq<T2>,
    {
        Vector::from_fn(|i| vec.index(i) != other.index(i))
    }

    /// Overridable implementation of `Vector::lt_mask` for aligned vec4s.
    #[inline(always)]
    fn vec4_lt_mask<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> Vec4<bool>
    where
        Self: PartialOrd<T2>,
    {
        Vector::from_fn(|i| vec.index(i) < other.index(i))
    }

    /// Overridable implementation of `Vector::le_mask` for aligned vec4s.
    #[inline(always)]
    fn vec4_le_mask<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> Vec4<bool>
    where
        Self: PartialOrd<T2>,
    {
        Vector::from_fn(|i| vec.index(i) <= other.index(i))
    }

    /// Overridable implementation of `Vector::gt_mask` for aligned vec4s.
    #[inline(always)]
    fn vec4_gt_mask<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> Vec4<bool>
    where
        Self: PartialOrd<T2>,
    {
        Vector::from_fn(|i| vec.index(i) > other.index(i))
    }

    /// Overridable implementation of `Vector::ge_mask` for aligned vec4s.
    #[inline(always)]
    fn vec4_ge_mask<T2: Scalar>(vec: Vec4<Self>, other: Vec4<T2>) -> Vec4<bool>
    where
        Self: PartialOrd<T2>,
    {
        Vector::from_fn(|i| vec.index(i) >= other.index(i))
    }

    /// Overridable implementation of `Vector::sum` for aligned vec4s.
    #[inline(always)]
    fn vec4_sum(vec: Vec4<Self>) -> Self
    where
        Self: Add<Output = Self>,
    {
        vec.reduce(|a, b| a + b)
    }

    /// Overridable implementation of `Vector::product` for aligned vec4s.
    #[inline(always)]
    fn vec4_product(vec: Vec4<Self>) -> Self
    where
        Self: Mul<Output = Self>,
    {
        vec.reduce(|a, b| a * b)
    }
}
