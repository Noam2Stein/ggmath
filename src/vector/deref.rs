// This file was automatically generated by ggmath's codegen tool.
// Do not modify this file directly!

use std::{
    mem::transmute,
    ops::{Deref, DerefMut},
};

use crate::{Construct, ElementOfVector, Simdness, Vector};

#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct Vec2Elements<T: Construct> {
    /// The 1st element of the vector.
    pub x: T,
    /// The 2nd element of the vector.
    pub y: T,
}

#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct Vec3Elements<T: Construct> {
    /// The 1st element of the vector.
    pub x: T,
    /// The 2nd element of the vector.
    pub y: T,
    /// The 3rd element of the vector.
    pub z: T,
}

#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct Vec4Elements<T: Construct> {
    /// The 1st element of the vector.
    pub x: T,
    /// The 2nd element of the vector.
    pub y: T,
    /// The 3rd element of the vector.
    pub z: T,
    /// The 4th element of the vector.
    pub w: T,
}

impl<T: ElementOfVector<2, S>, S: Simdness> Deref for Vector<2, T, S> {
    type Target = Vec2Elements<T>;

    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        // SAFETY: Vector<2, T, S> is guaranteed to begin with 2 consecutive T elements
        unsafe { transmute::<&Vector<2, T, S>, &Vec2Elements<T>>(self) }
    }
}

impl<T: ElementOfVector<3, S>, S: Simdness> Deref for Vector<3, T, S> {
    type Target = Vec3Elements<T>;

    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        // SAFETY: Vector<3, T, S> is guaranteed to begin with 3 consecutive T elements
        unsafe { transmute::<&Vector<3, T, S>, &Vec3Elements<T>>(self) }
    }
}

impl<T: ElementOfVector<4, S>, S: Simdness> Deref for Vector<4, T, S> {
    type Target = Vec4Elements<T>;

    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        // SAFETY: Vector<4, T, S> is guaranteed to begin with 4 consecutive T elements
        unsafe { transmute::<&Vector<4, T, S>, &Vec4Elements<T>>(self) }
    }
}

impl<T: ElementOfVector<2, S>, S: Simdness> DerefMut for Vector<2, T, S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        // SAFETY: Vector<2, T, S> is guaranteed to begin with 2 consecutive T elements
        unsafe { transmute::<&mut Vector<2, T, S>, &mut Vec2Elements<T>>(self) }
    }
}

impl<T: ElementOfVector<3, S>, S: Simdness> DerefMut for Vector<3, T, S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        // SAFETY: Vector<3, T, S> is guaranteed to begin with 3 consecutive T elements
        unsafe { transmute::<&mut Vector<3, T, S>, &mut Vec3Elements<T>>(self) }
    }
}

impl<T: ElementOfVector<4, S>, S: Simdness> DerefMut for Vector<4, T, S> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        // SAFETY: Vector<4, T, S> is guaranteed to begin with 4 consecutive T elements
        unsafe { transmute::<&mut Vector<4, T, S>, &mut Vec4Elements<T>>(self) }
    }
}
