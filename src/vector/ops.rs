// This file was automatically generated by ggmath's codegen tool.
// Do not modify this file directly!

use std::ops::{
    Add, AddAssign, BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Div, DivAssign,
    Mul, MulAssign, Neg, Not, Rem, RemAssign, Shl, ShlAssign, Shr, ShrAssign, Sub, SubAssign,
};

use crate::{ElementOfVector, Simdness, Vector};

impl<const N: usize, T: Neg<Output = T> + ElementOfVector<N, S>, S: Simdness> Neg
    for Vector<N, T, S>
{
    type Output = Self;

    #[inline(always)]
    fn neg(self) -> Self::Output {
        T::vec_neg(self)
    }
}

impl<const N: usize, T: Not<Output = T> + ElementOfVector<N, S>, S: Simdness> Not
    for Vector<N, T, S>
{
    type Output = Self;

    #[inline(always)]
    fn not(self) -> Self::Output {
        T::vec_not(self)
    }
}

impl<const N: usize, T: Add<Output = T> + ElementOfVector<N, S>, S: Simdness> Add
    for Vector<N, T, S>
{
    type Output = Self;

    #[inline(always)]
    fn add(self, rhs: Self) -> Self::Output {
        T::vec_add(self, rhs)
    }
}

impl<const N: usize, T: Sub<Output = T> + ElementOfVector<N, S>, S: Simdness> Sub
    for Vector<N, T, S>
{
    type Output = Self;

    #[inline(always)]
    fn sub(self, rhs: Self) -> Self::Output {
        T::vec_sub(self, rhs)
    }
}

impl<const N: usize, T: Mul<Output = T> + ElementOfVector<N, S>, S: Simdness> Mul
    for Vector<N, T, S>
{
    type Output = Self;

    #[inline(always)]
    fn mul(self, rhs: Self) -> Self::Output {
        T::vec_mul(self, rhs)
    }
}

impl<const N: usize, T: Div<Output = T> + ElementOfVector<N, S>, S: Simdness> Div
    for Vector<N, T, S>
{
    type Output = Self;

    #[inline(always)]
    fn div(self, rhs: Self) -> Self::Output {
        T::vec_div(self, rhs)
    }
}

impl<const N: usize, T: Rem<Output = T> + ElementOfVector<N, S>, S: Simdness> Rem
    for Vector<N, T, S>
{
    type Output = Self;

    #[inline(always)]
    fn rem(self, rhs: Self) -> Self::Output {
        T::vec_rem(self, rhs)
    }
}

impl<const N: usize, T: Shl<Output = T> + ElementOfVector<N, S>, S: Simdness> Shl
    for Vector<N, T, S>
{
    type Output = Self;

    #[inline(always)]
    fn shl(self, rhs: Self) -> Self::Output {
        T::vec_shl(self, rhs)
    }
}

impl<const N: usize, T: Shr<Output = T> + ElementOfVector<N, S>, S: Simdness> Shr
    for Vector<N, T, S>
{
    type Output = Self;

    #[inline(always)]
    fn shr(self, rhs: Self) -> Self::Output {
        T::vec_shr(self, rhs)
    }
}

impl<const N: usize, T: BitAnd<Output = T> + ElementOfVector<N, S>, S: Simdness> BitAnd
    for Vector<N, T, S>
{
    type Output = Self;

    #[inline(always)]
    fn bitand(self, rhs: Self) -> Self::Output {
        T::vec_bitand(self, rhs)
    }
}

impl<const N: usize, T: BitOr<Output = T> + ElementOfVector<N, S>, S: Simdness> BitOr
    for Vector<N, T, S>
{
    type Output = Self;

    #[inline(always)]
    fn bitor(self, rhs: Self) -> Self::Output {
        T::vec_bitor(self, rhs)
    }
}

impl<const N: usize, T: BitXor<Output = T> + ElementOfVector<N, S>, S: Simdness> BitXor
    for Vector<N, T, S>
{
    type Output = Self;

    #[inline(always)]
    fn bitxor(self, rhs: Self) -> Self::Output {
        T::vec_bitxor(self, rhs)
    }
}

impl<const N: usize, T: Add<Output = T> + ElementOfVector<N, S>, S: Simdness> AddAssign
    for Vector<N, T, S>
{
    #[inline(always)]
    fn add_assign(&mut self, rhs: Self) {
        *self = T::vec_add(*self, rhs);
    }
}

impl<const N: usize, T: Sub<Output = T> + ElementOfVector<N, S>, S: Simdness> SubAssign
    for Vector<N, T, S>
{
    #[inline(always)]
    fn sub_assign(&mut self, rhs: Self) {
        *self = T::vec_sub(*self, rhs);
    }
}

impl<const N: usize, T: Mul<Output = T> + ElementOfVector<N, S>, S: Simdness> MulAssign
    for Vector<N, T, S>
{
    #[inline(always)]
    fn mul_assign(&mut self, rhs: Self) {
        *self = T::vec_mul(*self, rhs);
    }
}

impl<const N: usize, T: Div<Output = T> + ElementOfVector<N, S>, S: Simdness> DivAssign
    for Vector<N, T, S>
{
    #[inline(always)]
    fn div_assign(&mut self, rhs: Self) {
        *self = T::vec_div(*self, rhs);
    }
}

impl<const N: usize, T: Rem<Output = T> + ElementOfVector<N, S>, S: Simdness> RemAssign
    for Vector<N, T, S>
{
    #[inline(always)]
    fn rem_assign(&mut self, rhs: Self) {
        *self = T::vec_rem(*self, rhs);
    }
}

impl<const N: usize, T: Shl<Output = T> + ElementOfVector<N, S>, S: Simdness> ShlAssign
    for Vector<N, T, S>
{
    #[inline(always)]
    fn shl_assign(&mut self, rhs: Self) {
        *self = T::vec_shl(*self, rhs);
    }
}

impl<const N: usize, T: Shr<Output = T> + ElementOfVector<N, S>, S: Simdness> ShrAssign
    for Vector<N, T, S>
{
    #[inline(always)]
    fn shr_assign(&mut self, rhs: Self) {
        *self = T::vec_shr(*self, rhs);
    }
}

impl<const N: usize, T: BitAnd<Output = T> + ElementOfVector<N, S>, S: Simdness> BitAndAssign
    for Vector<N, T, S>
{
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: Self) {
        *self = T::vec_bitand(*self, rhs);
    }
}

impl<const N: usize, T: BitOr<Output = T> + ElementOfVector<N, S>, S: Simdness> BitOrAssign
    for Vector<N, T, S>
{
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: Self) {
        *self = T::vec_bitor(*self, rhs);
    }
}

impl<const N: usize, T: BitXor<Output = T> + ElementOfVector<N, S>, S: Simdness> BitXorAssign
    for Vector<N, T, S>
{
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = T::vec_bitxor(*self, rhs);
    }
}
