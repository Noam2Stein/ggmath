// This file was generated by an associated codegen crate.
// To modify this file, modify the source code of the associated codegen crate.

use std::ops::*;

use crate::{Scalar, Simd, Simdness, Usize, VecLen, Vector, specialize};

impl<const N: usize, T: Scalar + Neg<Output: Scalar>, S: Simdness> Neg for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn neg(self) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>) -> Vector<N, T::Output, S>:

            for (Vector<2, T, Simd>) -> Vector<2, T::Output, Simd> {
                |vec| T::vec2_neg(vec)
            }
            for (Vector<3, T, Simd>) -> Vector<3, T::Output, Simd> {
                |vec| T::vec3_neg(vec)
            }
            for (Vector<4, T, Simd>) -> Vector<4, T::Output, Simd> {
                |vec| T::vec4_neg(vec)
            }
            else {
                self.map(|v| v.neg())
            }
        }
    }
}

impl<const N: usize, T: Scalar + Neg<Output: Scalar>, S: Simdness> Neg for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn neg(self) -> Self::Output {
        (*self).neg()
    }
}
impl<const N: usize, T: Scalar + Not<Output: Scalar>, S: Simdness> Not for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn not(self) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>) -> Vector<N, T::Output, S>:

            for (Vector<2, T, Simd>) -> Vector<2, T::Output, Simd> {
                |vec| T::vec2_not(vec)
            }
            for (Vector<3, T, Simd>) -> Vector<3, T::Output, Simd> {
                |vec| T::vec3_not(vec)
            }
            for (Vector<4, T, Simd>) -> Vector<4, T::Output, Simd> {
                |vec| T::vec4_not(vec)
            }
            else {
                self.map(|v| v.not())
            }
        }
    }
}

impl<const N: usize, T: Scalar + Not<Output: Scalar>, S: Simdness> Not for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn not(self) -> Self::Output {
        (*self).not()
    }
}

impl<const N: usize, T: Scalar + Add<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Add<Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn add(self, rhs: Vector<N, T2, S>) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>, rhs: Vector<N, T2, S>) -> Vector<N, T::Output, S>:

            for (Vector<2, T, Simd>, Vector<2, T2, Simd>) -> Vector<2, T::Output, Simd> {
                |vec, rhs| T::vec2_add(vec, rhs)
            }
            for (Vector<3, T, Simd>, Vector<3, T2, Simd>) -> Vector<3, T::Output, Simd> {
                |vec, rhs| T::vec3_add(vec, rhs)
            }
            for (Vector<4, T, Simd>, Vector<4, T2, Simd>) -> Vector<4, T::Output, Simd> {
                |vec, rhs| T::vec4_add(vec, rhs)
            }
            else {
                Vector::from_fn(|i| self.index(i).add(rhs.index(i)))
            }
        }
    }
}

impl<const N: usize, T: Scalar + Add<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Add<Vector<N, T2, S>> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn add(self, rhs: Vector<N, T2, S>) -> Self::Output {
        (*self).add(rhs)
    }
}

impl<const N: usize, T: Scalar + Add<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Add<&Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn add(self, rhs: &Vector<N, T2, S>) -> Self::Output {
        self.add(*rhs)
    }
}

impl<const N: usize, T: Scalar + Add<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Add<&Vector<N, T2, S>> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn add(self, rhs: &Vector<N, T2, S>) -> Self::Output {
        (*self).add(*rhs)
    }
}

impl<const N: usize, T: Scalar + Add<T2, Output = T>, S: Simdness, T2: Scalar>
    AddAssign<Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn add_assign(&mut self, rhs: Vector<N, T2, S>) {
        *self = (*self).add(rhs);
    }
}

impl<const N: usize, T: Scalar + Add<T2, Output = T>, S: Simdness, T2: Scalar>
    AddAssign<&Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn add_assign(&mut self, rhs: &Vector<N, T2, S>) {
        self.add_assign(*rhs);
    }
}

impl<const N: usize, T: Scalar + Add<T2, Output: Scalar>, S: Simdness, T2: Scalar> Add<T2>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn add(self, rhs: T2) -> Self::Output {
        self.add(Vector::<N, T2, S>::splat(rhs))
    }
}

impl<const N: usize, T: Scalar + Add<T2, Output: Scalar>, S: Simdness, T2: Scalar> Add<T2>
    for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn add(self, rhs: T2) -> Self::Output {
        (*self).add(rhs)
    }
}

impl<const N: usize, T: Scalar + Add<T2, Output = T>, S: Simdness, T2: Scalar> AddAssign<T2>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn add_assign(&mut self, rhs: T2) {
        *self = (*self).add(rhs);
    }
}
impl<const N: usize, T: Scalar + Sub<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Sub<Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn sub(self, rhs: Vector<N, T2, S>) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>, rhs: Vector<N, T2, S>) -> Vector<N, T::Output, S>:

            for (Vector<2, T, Simd>, Vector<2, T2, Simd>) -> Vector<2, T::Output, Simd> {
                |vec, rhs| T::vec2_sub(vec, rhs)
            }
            for (Vector<3, T, Simd>, Vector<3, T2, Simd>) -> Vector<3, T::Output, Simd> {
                |vec, rhs| T::vec3_sub(vec, rhs)
            }
            for (Vector<4, T, Simd>, Vector<4, T2, Simd>) -> Vector<4, T::Output, Simd> {
                |vec, rhs| T::vec4_sub(vec, rhs)
            }
            else {
                Vector::from_fn(|i| self.index(i).sub(rhs.index(i)))
            }
        }
    }
}

impl<const N: usize, T: Scalar + Sub<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Sub<Vector<N, T2, S>> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn sub(self, rhs: Vector<N, T2, S>) -> Self::Output {
        (*self).sub(rhs)
    }
}

impl<const N: usize, T: Scalar + Sub<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Sub<&Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn sub(self, rhs: &Vector<N, T2, S>) -> Self::Output {
        self.sub(*rhs)
    }
}

impl<const N: usize, T: Scalar + Sub<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Sub<&Vector<N, T2, S>> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn sub(self, rhs: &Vector<N, T2, S>) -> Self::Output {
        (*self).sub(*rhs)
    }
}

impl<const N: usize, T: Scalar + Sub<T2, Output = T>, S: Simdness, T2: Scalar>
    SubAssign<Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn sub_assign(&mut self, rhs: Vector<N, T2, S>) {
        *self = (*self).sub(rhs);
    }
}

impl<const N: usize, T: Scalar + Sub<T2, Output = T>, S: Simdness, T2: Scalar>
    SubAssign<&Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn sub_assign(&mut self, rhs: &Vector<N, T2, S>) {
        self.sub_assign(*rhs);
    }
}

impl<const N: usize, T: Scalar + Sub<T2, Output: Scalar>, S: Simdness, T2: Scalar> Sub<T2>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn sub(self, rhs: T2) -> Self::Output {
        self.sub(Vector::<N, T2, S>::splat(rhs))
    }
}

impl<const N: usize, T: Scalar + Sub<T2, Output: Scalar>, S: Simdness, T2: Scalar> Sub<T2>
    for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn sub(self, rhs: T2) -> Self::Output {
        (*self).sub(rhs)
    }
}

impl<const N: usize, T: Scalar + Sub<T2, Output = T>, S: Simdness, T2: Scalar> SubAssign<T2>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn sub_assign(&mut self, rhs: T2) {
        *self = (*self).sub(rhs);
    }
}
impl<const N: usize, T: Scalar + Mul<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Mul<Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn mul(self, rhs: Vector<N, T2, S>) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>, rhs: Vector<N, T2, S>) -> Vector<N, T::Output, S>:

            for (Vector<2, T, Simd>, Vector<2, T2, Simd>) -> Vector<2, T::Output, Simd> {
                |vec, rhs| T::vec2_mul(vec, rhs)
            }
            for (Vector<3, T, Simd>, Vector<3, T2, Simd>) -> Vector<3, T::Output, Simd> {
                |vec, rhs| T::vec3_mul(vec, rhs)
            }
            for (Vector<4, T, Simd>, Vector<4, T2, Simd>) -> Vector<4, T::Output, Simd> {
                |vec, rhs| T::vec4_mul(vec, rhs)
            }
            else {
                Vector::from_fn(|i| self.index(i).mul(rhs.index(i)))
            }
        }
    }
}

impl<const N: usize, T: Scalar + Mul<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Mul<Vector<N, T2, S>> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn mul(self, rhs: Vector<N, T2, S>) -> Self::Output {
        (*self).mul(rhs)
    }
}

impl<const N: usize, T: Scalar + Mul<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Mul<&Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn mul(self, rhs: &Vector<N, T2, S>) -> Self::Output {
        self.mul(*rhs)
    }
}

impl<const N: usize, T: Scalar + Mul<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Mul<&Vector<N, T2, S>> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn mul(self, rhs: &Vector<N, T2, S>) -> Self::Output {
        (*self).mul(*rhs)
    }
}

impl<const N: usize, T: Scalar + Mul<T2, Output = T>, S: Simdness, T2: Scalar>
    MulAssign<Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn mul_assign(&mut self, rhs: Vector<N, T2, S>) {
        *self = (*self).mul(rhs);
    }
}

impl<const N: usize, T: Scalar + Mul<T2, Output = T>, S: Simdness, T2: Scalar>
    MulAssign<&Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn mul_assign(&mut self, rhs: &Vector<N, T2, S>) {
        self.mul_assign(*rhs);
    }
}

impl<const N: usize, T: Scalar + Mul<T2, Output: Scalar>, S: Simdness, T2: Scalar> Mul<T2>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn mul(self, rhs: T2) -> Self::Output {
        self.mul(Vector::<N, T2, S>::splat(rhs))
    }
}

impl<const N: usize, T: Scalar + Mul<T2, Output: Scalar>, S: Simdness, T2: Scalar> Mul<T2>
    for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn mul(self, rhs: T2) -> Self::Output {
        (*self).mul(rhs)
    }
}

impl<const N: usize, T: Scalar + Mul<T2, Output = T>, S: Simdness, T2: Scalar> MulAssign<T2>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn mul_assign(&mut self, rhs: T2) {
        *self = (*self).mul(rhs);
    }
}
impl<const N: usize, T: Scalar + Div<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Div<Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn div(self, rhs: Vector<N, T2, S>) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>, rhs: Vector<N, T2, S>) -> Vector<N, T::Output, S>:

            for (Vector<2, T, Simd>, Vector<2, T2, Simd>) -> Vector<2, T::Output, Simd> {
                |vec, rhs| T::vec2_div(vec, rhs)
            }
            for (Vector<3, T, Simd>, Vector<3, T2, Simd>) -> Vector<3, T::Output, Simd> {
                |vec, rhs| T::vec3_div(vec, rhs)
            }
            for (Vector<4, T, Simd>, Vector<4, T2, Simd>) -> Vector<4, T::Output, Simd> {
                |vec, rhs| T::vec4_div(vec, rhs)
            }
            else {
                Vector::from_fn(|i| self.index(i).div(rhs.index(i)))
            }
        }
    }
}

impl<const N: usize, T: Scalar + Div<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Div<Vector<N, T2, S>> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn div(self, rhs: Vector<N, T2, S>) -> Self::Output {
        (*self).div(rhs)
    }
}

impl<const N: usize, T: Scalar + Div<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Div<&Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn div(self, rhs: &Vector<N, T2, S>) -> Self::Output {
        self.div(*rhs)
    }
}

impl<const N: usize, T: Scalar + Div<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Div<&Vector<N, T2, S>> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn div(self, rhs: &Vector<N, T2, S>) -> Self::Output {
        (*self).div(*rhs)
    }
}

impl<const N: usize, T: Scalar + Div<T2, Output = T>, S: Simdness, T2: Scalar>
    DivAssign<Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn div_assign(&mut self, rhs: Vector<N, T2, S>) {
        *self = (*self).div(rhs);
    }
}

impl<const N: usize, T: Scalar + Div<T2, Output = T>, S: Simdness, T2: Scalar>
    DivAssign<&Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn div_assign(&mut self, rhs: &Vector<N, T2, S>) {
        self.div_assign(*rhs);
    }
}

impl<const N: usize, T: Scalar + Div<T2, Output: Scalar>, S: Simdness, T2: Scalar> Div<T2>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn div(self, rhs: T2) -> Self::Output {
        self.div(Vector::<N, T2, S>::splat(rhs))
    }
}

impl<const N: usize, T: Scalar + Div<T2, Output: Scalar>, S: Simdness, T2: Scalar> Div<T2>
    for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn div(self, rhs: T2) -> Self::Output {
        (*self).div(rhs)
    }
}

impl<const N: usize, T: Scalar + Div<T2, Output = T>, S: Simdness, T2: Scalar> DivAssign<T2>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn div_assign(&mut self, rhs: T2) {
        *self = (*self).div(rhs);
    }
}
impl<const N: usize, T: Scalar + Rem<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Rem<Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn rem(self, rhs: Vector<N, T2, S>) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>, rhs: Vector<N, T2, S>) -> Vector<N, T::Output, S>:

            for (Vector<2, T, Simd>, Vector<2, T2, Simd>) -> Vector<2, T::Output, Simd> {
                |vec, rhs| T::vec2_rem(vec, rhs)
            }
            for (Vector<3, T, Simd>, Vector<3, T2, Simd>) -> Vector<3, T::Output, Simd> {
                |vec, rhs| T::vec3_rem(vec, rhs)
            }
            for (Vector<4, T, Simd>, Vector<4, T2, Simd>) -> Vector<4, T::Output, Simd> {
                |vec, rhs| T::vec4_rem(vec, rhs)
            }
            else {
                Vector::from_fn(|i| self.index(i).rem(rhs.index(i)))
            }
        }
    }
}

impl<const N: usize, T: Scalar + Rem<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Rem<Vector<N, T2, S>> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn rem(self, rhs: Vector<N, T2, S>) -> Self::Output {
        (*self).rem(rhs)
    }
}

impl<const N: usize, T: Scalar + Rem<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Rem<&Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn rem(self, rhs: &Vector<N, T2, S>) -> Self::Output {
        self.rem(*rhs)
    }
}

impl<const N: usize, T: Scalar + Rem<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Rem<&Vector<N, T2, S>> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn rem(self, rhs: &Vector<N, T2, S>) -> Self::Output {
        (*self).rem(*rhs)
    }
}

impl<const N: usize, T: Scalar + Rem<T2, Output = T>, S: Simdness, T2: Scalar>
    RemAssign<Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn rem_assign(&mut self, rhs: Vector<N, T2, S>) {
        *self = (*self).rem(rhs);
    }
}

impl<const N: usize, T: Scalar + Rem<T2, Output = T>, S: Simdness, T2: Scalar>
    RemAssign<&Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn rem_assign(&mut self, rhs: &Vector<N, T2, S>) {
        self.rem_assign(*rhs);
    }
}

impl<const N: usize, T: Scalar + Rem<T2, Output: Scalar>, S: Simdness, T2: Scalar> Rem<T2>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn rem(self, rhs: T2) -> Self::Output {
        self.rem(Vector::<N, T2, S>::splat(rhs))
    }
}

impl<const N: usize, T: Scalar + Rem<T2, Output: Scalar>, S: Simdness, T2: Scalar> Rem<T2>
    for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn rem(self, rhs: T2) -> Self::Output {
        (*self).rem(rhs)
    }
}

impl<const N: usize, T: Scalar + Rem<T2, Output = T>, S: Simdness, T2: Scalar> RemAssign<T2>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn rem_assign(&mut self, rhs: T2) {
        *self = (*self).rem(rhs);
    }
}
impl<const N: usize, T: Scalar + Shl<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Shl<Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn shl(self, rhs: Vector<N, T2, S>) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>, rhs: Vector<N, T2, S>) -> Vector<N, T::Output, S>:

            for (Vector<2, T, Simd>, Vector<2, T2, Simd>) -> Vector<2, T::Output, Simd> {
                |vec, rhs| T::vec2_shl(vec, rhs)
            }
            for (Vector<3, T, Simd>, Vector<3, T2, Simd>) -> Vector<3, T::Output, Simd> {
                |vec, rhs| T::vec3_shl(vec, rhs)
            }
            for (Vector<4, T, Simd>, Vector<4, T2, Simd>) -> Vector<4, T::Output, Simd> {
                |vec, rhs| T::vec4_shl(vec, rhs)
            }
            else {
                Vector::from_fn(|i| self.index(i).shl(rhs.index(i)))
            }
        }
    }
}

impl<const N: usize, T: Scalar + Shl<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Shl<Vector<N, T2, S>> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn shl(self, rhs: Vector<N, T2, S>) -> Self::Output {
        (*self).shl(rhs)
    }
}

impl<const N: usize, T: Scalar + Shl<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Shl<&Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn shl(self, rhs: &Vector<N, T2, S>) -> Self::Output {
        self.shl(*rhs)
    }
}

impl<const N: usize, T: Scalar + Shl<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Shl<&Vector<N, T2, S>> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn shl(self, rhs: &Vector<N, T2, S>) -> Self::Output {
        (*self).shl(*rhs)
    }
}

impl<const N: usize, T: Scalar + Shl<T2, Output = T>, S: Simdness, T2: Scalar>
    ShlAssign<Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn shl_assign(&mut self, rhs: Vector<N, T2, S>) {
        *self = (*self).shl(rhs);
    }
}

impl<const N: usize, T: Scalar + Shl<T2, Output = T>, S: Simdness, T2: Scalar>
    ShlAssign<&Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn shl_assign(&mut self, rhs: &Vector<N, T2, S>) {
        self.shl_assign(*rhs);
    }
}

impl<const N: usize, T: Scalar + Shl<T2, Output: Scalar>, S: Simdness, T2: Scalar> Shl<T2>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn shl(self, rhs: T2) -> Self::Output {
        self.shl(Vector::<N, T2, S>::splat(rhs))
    }
}

impl<const N: usize, T: Scalar + Shl<T2, Output: Scalar>, S: Simdness, T2: Scalar> Shl<T2>
    for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn shl(self, rhs: T2) -> Self::Output {
        (*self).shl(rhs)
    }
}

impl<const N: usize, T: Scalar + Shl<T2, Output = T>, S: Simdness, T2: Scalar> ShlAssign<T2>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn shl_assign(&mut self, rhs: T2) {
        *self = (*self).shl(rhs);
    }
}
impl<const N: usize, T: Scalar + Shr<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Shr<Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn shr(self, rhs: Vector<N, T2, S>) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>, rhs: Vector<N, T2, S>) -> Vector<N, T::Output, S>:

            for (Vector<2, T, Simd>, Vector<2, T2, Simd>) -> Vector<2, T::Output, Simd> {
                |vec, rhs| T::vec2_shr(vec, rhs)
            }
            for (Vector<3, T, Simd>, Vector<3, T2, Simd>) -> Vector<3, T::Output, Simd> {
                |vec, rhs| T::vec3_shr(vec, rhs)
            }
            for (Vector<4, T, Simd>, Vector<4, T2, Simd>) -> Vector<4, T::Output, Simd> {
                |vec, rhs| T::vec4_shr(vec, rhs)
            }
            else {
                Vector::from_fn(|i| self.index(i).shr(rhs.index(i)))
            }
        }
    }
}

impl<const N: usize, T: Scalar + Shr<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Shr<Vector<N, T2, S>> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn shr(self, rhs: Vector<N, T2, S>) -> Self::Output {
        (*self).shr(rhs)
    }
}

impl<const N: usize, T: Scalar + Shr<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Shr<&Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn shr(self, rhs: &Vector<N, T2, S>) -> Self::Output {
        self.shr(*rhs)
    }
}

impl<const N: usize, T: Scalar + Shr<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    Shr<&Vector<N, T2, S>> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn shr(self, rhs: &Vector<N, T2, S>) -> Self::Output {
        (*self).shr(*rhs)
    }
}

impl<const N: usize, T: Scalar + Shr<T2, Output = T>, S: Simdness, T2: Scalar>
    ShrAssign<Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn shr_assign(&mut self, rhs: Vector<N, T2, S>) {
        *self = (*self).shr(rhs);
    }
}

impl<const N: usize, T: Scalar + Shr<T2, Output = T>, S: Simdness, T2: Scalar>
    ShrAssign<&Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn shr_assign(&mut self, rhs: &Vector<N, T2, S>) {
        self.shr_assign(*rhs);
    }
}

impl<const N: usize, T: Scalar + Shr<T2, Output: Scalar>, S: Simdness, T2: Scalar> Shr<T2>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn shr(self, rhs: T2) -> Self::Output {
        self.shr(Vector::<N, T2, S>::splat(rhs))
    }
}

impl<const N: usize, T: Scalar + Shr<T2, Output: Scalar>, S: Simdness, T2: Scalar> Shr<T2>
    for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn shr(self, rhs: T2) -> Self::Output {
        (*self).shr(rhs)
    }
}

impl<const N: usize, T: Scalar + Shr<T2, Output = T>, S: Simdness, T2: Scalar> ShrAssign<T2>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn shr_assign(&mut self, rhs: T2) {
        *self = (*self).shr(rhs);
    }
}
impl<const N: usize, T: Scalar + BitAnd<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    BitAnd<Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn bitand(self, rhs: Vector<N, T2, S>) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>, rhs: Vector<N, T2, S>) -> Vector<N, T::Output, S>:

            for (Vector<2, T, Simd>, Vector<2, T2, Simd>) -> Vector<2, T::Output, Simd> {
                |vec, rhs| T::vec2_bitand(vec, rhs)
            }
            for (Vector<3, T, Simd>, Vector<3, T2, Simd>) -> Vector<3, T::Output, Simd> {
                |vec, rhs| T::vec3_bitand(vec, rhs)
            }
            for (Vector<4, T, Simd>, Vector<4, T2, Simd>) -> Vector<4, T::Output, Simd> {
                |vec, rhs| T::vec4_bitand(vec, rhs)
            }
            else {
                Vector::from_fn(|i| self.index(i).bitand(rhs.index(i)))
            }
        }
    }
}

impl<const N: usize, T: Scalar + BitAnd<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    BitAnd<Vector<N, T2, S>> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn bitand(self, rhs: Vector<N, T2, S>) -> Self::Output {
        (*self).bitand(rhs)
    }
}

impl<const N: usize, T: Scalar + BitAnd<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    BitAnd<&Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn bitand(self, rhs: &Vector<N, T2, S>) -> Self::Output {
        self.bitand(*rhs)
    }
}

impl<const N: usize, T: Scalar + BitAnd<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    BitAnd<&Vector<N, T2, S>> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn bitand(self, rhs: &Vector<N, T2, S>) -> Self::Output {
        (*self).bitand(*rhs)
    }
}

impl<const N: usize, T: Scalar + BitAnd<T2, Output = T>, S: Simdness, T2: Scalar>
    BitAndAssign<Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: Vector<N, T2, S>) {
        *self = (*self).bitand(rhs);
    }
}

impl<const N: usize, T: Scalar + BitAnd<T2, Output = T>, S: Simdness, T2: Scalar>
    BitAndAssign<&Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: &Vector<N, T2, S>) {
        self.bitand_assign(*rhs);
    }
}

impl<const N: usize, T: Scalar + BitAnd<T2, Output: Scalar>, S: Simdness, T2: Scalar> BitAnd<T2>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn bitand(self, rhs: T2) -> Self::Output {
        self.bitand(Vector::<N, T2, S>::splat(rhs))
    }
}

impl<const N: usize, T: Scalar + BitAnd<T2, Output: Scalar>, S: Simdness, T2: Scalar> BitAnd<T2>
    for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn bitand(self, rhs: T2) -> Self::Output {
        (*self).bitand(rhs)
    }
}

impl<const N: usize, T: Scalar + BitAnd<T2, Output = T>, S: Simdness, T2: Scalar> BitAndAssign<T2>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: T2) {
        *self = (*self).bitand(rhs);
    }
}
impl<const N: usize, T: Scalar + BitOr<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    BitOr<Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn bitor(self, rhs: Vector<N, T2, S>) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>, rhs: Vector<N, T2, S>) -> Vector<N, T::Output, S>:

            for (Vector<2, T, Simd>, Vector<2, T2, Simd>) -> Vector<2, T::Output, Simd> {
                |vec, rhs| T::vec2_bitor(vec, rhs)
            }
            for (Vector<3, T, Simd>, Vector<3, T2, Simd>) -> Vector<3, T::Output, Simd> {
                |vec, rhs| T::vec3_bitor(vec, rhs)
            }
            for (Vector<4, T, Simd>, Vector<4, T2, Simd>) -> Vector<4, T::Output, Simd> {
                |vec, rhs| T::vec4_bitor(vec, rhs)
            }
            else {
                Vector::from_fn(|i| self.index(i).bitor(rhs.index(i)))
            }
        }
    }
}

impl<const N: usize, T: Scalar + BitOr<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    BitOr<Vector<N, T2, S>> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn bitor(self, rhs: Vector<N, T2, S>) -> Self::Output {
        (*self).bitor(rhs)
    }
}

impl<const N: usize, T: Scalar + BitOr<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    BitOr<&Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn bitor(self, rhs: &Vector<N, T2, S>) -> Self::Output {
        self.bitor(*rhs)
    }
}

impl<const N: usize, T: Scalar + BitOr<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    BitOr<&Vector<N, T2, S>> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn bitor(self, rhs: &Vector<N, T2, S>) -> Self::Output {
        (*self).bitor(*rhs)
    }
}

impl<const N: usize, T: Scalar + BitOr<T2, Output = T>, S: Simdness, T2: Scalar>
    BitOrAssign<Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: Vector<N, T2, S>) {
        *self = (*self).bitor(rhs);
    }
}

impl<const N: usize, T: Scalar + BitOr<T2, Output = T>, S: Simdness, T2: Scalar>
    BitOrAssign<&Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: &Vector<N, T2, S>) {
        self.bitor_assign(*rhs);
    }
}

impl<const N: usize, T: Scalar + BitOr<T2, Output: Scalar>, S: Simdness, T2: Scalar> BitOr<T2>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn bitor(self, rhs: T2) -> Self::Output {
        self.bitor(Vector::<N, T2, S>::splat(rhs))
    }
}

impl<const N: usize, T: Scalar + BitOr<T2, Output: Scalar>, S: Simdness, T2: Scalar> BitOr<T2>
    for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn bitor(self, rhs: T2) -> Self::Output {
        (*self).bitor(rhs)
    }
}

impl<const N: usize, T: Scalar + BitOr<T2, Output = T>, S: Simdness, T2: Scalar> BitOrAssign<T2>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: T2) {
        *self = (*self).bitor(rhs);
    }
}
impl<const N: usize, T: Scalar + BitXor<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    BitXor<Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn bitxor(self, rhs: Vector<N, T2, S>) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>, rhs: Vector<N, T2, S>) -> Vector<N, T::Output, S>:

            for (Vector<2, T, Simd>, Vector<2, T2, Simd>) -> Vector<2, T::Output, Simd> {
                |vec, rhs| T::vec2_bitxor(vec, rhs)
            }
            for (Vector<3, T, Simd>, Vector<3, T2, Simd>) -> Vector<3, T::Output, Simd> {
                |vec, rhs| T::vec3_bitxor(vec, rhs)
            }
            for (Vector<4, T, Simd>, Vector<4, T2, Simd>) -> Vector<4, T::Output, Simd> {
                |vec, rhs| T::vec4_bitxor(vec, rhs)
            }
            else {
                Vector::from_fn(|i| self.index(i).bitxor(rhs.index(i)))
            }
        }
    }
}

impl<const N: usize, T: Scalar + BitXor<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    BitXor<Vector<N, T2, S>> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn bitxor(self, rhs: Vector<N, T2, S>) -> Self::Output {
        (*self).bitxor(rhs)
    }
}

impl<const N: usize, T: Scalar + BitXor<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    BitXor<&Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn bitxor(self, rhs: &Vector<N, T2, S>) -> Self::Output {
        self.bitxor(*rhs)
    }
}

impl<const N: usize, T: Scalar + BitXor<T2, Output: Scalar>, S: Simdness, T2: Scalar>
    BitXor<&Vector<N, T2, S>> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn bitxor(self, rhs: &Vector<N, T2, S>) -> Self::Output {
        (*self).bitxor(*rhs)
    }
}

impl<const N: usize, T: Scalar + BitXor<T2, Output = T>, S: Simdness, T2: Scalar>
    BitXorAssign<Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: Vector<N, T2, S>) {
        *self = (*self).bitxor(rhs);
    }
}

impl<const N: usize, T: Scalar + BitXor<T2, Output = T>, S: Simdness, T2: Scalar>
    BitXorAssign<&Vector<N, T2, S>> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: &Vector<N, T2, S>) {
        self.bitxor_assign(*rhs);
    }
}

impl<const N: usize, T: Scalar + BitXor<T2, Output: Scalar>, S: Simdness, T2: Scalar> BitXor<T2>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn bitxor(self, rhs: T2) -> Self::Output {
        self.bitxor(Vector::<N, T2, S>::splat(rhs))
    }
}

impl<const N: usize, T: Scalar + BitXor<T2, Output: Scalar>, S: Simdness, T2: Scalar> BitXor<T2>
    for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, S>;

    #[inline(always)]
    fn bitxor(self, rhs: T2) -> Self::Output {
        (*self).bitxor(rhs)
    }
}

impl<const N: usize, T: Scalar + BitXor<T2, Output = T>, S: Simdness, T2: Scalar> BitXorAssign<T2>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: T2) {
        *self = (*self).bitxor(rhs);
    }
}
