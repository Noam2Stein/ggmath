// This file was generated by a codegen tool.
// To modify this file, modify the source code of the codegen tool.

use std::ops::*;

use crate::{Scalar, Simd, Simdness, Usize, VecLen, Vector, specialize};

impl<const N: usize, T: Scalar + Neg<Output = T>, S: Simdness> Neg for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn neg(self) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>) -> Vector<N, T, S>:

            for (Vector<N, T, Simd>) -> Vector<N, T, Simd> {
                |vec| T::vec_neg(vec)
            } else {
                self.map(|v| v.neg())
            }
        }
    }
}

impl<const N: usize, T: Scalar + Neg<Output = T>, S: Simdness> Neg for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn neg(self) -> Self::Output {
        (*self).neg()
    }
}

impl<const N: usize, T: Scalar + Not<Output = T>, S: Simdness> Not for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn not(self) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>) -> Vector<N, T, S>:

            for (Vector<N, T, Simd>) -> Vector<N, T, Simd> {
                |vec| T::vec_not(vec)
            } else {
                self.map(|v| v.not())
            }
        }
    }
}

impl<const N: usize, T: Scalar + Not<Output = T>, S: Simdness> Not for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn not(self) -> Self::Output {
        (*self).not()
    }
}

impl<const N: usize, T: Scalar + Add<Output = T>, S: Simdness> Add for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn add(self, rhs: Self) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>, rhs: Vector<N, T, S>) -> Vector<N, T, S>:

            for (Vector<N, T, Simd>, Vector<N, T, Simd>) -> Vector<N, T, Simd> {
                |vec, rhs| T::vec_add(vec, rhs)
            } else {
                Vector::from_fn(|i| self.index(i).add(rhs.index(i)))
            }
        }
    }
}

impl<const N: usize, T: Scalar + Add<Output = T>, S: Simdness> Add<Vector<N, T, S>>
    for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn add(self, rhs: Vector<N, T, S>) -> Self::Output {
        (*self).add(rhs)
    }
}

impl<const N: usize, T: Scalar + Add<Output = T>, S: Simdness> Add<&Self> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn add(self, rhs: &Self) -> Self::Output {
        self.add(*rhs)
    }
}

impl<const N: usize, T: Scalar + Add<Output = T>, S: Simdness> Add for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn add(self, rhs: Self) -> Self::Output {
        (*self).add(*rhs)
    }
}

impl<const N: usize, T: Scalar + Add<Output = T>, S: Simdness> AddAssign for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn add_assign(&mut self, rhs: Self) {
        *self = (*self).add(rhs);
    }
}

impl<const N: usize, T: Scalar + Add<Output = T>, S: Simdness> AddAssign<&Self> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn add_assign(&mut self, rhs: &Self) {
        self.add_assign(*rhs);
    }
}

impl<const N: usize, T: Scalar + Add<Output = T>, S: Simdness> Add<T> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn add(self, rhs: T) -> Self::Output {
        self.add(Self::splat(rhs))
    }
}

impl<const N: usize, T: Scalar + Add<Output = T>, S: Simdness> Add<T> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn add(self, rhs: T) -> Self::Output {
        (*self).add(rhs)
    }
}

impl<const N: usize, T: Scalar + Add<Output = T>, S: Simdness> AddAssign<T> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn add_assign(&mut self, rhs: T) {
        *self = (*self).add(rhs);
    }
}

impl<const N: usize, T: Scalar + Sub<Output = T>, S: Simdness> Sub for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn sub(self, rhs: Self) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>, rhs: Vector<N, T, S>) -> Vector<N, T, S>:

            for (Vector<N, T, Simd>, Vector<N, T, Simd>) -> Vector<N, T, Simd> {
                |vec, rhs| T::vec_sub(vec, rhs)
            } else {
                Vector::from_fn(|i| self.index(i).sub(rhs.index(i)))
            }
        }
    }
}

impl<const N: usize, T: Scalar + Sub<Output = T>, S: Simdness> Sub<Vector<N, T, S>>
    for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn sub(self, rhs: Vector<N, T, S>) -> Self::Output {
        (*self).sub(rhs)
    }
}

impl<const N: usize, T: Scalar + Sub<Output = T>, S: Simdness> Sub<&Self> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn sub(self, rhs: &Self) -> Self::Output {
        self.sub(*rhs)
    }
}

impl<const N: usize, T: Scalar + Sub<Output = T>, S: Simdness> Sub for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn sub(self, rhs: Self) -> Self::Output {
        (*self).sub(*rhs)
    }
}

impl<const N: usize, T: Scalar + Sub<Output = T>, S: Simdness> SubAssign for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn sub_assign(&mut self, rhs: Self) {
        *self = (*self).sub(rhs);
    }
}

impl<const N: usize, T: Scalar + Sub<Output = T>, S: Simdness> SubAssign<&Self> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn sub_assign(&mut self, rhs: &Self) {
        self.sub_assign(*rhs);
    }
}

impl<const N: usize, T: Scalar + Sub<Output = T>, S: Simdness> Sub<T> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn sub(self, rhs: T) -> Self::Output {
        self.sub(Self::splat(rhs))
    }
}

impl<const N: usize, T: Scalar + Sub<Output = T>, S: Simdness> Sub<T> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn sub(self, rhs: T) -> Self::Output {
        (*self).sub(rhs)
    }
}

impl<const N: usize, T: Scalar + Sub<Output = T>, S: Simdness> SubAssign<T> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn sub_assign(&mut self, rhs: T) {
        *self = (*self).sub(rhs);
    }
}

impl<const N: usize, T: Scalar + Mul<Output = T>, S: Simdness> Mul for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn mul(self, rhs: Self) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>, rhs: Vector<N, T, S>) -> Vector<N, T, S>:

            for (Vector<N, T, Simd>, Vector<N, T, Simd>) -> Vector<N, T, Simd> {
                |vec, rhs| T::vec_mul(vec, rhs)
            } else {
                Vector::from_fn(|i| self.index(i).mul(rhs.index(i)))
            }
        }
    }
}

impl<const N: usize, T: Scalar + Mul<Output = T>, S: Simdness> Mul<Vector<N, T, S>>
    for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn mul(self, rhs: Vector<N, T, S>) -> Self::Output {
        (*self).mul(rhs)
    }
}

impl<const N: usize, T: Scalar + Mul<Output = T>, S: Simdness> Mul<&Self> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn mul(self, rhs: &Self) -> Self::Output {
        self.mul(*rhs)
    }
}

impl<const N: usize, T: Scalar + Mul<Output = T>, S: Simdness> Mul for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn mul(self, rhs: Self) -> Self::Output {
        (*self).mul(*rhs)
    }
}

impl<const N: usize, T: Scalar + Mul<Output = T>, S: Simdness> MulAssign for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn mul_assign(&mut self, rhs: Self) {
        *self = (*self).mul(rhs);
    }
}

impl<const N: usize, T: Scalar + Mul<Output = T>, S: Simdness> MulAssign<&Self> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn mul_assign(&mut self, rhs: &Self) {
        self.mul_assign(*rhs);
    }
}

impl<const N: usize, T: Scalar + Mul<Output = T>, S: Simdness> Mul<T> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn mul(self, rhs: T) -> Self::Output {
        self.mul(Self::splat(rhs))
    }
}

impl<const N: usize, T: Scalar + Mul<Output = T>, S: Simdness> Mul<T> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn mul(self, rhs: T) -> Self::Output {
        (*self).mul(rhs)
    }
}

impl<const N: usize, T: Scalar + Mul<Output = T>, S: Simdness> MulAssign<T> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn mul_assign(&mut self, rhs: T) {
        *self = (*self).mul(rhs);
    }
}

impl<const N: usize, T: Scalar + Div<Output = T>, S: Simdness> Div for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn div(self, rhs: Self) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>, rhs: Vector<N, T, S>) -> Vector<N, T, S>:

            for (Vector<N, T, Simd>, Vector<N, T, Simd>) -> Vector<N, T, Simd> {
                |vec, rhs| T::vec_div(vec, rhs)
            } else {
                Vector::from_fn(|i| self.index(i).div(rhs.index(i)))
            }
        }
    }
}

impl<const N: usize, T: Scalar + Div<Output = T>, S: Simdness> Div<Vector<N, T, S>>
    for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn div(self, rhs: Vector<N, T, S>) -> Self::Output {
        (*self).div(rhs)
    }
}

impl<const N: usize, T: Scalar + Div<Output = T>, S: Simdness> Div<&Self> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn div(self, rhs: &Self) -> Self::Output {
        self.div(*rhs)
    }
}

impl<const N: usize, T: Scalar + Div<Output = T>, S: Simdness> Div for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn div(self, rhs: Self) -> Self::Output {
        (*self).div(*rhs)
    }
}

impl<const N: usize, T: Scalar + Div<Output = T>, S: Simdness> DivAssign for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn div_assign(&mut self, rhs: Self) {
        *self = (*self).div(rhs);
    }
}

impl<const N: usize, T: Scalar + Div<Output = T>, S: Simdness> DivAssign<&Self> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn div_assign(&mut self, rhs: &Self) {
        self.div_assign(*rhs);
    }
}

impl<const N: usize, T: Scalar + Div<Output = T>, S: Simdness> Div<T> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn div(self, rhs: T) -> Self::Output {
        self.div(Self::splat(rhs))
    }
}

impl<const N: usize, T: Scalar + Div<Output = T>, S: Simdness> Div<T> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn div(self, rhs: T) -> Self::Output {
        (*self).div(rhs)
    }
}

impl<const N: usize, T: Scalar + Div<Output = T>, S: Simdness> DivAssign<T> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn div_assign(&mut self, rhs: T) {
        *self = (*self).div(rhs);
    }
}

impl<const N: usize, T: Scalar + Rem<Output = T>, S: Simdness> Rem for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn rem(self, rhs: Self) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>, rhs: Vector<N, T, S>) -> Vector<N, T, S>:

            for (Vector<N, T, Simd>, Vector<N, T, Simd>) -> Vector<N, T, Simd> {
                |vec, rhs| T::vec_rem(vec, rhs)
            } else {
                Vector::from_fn(|i| self.index(i).rem(rhs.index(i)))
            }
        }
    }
}

impl<const N: usize, T: Scalar + Rem<Output = T>, S: Simdness> Rem<Vector<N, T, S>>
    for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn rem(self, rhs: Vector<N, T, S>) -> Self::Output {
        (*self).rem(rhs)
    }
}

impl<const N: usize, T: Scalar + Rem<Output = T>, S: Simdness> Rem<&Self> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn rem(self, rhs: &Self) -> Self::Output {
        self.rem(*rhs)
    }
}

impl<const N: usize, T: Scalar + Rem<Output = T>, S: Simdness> Rem for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn rem(self, rhs: Self) -> Self::Output {
        (*self).rem(*rhs)
    }
}

impl<const N: usize, T: Scalar + Rem<Output = T>, S: Simdness> RemAssign for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn rem_assign(&mut self, rhs: Self) {
        *self = (*self).rem(rhs);
    }
}

impl<const N: usize, T: Scalar + Rem<Output = T>, S: Simdness> RemAssign<&Self> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn rem_assign(&mut self, rhs: &Self) {
        self.rem_assign(*rhs);
    }
}

impl<const N: usize, T: Scalar + Rem<Output = T>, S: Simdness> Rem<T> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn rem(self, rhs: T) -> Self::Output {
        self.rem(Self::splat(rhs))
    }
}

impl<const N: usize, T: Scalar + Rem<Output = T>, S: Simdness> Rem<T> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn rem(self, rhs: T) -> Self::Output {
        (*self).rem(rhs)
    }
}

impl<const N: usize, T: Scalar + Rem<Output = T>, S: Simdness> RemAssign<T> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn rem_assign(&mut self, rhs: T) {
        *self = (*self).rem(rhs);
    }
}

impl<const N: usize, T: Scalar + Shl<Output = T>, S: Simdness> Shl for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn shl(self, rhs: Self) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>, rhs: Vector<N, T, S>) -> Vector<N, T, S>:

            for (Vector<N, T, Simd>, Vector<N, T, Simd>) -> Vector<N, T, Simd> {
                |vec, rhs| T::vec_shl(vec, rhs)
            } else {
                Vector::from_fn(|i| self.index(i).shl(rhs.index(i)))
            }
        }
    }
}

impl<const N: usize, T: Scalar + Shl<Output = T>, S: Simdness> Shl<Vector<N, T, S>>
    for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn shl(self, rhs: Vector<N, T, S>) -> Self::Output {
        (*self).shl(rhs)
    }
}

impl<const N: usize, T: Scalar + Shl<Output = T>, S: Simdness> Shl<&Self> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn shl(self, rhs: &Self) -> Self::Output {
        self.shl(*rhs)
    }
}

impl<const N: usize, T: Scalar + Shl<Output = T>, S: Simdness> Shl for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn shl(self, rhs: Self) -> Self::Output {
        (*self).shl(*rhs)
    }
}

impl<const N: usize, T: Scalar + Shl<Output = T>, S: Simdness> ShlAssign for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn shl_assign(&mut self, rhs: Self) {
        *self = (*self).shl(rhs);
    }
}

impl<const N: usize, T: Scalar + Shl<Output = T>, S: Simdness> ShlAssign<&Self> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn shl_assign(&mut self, rhs: &Self) {
        self.shl_assign(*rhs);
    }
}

impl<const N: usize, T: Scalar + Shl<Output = T>, S: Simdness> Shl<T> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn shl(self, rhs: T) -> Self::Output {
        self.shl(Self::splat(rhs))
    }
}

impl<const N: usize, T: Scalar + Shl<Output = T>, S: Simdness> Shl<T> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn shl(self, rhs: T) -> Self::Output {
        (*self).shl(rhs)
    }
}

impl<const N: usize, T: Scalar + Shl<Output = T>, S: Simdness> ShlAssign<T> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn shl_assign(&mut self, rhs: T) {
        *self = (*self).shl(rhs);
    }
}

impl<const N: usize, T: Scalar + Shr<Output = T>, S: Simdness> Shr for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn shr(self, rhs: Self) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>, rhs: Vector<N, T, S>) -> Vector<N, T, S>:

            for (Vector<N, T, Simd>, Vector<N, T, Simd>) -> Vector<N, T, Simd> {
                |vec, rhs| T::vec_shr(vec, rhs)
            } else {
                Vector::from_fn(|i| self.index(i).shr(rhs.index(i)))
            }
        }
    }
}

impl<const N: usize, T: Scalar + Shr<Output = T>, S: Simdness> Shr<Vector<N, T, S>>
    for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn shr(self, rhs: Vector<N, T, S>) -> Self::Output {
        (*self).shr(rhs)
    }
}

impl<const N: usize, T: Scalar + Shr<Output = T>, S: Simdness> Shr<&Self> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn shr(self, rhs: &Self) -> Self::Output {
        self.shr(*rhs)
    }
}

impl<const N: usize, T: Scalar + Shr<Output = T>, S: Simdness> Shr for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn shr(self, rhs: Self) -> Self::Output {
        (*self).shr(*rhs)
    }
}

impl<const N: usize, T: Scalar + Shr<Output = T>, S: Simdness> ShrAssign for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn shr_assign(&mut self, rhs: Self) {
        *self = (*self).shr(rhs);
    }
}

impl<const N: usize, T: Scalar + Shr<Output = T>, S: Simdness> ShrAssign<&Self> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn shr_assign(&mut self, rhs: &Self) {
        self.shr_assign(*rhs);
    }
}

impl<const N: usize, T: Scalar + Shr<Output = T>, S: Simdness> Shr<T> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn shr(self, rhs: T) -> Self::Output {
        self.shr(Self::splat(rhs))
    }
}

impl<const N: usize, T: Scalar + Shr<Output = T>, S: Simdness> Shr<T> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn shr(self, rhs: T) -> Self::Output {
        (*self).shr(rhs)
    }
}

impl<const N: usize, T: Scalar + Shr<Output = T>, S: Simdness> ShrAssign<T> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn shr_assign(&mut self, rhs: T) {
        *self = (*self).shr(rhs);
    }
}

impl<const N: usize, T: Scalar + BitAnd<Output = T>, S: Simdness> BitAnd for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn bitand(self, rhs: Self) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>, rhs: Vector<N, T, S>) -> Vector<N, T, S>:

            for (Vector<N, T, Simd>, Vector<N, T, Simd>) -> Vector<N, T, Simd> {
                |vec, rhs| T::vec_bitand(vec, rhs)
            } else {
                Vector::from_fn(|i| self.index(i).bitand(rhs.index(i)))
            }
        }
    }
}

impl<const N: usize, T: Scalar + BitAnd<Output = T>, S: Simdness> BitAnd<Vector<N, T, S>>
    for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn bitand(self, rhs: Vector<N, T, S>) -> Self::Output {
        (*self).bitand(rhs)
    }
}

impl<const N: usize, T: Scalar + BitAnd<Output = T>, S: Simdness> BitAnd<&Self> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn bitand(self, rhs: &Self) -> Self::Output {
        self.bitand(*rhs)
    }
}

impl<const N: usize, T: Scalar + BitAnd<Output = T>, S: Simdness> BitAnd for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn bitand(self, rhs: Self) -> Self::Output {
        (*self).bitand(*rhs)
    }
}

impl<const N: usize, T: Scalar + BitAnd<Output = T>, S: Simdness> BitAndAssign for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: Self) {
        *self = (*self).bitand(rhs);
    }
}

impl<const N: usize, T: Scalar + BitAnd<Output = T>, S: Simdness> BitAndAssign<&Self>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: &Self) {
        self.bitand_assign(*rhs);
    }
}

impl<const N: usize, T: Scalar + BitAnd<Output = T>, S: Simdness> BitAnd<T> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn bitand(self, rhs: T) -> Self::Output {
        self.bitand(Self::splat(rhs))
    }
}

impl<const N: usize, T: Scalar + BitAnd<Output = T>, S: Simdness> BitAnd<T> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn bitand(self, rhs: T) -> Self::Output {
        (*self).bitand(rhs)
    }
}

impl<const N: usize, T: Scalar + BitAnd<Output = T>, S: Simdness> BitAndAssign<T>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: T) {
        *self = (*self).bitand(rhs);
    }
}

impl<const N: usize, T: Scalar + BitOr<Output = T>, S: Simdness> BitOr for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn bitor(self, rhs: Self) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>, rhs: Vector<N, T, S>) -> Vector<N, T, S>:

            for (Vector<N, T, Simd>, Vector<N, T, Simd>) -> Vector<N, T, Simd> {
                |vec, rhs| T::vec_bitor(vec, rhs)
            } else {
                Vector::from_fn(|i| self.index(i).bitor(rhs.index(i)))
            }
        }
    }
}

impl<const N: usize, T: Scalar + BitOr<Output = T>, S: Simdness> BitOr<Vector<N, T, S>>
    for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn bitor(self, rhs: Vector<N, T, S>) -> Self::Output {
        (*self).bitor(rhs)
    }
}

impl<const N: usize, T: Scalar + BitOr<Output = T>, S: Simdness> BitOr<&Self> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn bitor(self, rhs: &Self) -> Self::Output {
        self.bitor(*rhs)
    }
}

impl<const N: usize, T: Scalar + BitOr<Output = T>, S: Simdness> BitOr for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn bitor(self, rhs: Self) -> Self::Output {
        (*self).bitor(*rhs)
    }
}

impl<const N: usize, T: Scalar + BitOr<Output = T>, S: Simdness> BitOrAssign for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: Self) {
        *self = (*self).bitor(rhs);
    }
}

impl<const N: usize, T: Scalar + BitOr<Output = T>, S: Simdness> BitOrAssign<&Self>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: &Self) {
        self.bitor_assign(*rhs);
    }
}

impl<const N: usize, T: Scalar + BitOr<Output = T>, S: Simdness> BitOr<T> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn bitor(self, rhs: T) -> Self::Output {
        self.bitor(Self::splat(rhs))
    }
}

impl<const N: usize, T: Scalar + BitOr<Output = T>, S: Simdness> BitOr<T> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn bitor(self, rhs: T) -> Self::Output {
        (*self).bitor(rhs)
    }
}

impl<const N: usize, T: Scalar + BitOr<Output = T>, S: Simdness> BitOrAssign<T> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: T) {
        *self = (*self).bitor(rhs);
    }
}

impl<const N: usize, T: Scalar + BitXor<Output = T>, S: Simdness> BitXor for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn bitxor(self, rhs: Self) -> Self::Output {
        specialize! {
            (self: Vector<N, T, S>, rhs: Vector<N, T, S>) -> Vector<N, T, S>:

            for (Vector<N, T, Simd>, Vector<N, T, Simd>) -> Vector<N, T, Simd> {
                |vec, rhs| T::vec_bitxor(vec, rhs)
            } else {
                Vector::from_fn(|i| self.index(i).bitxor(rhs.index(i)))
            }
        }
    }
}

impl<const N: usize, T: Scalar + BitXor<Output = T>, S: Simdness> BitXor<Vector<N, T, S>>
    for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn bitxor(self, rhs: Vector<N, T, S>) -> Self::Output {
        (*self).bitxor(rhs)
    }
}

impl<const N: usize, T: Scalar + BitXor<Output = T>, S: Simdness> BitXor<&Self> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn bitxor(self, rhs: &Self) -> Self::Output {
        self.bitxor(*rhs)
    }
}

impl<const N: usize, T: Scalar + BitXor<Output = T>, S: Simdness> BitXor for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn bitxor(self, rhs: Self) -> Self::Output {
        (*self).bitxor(*rhs)
    }
}

impl<const N: usize, T: Scalar + BitXor<Output = T>, S: Simdness> BitXorAssign for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = (*self).bitxor(rhs);
    }
}

impl<const N: usize, T: Scalar + BitXor<Output = T>, S: Simdness> BitXorAssign<&Self>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: &Self) {
        self.bitxor_assign(*rhs);
    }
}

impl<const N: usize, T: Scalar + BitXor<Output = T>, S: Simdness> BitXor<T> for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Self;

    #[inline(always)]
    fn bitxor(self, rhs: T) -> Self::Output {
        self.bitxor(Self::splat(rhs))
    }
}

impl<const N: usize, T: Scalar + BitXor<Output = T>, S: Simdness> BitXor<T> for &Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T, S>;

    #[inline(always)]
    fn bitxor(self, rhs: T) -> Self::Output {
        (*self).bitxor(rhs)
    }
}

impl<const N: usize, T: Scalar + BitXor<Output = T>, S: Simdness> BitXorAssign<T>
    for Vector<N, T, S>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: T) {
        *self = (*self).bitxor(rhs);
    }
}
