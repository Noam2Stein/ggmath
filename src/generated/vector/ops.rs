// This file is automatically generated.
// To edit this file edit the codegen crate instead.

use core::ops::*;

use crate::{Scalar, Usize, VecAlignment, VecLen, Vector};

impl<const N: usize, T: Scalar + Neg<Output: Scalar>, A: VecAlignment> Neg for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn neg(self) -> Vector<N, T::Output, A> {
        self.map(|x| x.neg())
    }
}

impl<const N: usize, T: Scalar + Neg<Output: Scalar>, A: VecAlignment> Neg for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn neg(self) -> Vector<N, T::Output, A> {
        self.map(|x| x.neg())
    }
}

impl<const N: usize, T: Scalar + Not<Output: Scalar>, A: VecAlignment> Not for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn not(self) -> Vector<N, T::Output, A> {
        self.map(|x| x.not())
    }
}

impl<const N: usize, T: Scalar + Not<Output: Scalar>, A: VecAlignment> Not for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn not(self) -> Vector<N, T::Output, A> {
        self.map(|x| x.not())
    }
}

impl<
    const N: usize,
    T: Scalar + Add<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Add<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn add(self, rhs: Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        Vector::from_fn(|i| self[i].add(rhs[i]))
    }
}

impl<
    const N: usize,
    T: Scalar + Add<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Add<Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn add(self, rhs: Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        Vector::from_fn(|i| self[i].add(rhs[i]))
    }
}

impl<
    const N: usize,
    T: Scalar + Add<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Add<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn add(self, rhs: &Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        self.add(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Add<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Add<&Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn add(self, rhs: &Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        (*self).add(*rhs)
    }
}

impl<const N: usize, T: Scalar + AddAssign<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    AddAssign<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn add_assign(&mut self, rhs: Vector<N, T2, A2>) {
        for i in 0..N {
            self[i].add_assign(rhs[i]);
        }
    }
}

impl<const N: usize, T: Scalar + AddAssign<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    AddAssign<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn add_assign(&mut self, rhs: &Vector<N, T2, A2>) {
        self.add_assign(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Sub<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Sub<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn sub(self, rhs: Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        Vector::from_fn(|i| self[i].sub(rhs[i]))
    }
}

impl<
    const N: usize,
    T: Scalar + Sub<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Sub<Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn sub(self, rhs: Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        Vector::from_fn(|i| self[i].sub(rhs[i]))
    }
}

impl<
    const N: usize,
    T: Scalar + Sub<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Sub<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn sub(self, rhs: &Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        self.sub(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Sub<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Sub<&Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn sub(self, rhs: &Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        (*self).sub(*rhs)
    }
}

impl<const N: usize, T: Scalar + SubAssign<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    SubAssign<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn sub_assign(&mut self, rhs: Vector<N, T2, A2>) {
        for i in 0..N {
            self[i].sub_assign(rhs[i]);
        }
    }
}

impl<const N: usize, T: Scalar + SubAssign<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    SubAssign<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn sub_assign(&mut self, rhs: &Vector<N, T2, A2>) {
        self.sub_assign(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Mul<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Mul<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn mul(self, rhs: Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        Vector::from_fn(|i| self[i].mul(rhs[i]))
    }
}

impl<
    const N: usize,
    T: Scalar + Mul<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Mul<Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn mul(self, rhs: Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        Vector::from_fn(|i| self[i].mul(rhs[i]))
    }
}

impl<
    const N: usize,
    T: Scalar + Mul<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Mul<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn mul(self, rhs: &Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        self.mul(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Mul<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Mul<&Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn mul(self, rhs: &Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        (*self).mul(*rhs)
    }
}

impl<const N: usize, T: Scalar + MulAssign<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    MulAssign<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn mul_assign(&mut self, rhs: Vector<N, T2, A2>) {
        for i in 0..N {
            self[i].mul_assign(rhs[i]);
        }
    }
}

impl<const N: usize, T: Scalar + MulAssign<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    MulAssign<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn mul_assign(&mut self, rhs: &Vector<N, T2, A2>) {
        self.mul_assign(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Div<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Div<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn div(self, rhs: Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        Vector::from_fn(|i| self[i].div(rhs[i]))
    }
}

impl<
    const N: usize,
    T: Scalar + Div<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Div<Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn div(self, rhs: Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        Vector::from_fn(|i| self[i].div(rhs[i]))
    }
}

impl<
    const N: usize,
    T: Scalar + Div<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Div<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn div(self, rhs: &Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        self.div(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Div<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Div<&Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn div(self, rhs: &Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        (*self).div(*rhs)
    }
}

impl<const N: usize, T: Scalar + DivAssign<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    DivAssign<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn div_assign(&mut self, rhs: Vector<N, T2, A2>) {
        for i in 0..N {
            self[i].div_assign(rhs[i]);
        }
    }
}

impl<const N: usize, T: Scalar + DivAssign<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    DivAssign<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn div_assign(&mut self, rhs: &Vector<N, T2, A2>) {
        self.div_assign(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Rem<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Rem<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn rem(self, rhs: Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        Vector::from_fn(|i| self[i].rem(rhs[i]))
    }
}

impl<
    const N: usize,
    T: Scalar + Rem<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Rem<Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn rem(self, rhs: Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        Vector::from_fn(|i| self[i].rem(rhs[i]))
    }
}

impl<
    const N: usize,
    T: Scalar + Rem<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Rem<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn rem(self, rhs: &Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        self.rem(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Rem<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Rem<&Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn rem(self, rhs: &Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        (*self).rem(*rhs)
    }
}

impl<const N: usize, T: Scalar + RemAssign<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    RemAssign<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn rem_assign(&mut self, rhs: Vector<N, T2, A2>) {
        for i in 0..N {
            self[i].rem_assign(rhs[i]);
        }
    }
}

impl<const N: usize, T: Scalar + RemAssign<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    RemAssign<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn rem_assign(&mut self, rhs: &Vector<N, T2, A2>) {
        self.rem_assign(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Shl<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Shl<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn shl(self, rhs: Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        Vector::from_fn(|i| self[i].shl(rhs[i]))
    }
}

impl<
    const N: usize,
    T: Scalar + Shl<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Shl<Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn shl(self, rhs: Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        Vector::from_fn(|i| self[i].shl(rhs[i]))
    }
}

impl<
    const N: usize,
    T: Scalar + Shl<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Shl<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn shl(self, rhs: &Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        self.shl(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Shl<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Shl<&Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn shl(self, rhs: &Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        (*self).shl(*rhs)
    }
}

impl<const N: usize, T: Scalar + ShlAssign<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    ShlAssign<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn shl_assign(&mut self, rhs: Vector<N, T2, A2>) {
        for i in 0..N {
            self[i].shl_assign(rhs[i]);
        }
    }
}

impl<const N: usize, T: Scalar + ShlAssign<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    ShlAssign<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn shl_assign(&mut self, rhs: &Vector<N, T2, A2>) {
        self.shl_assign(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Shr<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Shr<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn shr(self, rhs: Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        Vector::from_fn(|i| self[i].shr(rhs[i]))
    }
}

impl<
    const N: usize,
    T: Scalar + Shr<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Shr<Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn shr(self, rhs: Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        Vector::from_fn(|i| self[i].shr(rhs[i]))
    }
}

impl<
    const N: usize,
    T: Scalar + Shr<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Shr<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn shr(self, rhs: &Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        self.shr(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + Shr<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> Shr<&Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn shr(self, rhs: &Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        (*self).shr(*rhs)
    }
}

impl<const N: usize, T: Scalar + ShrAssign<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    ShrAssign<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn shr_assign(&mut self, rhs: Vector<N, T2, A2>) {
        for i in 0..N {
            self[i].shr_assign(rhs[i]);
        }
    }
}

impl<const N: usize, T: Scalar + ShrAssign<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    ShrAssign<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn shr_assign(&mut self, rhs: &Vector<N, T2, A2>) {
        self.shr_assign(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + BitAnd<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitAnd<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitand(self, rhs: Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        Vector::from_fn(|i| self[i].bitand(rhs[i]))
    }
}

impl<
    const N: usize,
    T: Scalar + BitAnd<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitAnd<Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitand(self, rhs: Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        Vector::from_fn(|i| self[i].bitand(rhs[i]))
    }
}

impl<
    const N: usize,
    T: Scalar + BitAnd<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitAnd<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitand(self, rhs: &Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        self.bitand(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + BitAnd<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitAnd<&Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitand(self, rhs: &Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        (*self).bitand(*rhs)
    }
}

impl<const N: usize, T: Scalar + BitAndAssign<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    BitAndAssign<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: Vector<N, T2, A2>) {
        for i in 0..N {
            self[i].bitand_assign(rhs[i]);
        }
    }
}

impl<const N: usize, T: Scalar + BitAndAssign<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    BitAndAssign<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: &Vector<N, T2, A2>) {
        self.bitand_assign(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + BitOr<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitOr<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitor(self, rhs: Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        Vector::from_fn(|i| self[i].bitor(rhs[i]))
    }
}

impl<
    const N: usize,
    T: Scalar + BitOr<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitOr<Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitor(self, rhs: Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        Vector::from_fn(|i| self[i].bitor(rhs[i]))
    }
}

impl<
    const N: usize,
    T: Scalar + BitOr<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitOr<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitor(self, rhs: &Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        self.bitor(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + BitOr<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitOr<&Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitor(self, rhs: &Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        (*self).bitor(*rhs)
    }
}

impl<const N: usize, T: Scalar + BitOrAssign<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    BitOrAssign<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: Vector<N, T2, A2>) {
        for i in 0..N {
            self[i].bitor_assign(rhs[i]);
        }
    }
}

impl<const N: usize, T: Scalar + BitOrAssign<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    BitOrAssign<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: &Vector<N, T2, A2>) {
        self.bitor_assign(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + BitXor<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitXor<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitxor(self, rhs: Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        Vector::from_fn(|i| self[i].bitxor(rhs[i]))
    }
}

impl<
    const N: usize,
    T: Scalar + BitXor<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitXor<Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitxor(self, rhs: Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        Vector::from_fn(|i| self[i].bitxor(rhs[i]))
    }
}

impl<
    const N: usize,
    T: Scalar + BitXor<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitXor<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitxor(self, rhs: &Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        self.bitxor(*rhs)
    }
}

impl<
    const N: usize,
    T: Scalar + BitXor<T2, Output: Scalar>,
    A: VecAlignment,
    T2: Scalar,
    A2: VecAlignment,
> BitXor<&Vector<N, T2, A2>> for &Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    type Output = Vector<N, T::Output, A>;

    #[inline(always)]
    fn bitxor(self, rhs: &Vector<N, T2, A2>) -> Vector<N, T::Output, A> {
        (*self).bitxor(*rhs)
    }
}

impl<const N: usize, T: Scalar + BitXorAssign<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    BitXorAssign<Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: Vector<N, T2, A2>) {
        for i in 0..N {
            self[i].bitxor_assign(rhs[i]);
        }
    }
}

impl<const N: usize, T: Scalar + BitXorAssign<T2>, A: VecAlignment, T2: Scalar, A2: VecAlignment>
    BitXorAssign<&Vector<N, T2, A2>> for Vector<N, T, A>
where
    Usize<N>: VecLen,
{
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: &Vector<N, T2, A2>) {
        self.bitxor_assign(*rhs)
    }
}
