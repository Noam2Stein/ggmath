// This file is automatically generated.
// To edit this file edit the codegen crate instead.

use crate::{Usize, vector::*};

impl<const N: usize, A: VecAlignment> Vector<N, f32, A>
where
    Usize<N>: VecLen,
{
    // The following items are generated for all number types

    /// A vector of all minimum values.
    pub const MIN: Self = Self::const_splat(f32::MIN);
    /// A vector of all maximum values.
    pub const MAX: Self = Self::const_splat(f32::MAX);

    /// Converts `self` to a vector of `f64` elements.
    #[inline(always)]
    pub fn as_f64(self) -> Vector<N, f64, A> {
        self.map(|x| x as f64)
    }

    /// Converts `self` to a vector of `i8` elements.
    #[inline(always)]
    pub fn as_i8(self) -> Vector<N, i8, A> {
        self.map(|x| x as i8)
    }

    /// Converts `self` to a vector of `i16` elements.
    #[inline(always)]
    pub fn as_i16(self) -> Vector<N, i16, A> {
        self.map(|x| x as i16)
    }

    /// Converts `self` to a vector of `i32` elements.
    #[inline(always)]
    pub fn as_i32(self) -> Vector<N, i32, A> {
        self.map(|x| x as i32)
    }

    /// Converts `self` to a vector of `i64` elements.
    #[inline(always)]
    pub fn as_i64(self) -> Vector<N, i64, A> {
        self.map(|x| x as i64)
    }

    /// Converts `self` to a vector of `i128` elements.
    #[inline(always)]
    pub fn as_i128(self) -> Vector<N, i128, A> {
        self.map(|x| x as i128)
    }

    /// Converts `self` to a vector of `isize` elements.
    #[inline(always)]
    pub fn as_isize(self) -> Vector<N, isize, A> {
        self.map(|x| x as isize)
    }

    /// Converts `self` to a vector of `u8` elements.
    #[inline(always)]
    pub fn as_u8(self) -> Vector<N, u8, A> {
        self.map(|x| x as u8)
    }

    /// Converts `self` to a vector of `u16` elements.
    #[inline(always)]
    pub fn as_u16(self) -> Vector<N, u16, A> {
        self.map(|x| x as u16)
    }

    /// Converts `self` to a vector of `u32` elements.
    #[inline(always)]
    pub fn as_u32(self) -> Vector<N, u32, A> {
        self.map(|x| x as u32)
    }

    /// Converts `self` to a vector of `u64` elements.
    #[inline(always)]
    pub fn as_u64(self) -> Vector<N, u64, A> {
        self.map(|x| x as u64)
    }

    /// Converts `self` to a vector of `u128` elements.
    #[inline(always)]
    pub fn as_u128(self) -> Vector<N, u128, A> {
        self.map(|x| x as u128)
    }

    /// Converts `self` to a vector of `usize` elements.
    #[inline(always)]
    pub fn as_usize(self) -> Vector<N, usize, A> {
        self.map(|x| x as usize)
    }

    // The following items are generated for all signed number types

    /// Returns a vector containing the absolute value of each element of `self`.
    #[inline(always)]
    pub fn abs(self) -> Self {
        self.map(|x| x.abs())
    }

    // The following items are generated for all float types

    /// A vector with all elements set to `NaN`.
    pub const NAN: Self = Self::const_splat(f32::NAN);
    /// A vector with all elements set to `Infinity`.
    pub const INFINITY: Self = Self::const_splat(f32::INFINITY);
    /// A vector with all elements set to `-Infinity`.
    pub const NEG_INFINITY: Self = Self::const_splat(f32::NEG_INFINITY);
    /// A vector with all elements set to `Epsilon`.
    pub const EPSILON: Self = Self::const_splat(f32::EPSILON);

    /// Returns a vector containing the signum of each element of `self`.
    /// Signum for each element is:
    /// - `1.0` if the element is positive or `+0.0`
    /// - `-1.0` if the element is negative `-0.0`
    #[inline(always)]
    pub fn signum(self) -> Self {
        self.map(|x| x.signum())
    }

    /// Returns a vector of bools with `true` for each element that has a negative sign, including `-0.0`.
    #[inline(always)]
    pub fn negative_sign_mask(self) -> Vector<N, bool, A> {
        self.map(|x| x.is_sign_negative())
    }

    /// Returns a vector of bools with `true` for each element that has a positive sign, including `+0.0`.
    #[inline(always)]
    pub fn positive_sign_mask(self) -> Vector<N, bool, A> {
        self.map(|x| x.is_sign_positive())
    }

    /// Returns a vector of bools with `true` for each element that is `NaN`.
    #[inline(always)]
    pub fn nan_mask(self) -> Vector<N, bool, A> {
        self.map(|x| x.is_nan())
    }

    /// Returns a vector of bools with `true` for each element that is finite.
    #[inline(always)]
    pub fn finite_mask(self) -> Vector<N, bool, A> {
        self.map(|x| x.is_finite())
    }

    /// Returns `true` if any element is `NaN`.
    #[inline(always)]
    pub fn is_nan(self) -> bool {
        self.nan_mask().any_true()
    }

    /// Returns `true` if all elements are finite.
    #[inline(always)]
    pub fn is_finite(self) -> bool {
        self.finite_mask().all_true()
    }

    /// Returns a vector with the same direction as `self`, but with a magnitude of `1`.
    #[inline(always)]
    pub fn normalize(self) -> Self {
        #[cfg(debug_assertions)]
        assert!(self.mag_sq() > 0.0, "self must be non-zero");

        self / self.mag()
    }

    /// Returns a vector with the same direction as `self`, but with a magnitude of `1`.
    /// If `self` is zero, `None` is returned.
    #[inline(always)]
    pub fn checked_normalize(self) -> Option<Self> {
        let normalized = self.normalize();
        if normalized.is_finite() {
            Some(normalized)
        } else {
            None
        }
    }

    /// Returns a vector with the same direction as `self`, but with a magnitude of `1`.
    #[inline(always)]
    pub fn normalize_or(self, default: Self) -> Self {
        let normalized = self.normalize();
        if normalized.is_finite() {
            normalized
        } else {
            default
        }
    }

    /// Returns a vector with the same direction as `self`, but with a magnitude of `1`.
    /// If `self` is zero, zero is returned.
    #[inline(always)]
    pub fn normalize_or_zero(self) -> Self {
        self.normalize_or(Self::ZERO)
    }

    /// Linearly interpolates between `self` and `other` based on the interpolation factor `t`,
    /// which is clamped to the range `[0.0, 1.0]`.
    ///
    /// This function uses the "delta lerp" formula which is:
    /// `a + (b - a) * t`
    ///
    /// This formula is more numerically stable and is usually faster than the "weighted lerp" formula:
    /// `a * (1.0 - t) + b * t`
    ///
    /// The other formula can be used by calling `lerp_weighted`.
    /// It is useful when interpolating large values that are very far away from each other.
    #[inline(always)]
    pub fn lerp(self, other: Vector<N, f32, impl VecAlignment>, t: f32) -> Self {
        self.lerp_unclamped(other, t.clamp(0.0, 1.0))
    }

    /// Linearly interpolates between `self` and `other` based on the interpolation factor `t`,
    /// which is clamped to the range `[0.0, 1.0]`.
    ///
    /// This function uses the "weighted lerp" formula which is:
    /// `a * (1.0 - t) + b * t`
    ///
    /// This formula is usually worse than the "delta lerp" formula:
    /// `a + (b - a) * t`
    ///
    /// This "weighted" formula is useful when interpolating large values that are very far away from each other.
    #[inline(always)]
    pub fn lerp_weighted(self, other: Vector<N, f32, impl VecAlignment>, t: f32) -> Self {
        self.lerp_unclamped_weighted(other, t.clamp(0.0, 1.0))
    }

    /// Linearly interpolates between `self` and `other` based on the interpolation factor `t`.
    /// If `t` is outside the range `[0.0, 1.0]`, the result is linearly extrapolated.
    ///
    /// This function uses the "delta lerp" formula which is:
    /// `a + (b - a) * t`
    ///
    /// This formula is more numerically stable and is usually faster than the "weighted lerp" formula:
    #[inline(always)]
    pub fn lerp_unclamped(self, other: Vector<N, f32, impl VecAlignment>, t: f32) -> Self {
        self + (other - self) * t
    }

    /// This "weighted" formula is useful when interpolating large values that are very far away from each other.
    #[inline(always)]
    pub fn lerp_unclamped_weighted(self, other: Vector<N, f32, impl VecAlignment>, t: f32) -> Self {
        self * (1.0 - t) + other * t
    }

    /// Moves `self` towards `target` by at most `max_delta`.
    #[inline(always)]
    pub fn move_towards(self, target: Vector<N, f32, impl VecAlignment>, max_delta: f32) -> Self {
        let delta = target - self;
        let delta_mag = delta.mag();
        if delta_mag <= max_delta || delta_mag <= 1e-4 {
            return target.to_storage();
        }
        self + delta / delta_mag * max_delta
    }

    /// Returns the projection of `self` onto `other`.
    #[inline(always)]
    pub fn project_onto(self, other: Self) -> Self {
        other * self.dot(other) * (1.0 / other.mag_sq())
    }

    /// Returns the projection of `self` onto `other`,
    /// where `other` must be normalized.
    ///
    /// This is faster than `project_onto`.
    #[inline(always)]
    pub fn project_onto_normalized(self, other: Self) -> Self {
        #[cfg(debug_assertions)]
        assert!(other.mag_sq() == 1.0, "other must be normalized");

        other * self.dot(other)
    }

    /// Returns the rejection of `self` from `other`.
    #[inline(always)]
    pub fn reject_from(self, other: Self) -> Self {
        self - self.project_onto(other)
    }

    /// Returns the rejection of `self` from `other`,
    /// where `other` must be normalized.
    ///
    /// This is faster than `reject_from`.
    #[inline(always)]
    pub fn reject_from_normalized(self, other: Self) -> Self {
        #[cfg(debug_assertions)]
        assert!(other.mag_sq() == 1.0, "other must be normalized");

        self - self.project_onto_normalized(other)
    }

    /// Returns the reflection of `self` off of `normal`.
    ///
    /// `normal` must be normalized.
    #[inline(always)]
    pub fn reflect(self, normal: Self) -> Self {
        #[cfg(debug_assertions)]
        assert!(normal.mag_sq() == 1.0, "normal must be normalized");

        self - normal * (2.0 * self.dot(normal))
    }

    /// Returns the refraction of `self` through `normal` for the given ratio of indices of refraction.
    ///
    /// `self` and `normal` must be normalized.
    #[inline(always)]
    pub fn refract(self, normal: Self, eta: f32) -> Self {
        #[cfg(debug_assertions)]
        assert!(self.mag_sq() == 1.0, "self must be normalized");

        #[cfg(debug_assertions)]
        assert!(normal.mag_sq() == 1.0, "normal must be normalized");

        let n_dot_i = normal.dot(self);
        let k = 1.0 - eta * eta * (1.0 - n_dot_i * n_dot_i);
        if k >= 0.0 {
            self * eta - normal * (eta * n_dot_i + k.sqrt())
        } else {
            Self::ZERO
        }
    }
}

impl<const N: usize, A: VecAlignment> Vector<N, f32, A>
where
    Usize<N>: VecLen,
{
    // The following items are generated for all primitive types

    /// Returns `self == other` and supports const contexts.
    #[inline(always)]
    pub const fn const_eq(self, other: Vector<N, f32, impl VecAlignment>) -> bool {
        let mut i = 0;
        while i < N {
            if self.as_array()[i] != other.as_array()[i] {
                return false;
            }
            i += 1;
        }
        true
    }

    /// Returns `self != other` and supports const contexts.
    #[inline(always)]
    pub const fn const_ne(self, other: Vector<N, f32, impl VecAlignment>) -> bool {
        let mut i = 0;
        while i < N {
            if self.as_array()[i] != other.as_array()[i] {
                return true;
            }
            i += 1;
        }
        false
    }

    /// Returns `self.eq_mask(other)` and supports const contexts.
    pub const fn const_eq_mask(
        self,
        other: Vector<N, f32, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] == other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.ne_mask(other)` and supports const contexts.
    pub const fn const_ne_mask(
        self,
        other: Vector<N, f32, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] != other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.lt_mask(other)` and supports const contexts.
    pub const fn const_lt_mask(
        self,
        other: Vector<N, f32, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] < other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.gt_mask(other)` and supports const contexts.
    pub const fn const_gt_mask(
        self,
        other: Vector<N, f32, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] > other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.le_mask(other)` and supports const contexts.
    pub const fn const_le_mask(
        self,
        other: Vector<N, f32, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] <= other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.ge_mask(other)` and supports const contexts.
    pub const fn const_ge_mask(
        self,
        other: Vector<N, f32, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] >= other.as_array()[i];
            i += 1;
        }
        output
    }

    // The following items are generated for all number types

    /// Returns `self + other` and supports const contexts.
    #[inline(always)]
    pub const fn const_add(mut self, other: Vector<N, f32, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] + other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self - other` and supports const contexts.
    #[inline(always)]
    pub const fn const_sub(mut self, other: Vector<N, f32, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] - other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self * other` and supports const contexts.
    #[inline(always)]
    pub const fn const_mul(mut self, other: Vector<N, f32, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] * other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self / other` and supports const contexts.
    #[inline(always)]
    pub const fn const_div(mut self, other: Vector<N, f32, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] / other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self % other` and supports const contexts.
    #[inline(always)]
    pub const fn const_rem(mut self, other: Vector<N, f32, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] % other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self.min(other)` and supports const contexts.
    #[inline(always)]
    pub const fn const_min(mut self, other: Vector<N, f32, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            if other.as_array()[i] < self.as_array()[i] {
                self.as_array_mut()[i] = other.as_array()[i];
            }
            i += 1;
        }
        self
    }

    /// Returns `self.max(other)` and supports const contexts.
    #[inline(always)]
    pub const fn const_max(mut self, other: Vector<N, f32, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            if other.as_array()[i] > self.as_array()[i] {
                self.as_array_mut()[i] = other.as_array()[i];
            }
            i += 1;
        }
        self
    }

    /// Returns `self.clamp(min, max)` and supports const contexts.
    #[inline(always)]
    pub const fn const_clamp(
        self,
        min: Vector<N, f32, impl VecAlignment>,
        max: Vector<N, f32, impl VecAlignment>,
    ) -> Self {
        #[cfg(debug_assertions)]
        assert!(
            min.const_le_mask(max).const_all_true(),
            "min must be less than or equal to max"
        );

        self.const_min(max).const_max(min)
    }

    /// Returns `self.sum()` and supports const contexts.
    #[inline(always)]
    pub const fn const_sum(self) -> f32 {
        let mut output = 0 as f32;
        let mut i = 0;
        while i < N {
            output += self.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.product()` and supports const contexts.
    #[inline(always)]
    pub const fn const_product(self) -> f32 {
        let mut output = 1 as f32;
        let mut i = 0;
        while i < N {
            output *= self.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.dot(other)` and supports const contexts.
    #[inline(always)]
    pub const fn const_dot(self, other: Vector<N, f32, impl VecAlignment>) -> f32 {
        let mut output = 0 as f32;
        let mut i = 0;
        while i < N {
            output += self.as_array()[i] * other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.mag_sq()` and supports const contexts.
    #[inline(always)]
    pub const fn const_mag_sq(self) -> f32 {
        let mut output = 0 as f32;
        let mut i = 0;
        while i < N {
            output += self.as_array()[i] * self.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.distance_sq(other)` and supports const contexts.
    #[inline(always)]
    pub const fn const_distance_sq(self, other: Vector<N, f32, impl VecAlignment>) -> f32 {
        self.const_abs_diff(other).const_mag_sq()
    }

    /// Version of `Vector::as_f64` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_f64(self) -> Vector<N, f64, A> {
        let mut output = Vector::<N, f64, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as f64;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i8` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i8(self) -> Vector<N, i8, A> {
        let mut output = Vector::<N, i8, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i8;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i16` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i16(self) -> Vector<N, i16, A> {
        let mut output = Vector::<N, i16, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i16;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i32` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i32(self) -> Vector<N, i32, A> {
        let mut output = Vector::<N, i32, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i32;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i64` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i64(self) -> Vector<N, i64, A> {
        let mut output = Vector::<N, i64, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i64;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i128` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i128(self) -> Vector<N, i128, A> {
        let mut output = Vector::<N, i128, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i128;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_isize` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_isize(self) -> Vector<N, isize, A> {
        let mut output = Vector::<N, isize, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as isize;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_u8` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_u8(self) -> Vector<N, u8, A> {
        let mut output = Vector::<N, u8, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as u8;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_u16` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_u16(self) -> Vector<N, u16, A> {
        let mut output = Vector::<N, u16, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as u16;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_u32` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_u32(self) -> Vector<N, u32, A> {
        let mut output = Vector::<N, u32, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as u32;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_u64` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_u64(self) -> Vector<N, u64, A> {
        let mut output = Vector::<N, u64, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as u64;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_u128` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_u128(self) -> Vector<N, u128, A> {
        let mut output = Vector::<N, u128, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as u128;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_usize` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_usize(self) -> Vector<N, usize, A> {
        let mut output = Vector::<N, usize, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as usize;
            i += 1;
        }
        output
    }

    // The following items are generated for all signed number types

    /// Returns `-self` and supports const contexts.
    #[inline(always)]
    pub const fn const_neg(mut self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = -self.as_array()[i];
            i += 1;
        }

        self
    }

    /// Version of `Vector::abs` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_abs(mut self) -> Self {
        let mut i = 0;

        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].abs();
            i += 1;
        }

        self
    }

    /// Version of `Vector::signum` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_signum(mut self) -> Self {
        let mut i = 0;

        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].signum();
            i += 1;
        }

        self
    }

    // The following items are generated for all float types

    /// Returns `self.abs_diff(other)` and supports const contexts.
    #[inline(always)]
    pub const fn const_abs_diff(self, other: Vector<N, f32, impl VecAlignment>) -> Self {
        self.const_sub(other).const_abs()
    }

    /// Version of `Vector::negative_sign_mask` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_negative_sign_mask(self) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);

        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i].is_sign_negative();
            i += 1;
        }

        output
    }

    /// Version of `Vector::positive_sign_mask` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_positive_sign_mask(self) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);

        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i].is_sign_positive();
            i += 1;
        }

        output
    }

    /// Version of `Vector::nan_mask` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_nan_mask(self) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);

        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i].is_nan();
            i += 1;
        }

        output
    }

    /// Version of `Vector::finite_mask` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_finite_mask(self) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);

        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i].is_finite();
            i += 1;
        }

        output
    }

    /// Version of `Vector::is_nan` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_is_nan(self) -> bool {
        self.const_nan_mask().const_any_true()
    }

    /// Version of `Vector::is_finite` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_is_finite(self) -> bool {
        self.const_finite_mask().const_all_true()
    }

    /// Version of `Vector::lerp` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_lerp(self, other: Vector<N, f32, impl VecAlignment>, t: f32) -> Self {
        self.const_lerp_unclamped(other, t.clamp(0.0, 1.0))
    }

    /// Version of `Vector::lerp_weighted` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_lerp_weighted(
        self,
        other: Vector<N, f32, impl VecAlignment>,
        t: f32,
    ) -> Self {
        self.const_lerp_unclamped_weighted(other, t.clamp(0.0, 1.0))
    }

    /// Version of `Vector::lerp_unclamped` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_lerp_unclamped(
        self,
        other: Vector<N, f32, impl VecAlignment>,
        t: f32,
    ) -> Self {
        self.const_add(other.const_sub(self).const_mul(Self::const_splat(t)))
    }

    /// Version of `Vector::lerp_unclamped_weighted` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_lerp_unclamped_weighted(
        self,
        other: Vector<N, f32, impl VecAlignment>,
        t: f32,
    ) -> Self {
        self.const_mul(Self::const_splat(1.0 - t))
            .const_add(other.const_mul(Self::const_splat(t)))
    }

    /// Version of `Vector::project_onto` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_project_onto(self, other: Vector<N, f32, impl VecAlignment>) -> Self {
        other
            .to_storage::<A>()
            .const_mul(Self::const_splat(self.const_dot(other)))
            .const_mul(Self::const_splat(1.0 / other.const_mag_sq()))
    }

    /// Version of `Vector::project_onto_normalized` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_project_onto_normalized(
        self,
        other: Vector<N, f32, impl VecAlignment>,
    ) -> Self {
        #[cfg(debug_assertions)]
        assert!(other.const_mag_sq() == 1.0, "other must be normalized");

        other
            .to_storage::<A>()
            .const_mul(Self::const_splat(self.const_dot(other)))
    }

    /// Version of `Vector::reject_from` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_reject_from(self, other: Vector<N, f32, impl VecAlignment>) -> Self {
        self.const_sub(self.const_project_onto(other))
    }

    /// Version of `Vector::reject_from_normalized` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_reject_from_normalized(
        self,
        other: Vector<N, f32, impl VecAlignment>,
    ) -> Self {
        #[cfg(debug_assertions)]
        assert!(other.const_mag_sq() == 1.0, "other must be normalized");

        self.const_sub(self.const_project_onto_normalized(other))
    }

    /// Version of `Vector::reflect` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_reflect(self, normal: Vector<N, f32, impl VecAlignment>) -> Self {
        #[cfg(debug_assertions)]
        assert!(normal.const_mag_sq() == 1.0, "normal must be normalized");

        self.const_sub(
            normal
                .to_storage::<A>()
                .const_mul(Self::const_splat(2.0 * self.const_dot(normal))),
        )
    }
}

impl<const N: usize, A: VecAlignment> Vector<N, f32, A>
where
    Usize<N>: VecLen,
{
    // The following items are generated for all float types

    /// Returns a vector containing the square root of each element of `self`.
    #[inline(always)]
    pub fn sqrt(self) -> Self {
        self.map(|x| x.sqrt())
    }

    /// Returns a vector containing the rounded value of each element of `self`.
    #[inline(always)]
    pub fn round(self) -> Self {
        self.map(|x| x.round())
    }

    /// Returns a vector containing the floor value of each element of `self`.
    #[inline(always)]
    pub fn floor(self) -> Self {
        self.map(|x| x.floor())
    }

    /// Returns a vector containing the ceiling value of each element of `self`.
    #[inline(always)]
    pub fn ceil(self) -> Self {
        self.map(|x| x.ceil())
    }

    /// Returns a vector containing the truncated value of each element of `self`.
    #[inline(always)]
    pub fn trunc(self) -> Self {
        self.map(|x| x.trunc())
    }

    /// Returns a vector containing the fractional part of each element of `self` as `self - self.trunc()`.
    #[inline(always)]
    pub fn fract(self) -> Self {
        self.map(|x| x.fract())
    }

    /// Returns a vector containing the sine of each element of `self`.
    #[inline(always)]
    pub fn sin(self) -> Self {
        self.map(|x| x.sin())
    }

    /// Returns a vector containing the cosine of each element of `self`.
    #[inline(always)]
    pub fn cos(self) -> Self {
        self.map(|x| x.cos())
    }

    /// Returns a vector containing the tangent of each element of `self`.
    #[inline(always)]
    pub fn tan(self) -> Self {
        self.map(|x| x.tan())
    }

    /// Returns a vector containing the arcsine of each element of `self`.
    #[inline(always)]
    pub fn asin(self) -> Self {
        self.map(|x| x.asin())
    }

    /// Returns a vector containing the arccosine of each element of `self`.
    #[inline(always)]
    pub fn acos(self) -> Self {
        self.map(|x| x.acos())
    }

    /// Returns a vector containing the arctangent of each element of `self`.
    #[inline(always)]
    pub fn atan(self) -> Self {
        self.map(|x| x.atan())
    }

    /// Returns a vector containing the hyperbolic sine of each element of `self`.
    #[inline(always)]
    pub fn sinh(self) -> Self {
        self.map(|x| x.sinh())
    }

    /// Returns a vector containing the hyperbolic cosine of each element of `self`.
    #[inline(always)]
    pub fn cosh(self) -> Self {
        self.map(|x| x.cosh())
    }

    /// Returns a vector containing the hyperbolic tangent of each element of `self`.
    #[inline(always)]
    pub fn tanh(self) -> Self {
        self.map(|x| x.tanh())
    }

    /// Returns a vector containing the hyperbolic arclength sine of each element of `self`.
    #[inline(always)]
    pub fn asinh(self) -> Self {
        self.map(|x| x.asinh())
    }

    /// Returns a vector containing the hyperbolic arclength cosine of each element of `self`.
    #[inline(always)]
    pub fn acosh(self) -> Self {
        self.map(|x| x.acosh())
    }

    /// Returns a vector containing the hyperbolic arclength tangent of each element of `self`.
    #[inline(always)]
    pub fn atanh(self) -> Self {
        self.map(|x| x.atanh())
    }

    /// Returns the magnitude of `self`.
    #[inline(always)]
    pub fn mag(self) -> f32 {
        self.mag_sq().sqrt()
    }

    /// Returns the Euclidean distance between `self` and `other`.
    #[inline(always)]
    pub fn distance(self, other: Self) -> f32 {
        self.distance_sq(other).sqrt()
    }
}

impl ScalarZero for f32 {
    const ZERO: f32 = 0 as Self;
}

impl ScalarOne for f32 {
    const ONE: f32 = 1 as Self;
}

impl ScalarNegOne for f32 {
    const NEG_ONE: f32 = -1 as Self;
}

#[cfg(test)]
mod tests {
    use crate::*;

    // These tests are generated for all primitive types

    #[test]
    fn test_array_aligned() {
        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).to_array(),
            [1.0, 2.0]
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).to_array(),
            [3.0, 4.0, 1.0]
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]).to_array(),
            [2.0, 3.0, 4.0, 1.0]
        );

        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).as_array(),
            &[1.0, 2.0]
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).as_array(),
            &[3.0, 4.0, 1.0]
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]).as_array(),
            &[2.0, 3.0, 4.0, 1.0]
        );

        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).as_array_mut(),
            &mut [1.0, 2.0]
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).as_array_mut(),
            &mut [3.0, 4.0, 1.0]
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]).as_array_mut(),
            &mut [2.0, 3.0, 4.0, 1.0]
        );

        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).as_ptr(),
            [1.0, 2.0].as_ptr()
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).as_ptr(),
            [3.0, 4.0, 1.0].as_ptr()
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]).as_ptr(),
            [2.0, 3.0, 4.0, 1.0].as_ptr()
        );

        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).as_mut_ptr(),
            [1.0, 2.0].as_mut_ptr()
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).as_mut_ptr(),
            [3.0, 4.0, 1.0].as_mut_ptr()
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]).as_mut_ptr(),
            [2.0, 3.0, 4.0, 1.0].as_mut_ptr()
        );

        assert_eq!(
            Vector::<2, f32, VecAligned>::from_fn(|i| [1.0, 2.0][i]).to_array(),
            [1.0, 2.0]
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_fn(|i| [3.0, 4.0, 1.0][i]).to_array(),
            [3.0, 4.0, 1.0]
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_fn(|i| [2.0, 3.0, 4.0, 1.0][i]).to_array(),
            [2.0, 3.0, 4.0, 1.0]
        );

        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0])
                .map(|x| {
                    let idx = [1.0, 2.0].into_iter().position(|y| y == x).unwrap();
                    [1.0, 2.0][idx]
                })
                .to_array(),
            [1.0, 2.0]
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0])
                .map(|x| {
                    let idx = [3.0, 4.0, 1.0].into_iter().position(|y| y == x).unwrap();
                    [3.0, 4.0, 1.0][idx]
                })
                .to_array(),
            [3.0, 4.0, 1.0]
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0])
                .map(|x| {
                    let idx = [2.0, 3.0, 4.0, 1.0]
                        .into_iter()
                        .position(|y| y == x)
                        .unwrap();
                    [2.0, 3.0, 4.0, 1.0][idx]
                })
                .to_array(),
            [2.0, 3.0, 4.0, 1.0]
        );

        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).fold(|x, y| x + y),
            1.0 + 2.0
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).fold(|x, y| x + y),
            3.0 + 4.0 + 1.0
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]).fold(|x, y| x + y),
            2.0 + 3.0 + 4.0 + 1.0
        );

        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).all(|x| x == 1.0),
            false
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).all(|x| x == 1.0),
            false
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]).all(|x| x == 1.0),
            false
        );

        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).any(|x| x == 1.0),
            true
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).any(|x| x == 1.0),
            true
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]).any(|x| x == 1.0),
            true
        );

        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).count(|x| x == 1.0),
            1
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).count(|x| x == 1.0),
            1
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]).count(|x| x == 1.0),
            1
        );

        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).len(),
            2
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).len(),
            3
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]).len(),
            4
        );
    }

    #[test]
    fn test_splat_aligned() {
        assert_eq!(
            Vector::<2, f32, VecAligned>::splat(1.0).to_array(),
            [1.0; 2]
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::splat(3.0).to_array(),
            [3.0; 3]
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::splat(2.0).to_array(),
            [2.0; 4]
        );

        assert_eq!(
            Vector::<2, f32, VecAligned>::const_splat(1.0).to_array(),
            [1.0; 2]
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::const_splat(3.0).to_array(),
            [3.0; 3]
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::const_splat(2.0).to_array(),
            [2.0; 4]
        );
    }

    #[test]
    fn test_storage_aligned() {
        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).align(),
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]),
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).align(),
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]).align(),
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]),
        );

        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).pack(),
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]),
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).pack(),
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]).pack(),
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]),
        );

        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).to_storage::<VecAligned>(),
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]),
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).to_storage::<VecAligned>(),
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0])
                .to_storage::<VecAligned>(),
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]),
        );

        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).to_storage::<VecPacked>(),
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]),
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).to_storage::<VecPacked>(),
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0])
                .to_storage::<VecPacked>(),
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]),
        );

        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).is_aligned(),
            true
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).is_aligned(),
            true
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]).is_aligned(),
            true
        );
    }

    #[test]
    fn test_swizzle_aligned() {
        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).x(),
            1.0
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).y(),
            4.0
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]).z(),
            4.0
        );

        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).yy(),
            Vector::<2, f32, VecAligned>::from_array([2.0, 2.0]),
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).zy(),
            Vector::<2, f32, VecAligned>::from_array([1.0, 4.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]).xw(),
            Vector::<2, f32, VecAligned>::from_array([2.0, 1.0]),
        );

        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).xyy(),
            Vector::<3, f32, VecAligned>::from_array([1.0, 2.0, 2.0]),
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).yzy(),
            Vector::<3, f32, VecAligned>::from_array([4.0, 1.0, 4.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]).wxy(),
            Vector::<3, f32, VecAligned>::from_array([1.0, 2.0, 3.0]),
        );

        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).xxyy(),
            Vector::<4, f32, VecAligned>::from_array([1.0, 1.0, 2.0, 2.0]),
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).yzyz(),
            Vector::<4, f32, VecAligned>::from_array([4.0, 1.0, 4.0, 1.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]).wxyw(),
            Vector::<4, f32, VecAligned>::from_array([1.0, 2.0, 3.0, 1.0]),
        );
    }

    #[test]
    fn test_swizzle_ref_aligned() {
        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).x_ref(),
            &1.0
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).y_ref(),
            &4.0
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]).z_ref(),
            &4.0
        );

        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).xy_ref(),
            &Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]),
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([1.0, 2.0, 3.0]).yz_ref(),
            &Vector::<2, f32, VecPacked>::from_array([2.0, 3.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([1.0, 2.0, 3.0, 4.0]).zw_ref(),
            &Vector::<2, f32, VecPacked>::from_array([3.0, 4.0]),
        );

        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([1.0, 2.0, 3.0]).xyz_ref(),
            &Vector::<3, f32, VecPacked>::from_array([1.0, 2.0, 3.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([1.0, 2.0, 3.0, 4.0]).yzw_ref(),
            &Vector::<3, f32, VecPacked>::from_array([2.0, 3.0, 4.0]),
        );

        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([1.0, 2.0, 3.0, 4.0]).xyzw_ref(),
            &Vector::<4, f32, VecPacked>::from_array([1.0, 2.0, 3.0, 4.0]),
        );
    }

    #[test]
    fn test_swizzle_mut_aligned() {
        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).x_mut(),
            &mut 1.0
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).y_mut(),
            &mut 4.0
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]).z_mut(),
            &mut 4.0
        );

        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).x_y_mut(),
            (&mut 1.0, &mut 2.0)
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).xy_z_mut(),
            (
                &mut Vector::<2, f32, VecPacked>::from_array([3.0, 4.0]),
                &mut 1.0
            )
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]).xy_zw_mut(),
            (
                &mut Vector::<2, f32, VecPacked>::from_array([2.0, 3.0]),
                &mut Vector::<2, f32, VecPacked>::from_array([4.0, 1.0]),
            ),
        );
    }

    #[test]
    fn test_swizzle_with_aligned() {
        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).with_x(3.0),
            Vector::<2, f32, VecAligned>::from_array([3.0, 2.0]),
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).with_y(2.0),
            Vector::<3, f32, VecAligned>::from_array([3.0, 2.0, 1.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]).with_z(3.0),
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 3.0, 1.0]),
        );

        assert_eq!(
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]).with_xy(vec2!(3.0, 4.0)),
            Vector::<2, f32, VecAligned>::from_array([3.0, 4.0]),
        );
        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]).with_zy(vec2!(2.0, 3.0)),
            Vector::<3, f32, VecAligned>::from_array([3.0, 3.0, 2.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]).with_xw(vec2!(3.0, 4.0)),
            Vector::<4, f32, VecAligned>::from_array([3.0, 2.0, 3.0, 4.0]),
        );

        assert_eq!(
            Vector::<3, f32, VecAligned>::from_array([1.0, 2.0, 3.0])
                .with_xzy(vec3!(3.0, 4.0, 1.0)),
            Vector::<3, f32, VecAligned>::from_array([3.0, 1.0, 4.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0])
                .with_ywx(vec3!(3.0, 4.0, 1.0)),
            Vector::<4, f32, VecAligned>::from_array([1.0, 3.0, 4.0, 4.0]),
        );

        assert_eq!(
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0])
                .with_xywz(vec4!(3.0, 4.0, 1.0, 2.0)),
            Vector::<4, f32, VecAligned>::from_array([3.0, 4.0, 2.0, 1.0]),
        );
    }

    #[test]
    fn test_swizzle_set_aligned() {
        assert_eq!(
            {
                let mut vector = Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]);
                vector.set_x(3.0);
                vector
            },
            Vector::<2, f32, VecAligned>::from_array([3.0, 2.0]),
        );
        assert_eq!(
            {
                let mut vector = Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]);
                vector.set_y(2.0);
                vector
            },
            Vector::<3, f32, VecAligned>::from_array([3.0, 2.0, 1.0]),
        );
        assert_eq!(
            {
                let mut vector = Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]);
                vector.set_z(3.0);
                vector
            },
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 3.0, 1.0]),
        );

        assert_eq!(
            {
                let mut vector = Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]);
                vector.set_xy(vec2!(3.0, 4.0));
                vector
            },
            Vector::<2, f32, VecAligned>::from_array([3.0, 4.0]),
        );
        assert_eq!(
            {
                let mut vector = Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]);
                vector.set_zy(vec2!(2.0, 3.0));
                vector
            },
            Vector::<3, f32, VecAligned>::from_array([3.0, 3.0, 2.0]),
        );
        assert_eq!(
            {
                let mut vector = Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]);
                vector.set_xw(vec2!(3.0, 4.0));
                vector
            },
            Vector::<4, f32, VecAligned>::from_array([3.0, 2.0, 3.0, 4.0]),
        );

        assert_eq!(
            {
                let mut vector = Vector::<3, f32, VecAligned>::from_array([1.0, 2.0, 3.0]);
                vector.set_xzy(vec3!(3.0, 4.0, 1.0));
                vector
            },
            Vector::<3, f32, VecAligned>::from_array([3.0, 1.0, 4.0]),
        );
        assert_eq!(
            {
                let mut vector = Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]);
                vector.set_ywx(vec3!(3.0, 4.0, 1.0));
                vector
            },
            Vector::<4, f32, VecAligned>::from_array([1.0, 3.0, 4.0, 4.0]),
        );

        assert_eq!(
            {
                let mut vector = Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]);
                vector.set_xywz(vec4!(3.0, 4.0, 1.0, 2.0));
                vector
            },
            Vector::<4, f32, VecAligned>::from_array([3.0, 4.0, 2.0, 1.0]),
        );
    }

    #[test]
    fn test_constructor_aligned() {
        assert_eq!(vec2!(1.0, 2.0).to_array(), [1.0, 2.0]);
        assert_eq!(vec2!(vec2!(1.0, 2.0)).to_array(), [1.0, 2.0]);

        assert_eq!(vec3!(1.0, 2.0, 3.0).to_array(), [1.0, 2.0, 3.0]);
        assert_eq!(vec3!(1.0, vec2!(2.0, 3.0)).to_array(), [1.0, 2.0, 3.0]);
        assert_eq!(vec3!(vec2!(1.0, 2.0), 3.0).to_array(), [1.0, 2.0, 3.0]);
        assert_eq!(vec3!(vec3!(1.0, 2.0, 3.0)).to_array(), [1.0, 2.0, 3.0]);

        assert_eq!(vec4!(1.0, 2.0, 3.0, 4.0).to_array(), [1.0, 2.0, 3.0, 4.0]);
        assert_eq!(
            vec4!(1.0, 2.0, vec2!(3.0, 4.0)).to_array(),
            [1.0, 2.0, 3.0, 4.0]
        );
        assert_eq!(
            vec4!(1.0, vec2!(2.0, 3.0), 4.0).to_array(),
            [1.0, 2.0, 3.0, 4.0]
        );
        assert_eq!(
            vec4!(1.0, vec3!(2.0, 3.0, 4.0)).to_array(),
            [1.0, 2.0, 3.0, 4.0]
        );
        assert_eq!(
            vec4!(vec2!(1.0, 2.0), 3.0, 4.0).to_array(),
            [1.0, 2.0, 3.0, 4.0]
        );
        assert_eq!(
            vec4!(vec2!(1.0, 2.0), vec2!(3.0, 4.0)).to_array(),
            [1.0, 2.0, 3.0, 4.0]
        );
        assert_eq!(
            vec4!(vec3!(1.0, 2.0, 3.0), 4.0).to_array(),
            [1.0, 2.0, 3.0, 4.0]
        );
        assert_eq!(
            vec4!(vec4!(1.0, 2.0, 3.0, 4.0)).to_array(),
            [1.0, 2.0, 3.0, 4.0]
        );
    }

    // These tests are generated for all primitive types

    #[test]
    fn test_array_packed() {
        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).to_array(),
            [1.0, 2.0]
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).to_array(),
            [3.0, 4.0, 1.0]
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]).to_array(),
            [2.0, 3.0, 4.0, 1.0]
        );

        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).as_array(),
            &[1.0, 2.0]
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).as_array(),
            &[3.0, 4.0, 1.0]
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]).as_array(),
            &[2.0, 3.0, 4.0, 1.0]
        );

        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).as_array_mut(),
            &mut [1.0, 2.0]
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).as_array_mut(),
            &mut [3.0, 4.0, 1.0]
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]).as_array_mut(),
            &mut [2.0, 3.0, 4.0, 1.0]
        );

        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).as_ptr(),
            [1.0, 2.0].as_ptr()
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).as_ptr(),
            [3.0, 4.0, 1.0].as_ptr()
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]).as_ptr(),
            [2.0, 3.0, 4.0, 1.0].as_ptr()
        );

        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).as_mut_ptr(),
            [1.0, 2.0].as_mut_ptr()
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).as_mut_ptr(),
            [3.0, 4.0, 1.0].as_mut_ptr()
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]).as_mut_ptr(),
            [2.0, 3.0, 4.0, 1.0].as_mut_ptr()
        );

        assert_eq!(
            Vector::<2, f32, VecPacked>::from_fn(|i| [1.0, 2.0][i]).to_array(),
            [1.0, 2.0]
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_fn(|i| [3.0, 4.0, 1.0][i]).to_array(),
            [3.0, 4.0, 1.0]
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_fn(|i| [2.0, 3.0, 4.0, 1.0][i]).to_array(),
            [2.0, 3.0, 4.0, 1.0]
        );

        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0])
                .map(|x| {
                    let idx = [1.0, 2.0].into_iter().position(|y| y == x).unwrap();
                    [1.0, 2.0][idx]
                })
                .to_array(),
            [1.0, 2.0]
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0])
                .map(|x| {
                    let idx = [3.0, 4.0, 1.0].into_iter().position(|y| y == x).unwrap();
                    [3.0, 4.0, 1.0][idx]
                })
                .to_array(),
            [3.0, 4.0, 1.0]
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0])
                .map(|x| {
                    let idx = [2.0, 3.0, 4.0, 1.0]
                        .into_iter()
                        .position(|y| y == x)
                        .unwrap();
                    [2.0, 3.0, 4.0, 1.0][idx]
                })
                .to_array(),
            [2.0, 3.0, 4.0, 1.0]
        );

        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).fold(|x, y| x + y),
            1.0 + 2.0
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).fold(|x, y| x + y),
            3.0 + 4.0 + 1.0
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]).fold(|x, y| x + y),
            2.0 + 3.0 + 4.0 + 1.0
        );

        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).all(|x| x == 1.0),
            false
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).all(|x| x == 1.0),
            false
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]).all(|x| x == 1.0),
            false
        );

        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).any(|x| x == 1.0),
            true
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).any(|x| x == 1.0),
            true
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]).any(|x| x == 1.0),
            true
        );

        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).count(|x| x == 1.0),
            1
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).count(|x| x == 1.0),
            1
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]).count(|x| x == 1.0),
            1
        );

        assert_eq!(Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).len(), 2);
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).len(),
            3
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]).len(),
            4
        );
    }

    #[test]
    fn test_splat_packed() {
        assert_eq!(Vector::<2, f32, VecPacked>::splat(1.0).to_array(), [1.0; 2]);
        assert_eq!(Vector::<3, f32, VecPacked>::splat(3.0).to_array(), [3.0; 3]);
        assert_eq!(Vector::<4, f32, VecPacked>::splat(2.0).to_array(), [2.0; 4]);

        assert_eq!(
            Vector::<2, f32, VecPacked>::const_splat(1.0).to_array(),
            [1.0; 2]
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::const_splat(3.0).to_array(),
            [3.0; 3]
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::const_splat(2.0).to_array(),
            [2.0; 4]
        );
    }

    #[test]
    fn test_storage_packed() {
        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).align(),
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]),
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).align(),
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]).align(),
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]),
        );

        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).pack(),
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]),
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).pack(),
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]).pack(),
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]),
        );

        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).to_storage::<VecAligned>(),
            Vector::<2, f32, VecAligned>::from_array([1.0, 2.0]),
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).to_storage::<VecAligned>(),
            Vector::<3, f32, VecAligned>::from_array([3.0, 4.0, 1.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0])
                .to_storage::<VecAligned>(),
            Vector::<4, f32, VecAligned>::from_array([2.0, 3.0, 4.0, 1.0]),
        );

        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).to_storage::<VecPacked>(),
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]),
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).to_storage::<VecPacked>(),
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]).to_storage::<VecPacked>(),
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]),
        );

        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).is_aligned(),
            false
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).is_aligned(),
            false
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]).is_aligned(),
            false
        );
    }

    #[test]
    fn test_swizzle_packed() {
        assert_eq!(Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).x(), 1.0);
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).y(),
            4.0
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]).z(),
            4.0
        );

        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).yy(),
            Vector::<2, f32, VecPacked>::from_array([2.0, 2.0]),
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).zy(),
            Vector::<2, f32, VecPacked>::from_array([1.0, 4.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]).xw(),
            Vector::<2, f32, VecPacked>::from_array([2.0, 1.0]),
        );

        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).xyy(),
            Vector::<3, f32, VecPacked>::from_array([1.0, 2.0, 2.0]),
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).yzy(),
            Vector::<3, f32, VecPacked>::from_array([4.0, 1.0, 4.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]).wxy(),
            Vector::<3, f32, VecPacked>::from_array([1.0, 2.0, 3.0]),
        );

        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).xxyy(),
            Vector::<4, f32, VecPacked>::from_array([1.0, 1.0, 2.0, 2.0]),
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).yzyz(),
            Vector::<4, f32, VecPacked>::from_array([4.0, 1.0, 4.0, 1.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]).wxyw(),
            Vector::<4, f32, VecPacked>::from_array([1.0, 2.0, 3.0, 1.0]),
        );
    }

    #[test]
    fn test_swizzle_ref_packed() {
        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).x_ref(),
            &1.0
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).y_ref(),
            &4.0
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]).z_ref(),
            &4.0
        );

        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).xy_ref(),
            &Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]),
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([1.0, 2.0, 3.0]).yz_ref(),
            &Vector::<2, f32, VecPacked>::from_array([2.0, 3.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([1.0, 2.0, 3.0, 4.0]).zw_ref(),
            &Vector::<2, f32, VecPacked>::from_array([3.0, 4.0]),
        );

        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([1.0, 2.0, 3.0]).xyz_ref(),
            &Vector::<3, f32, VecPacked>::from_array([1.0, 2.0, 3.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([1.0, 2.0, 3.0, 4.0]).yzw_ref(),
            &Vector::<3, f32, VecPacked>::from_array([2.0, 3.0, 4.0]),
        );

        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([1.0, 2.0, 3.0, 4.0]).xyzw_ref(),
            &Vector::<4, f32, VecPacked>::from_array([1.0, 2.0, 3.0, 4.0]),
        );
    }

    #[test]
    fn test_swizzle_mut_packed() {
        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).x_mut(),
            &mut 1.0
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).y_mut(),
            &mut 4.0
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]).z_mut(),
            &mut 4.0
        );

        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).x_y_mut(),
            (&mut 1.0, &mut 2.0)
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).xy_z_mut(),
            (
                &mut Vector::<2, f32, VecPacked>::from_array([3.0, 4.0]),
                &mut 1.0
            )
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]).xy_zw_mut(),
            (
                &mut Vector::<2, f32, VecPacked>::from_array([2.0, 3.0]),
                &mut Vector::<2, f32, VecPacked>::from_array([4.0, 1.0]),
            ),
        );
    }

    #[test]
    fn test_swizzle_with_packed() {
        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).with_x(3.0),
            Vector::<2, f32, VecPacked>::from_array([3.0, 2.0]),
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).with_y(2.0),
            Vector::<3, f32, VecPacked>::from_array([3.0, 2.0, 1.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]).with_z(3.0),
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 3.0, 1.0]),
        );

        assert_eq!(
            Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]).with_xy(vec2!(3.0, 4.0)),
            Vector::<2, f32, VecPacked>::from_array([3.0, 4.0]),
        );
        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]).with_zy(vec2!(2.0, 3.0)),
            Vector::<3, f32, VecPacked>::from_array([3.0, 3.0, 2.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]).with_xw(vec2!(3.0, 4.0)),
            Vector::<4, f32, VecPacked>::from_array([3.0, 2.0, 3.0, 4.0]),
        );

        assert_eq!(
            Vector::<3, f32, VecPacked>::from_array([1.0, 2.0, 3.0]).with_xzy(vec3!(3.0, 4.0, 1.0)),
            Vector::<3, f32, VecPacked>::from_array([3.0, 1.0, 4.0]),
        );
        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0])
                .with_ywx(vec3!(3.0, 4.0, 1.0)),
            Vector::<4, f32, VecPacked>::from_array([1.0, 3.0, 4.0, 4.0]),
        );

        assert_eq!(
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0])
                .with_xywz(vec4!(3.0, 4.0, 1.0, 2.0)),
            Vector::<4, f32, VecPacked>::from_array([3.0, 4.0, 2.0, 1.0]),
        );
    }

    #[test]
    fn test_swizzle_set_packed() {
        assert_eq!(
            {
                let mut vector = Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]);
                vector.set_x(3.0);
                vector
            },
            Vector::<2, f32, VecPacked>::from_array([3.0, 2.0]),
        );
        assert_eq!(
            {
                let mut vector = Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]);
                vector.set_y(2.0);
                vector
            },
            Vector::<3, f32, VecPacked>::from_array([3.0, 2.0, 1.0]),
        );
        assert_eq!(
            {
                let mut vector = Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]);
                vector.set_z(3.0);
                vector
            },
            Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 3.0, 1.0]),
        );

        assert_eq!(
            {
                let mut vector = Vector::<2, f32, VecPacked>::from_array([1.0, 2.0]);
                vector.set_xy(vec2!(3.0, 4.0));
                vector
            },
            Vector::<2, f32, VecPacked>::from_array([3.0, 4.0]),
        );
        assert_eq!(
            {
                let mut vector = Vector::<3, f32, VecPacked>::from_array([3.0, 4.0, 1.0]);
                vector.set_zy(vec2!(2.0, 3.0));
                vector
            },
            Vector::<3, f32, VecPacked>::from_array([3.0, 3.0, 2.0]),
        );
        assert_eq!(
            {
                let mut vector = Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]);
                vector.set_xw(vec2!(3.0, 4.0));
                vector
            },
            Vector::<4, f32, VecPacked>::from_array([3.0, 2.0, 3.0, 4.0]),
        );

        assert_eq!(
            {
                let mut vector = Vector::<3, f32, VecPacked>::from_array([1.0, 2.0, 3.0]);
                vector.set_xzy(vec3!(3.0, 4.0, 1.0));
                vector
            },
            Vector::<3, f32, VecPacked>::from_array([3.0, 1.0, 4.0]),
        );
        assert_eq!(
            {
                let mut vector = Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]);
                vector.set_ywx(vec3!(3.0, 4.0, 1.0));
                vector
            },
            Vector::<4, f32, VecPacked>::from_array([1.0, 3.0, 4.0, 4.0]),
        );

        assert_eq!(
            {
                let mut vector = Vector::<4, f32, VecPacked>::from_array([2.0, 3.0, 4.0, 1.0]);
                vector.set_xywz(vec4!(3.0, 4.0, 1.0, 2.0));
                vector
            },
            Vector::<4, f32, VecPacked>::from_array([3.0, 4.0, 2.0, 1.0]),
        );
    }

    #[test]
    fn test_constructor_packed() {
        assert_eq!(vec2p!(1.0, 2.0).to_array(), [1.0, 2.0]);
        assert_eq!(vec2p!(vec2p!(1.0, 2.0)).to_array(), [1.0, 2.0]);

        assert_eq!(vec3p!(1.0, 2.0, 3.0).to_array(), [1.0, 2.0, 3.0]);
        assert_eq!(vec3p!(1.0, vec2p!(2.0, 3.0)).to_array(), [1.0, 2.0, 3.0]);
        assert_eq!(vec3p!(vec2p!(1.0, 2.0), 3.0).to_array(), [1.0, 2.0, 3.0]);
        assert_eq!(vec3p!(vec3p!(1.0, 2.0, 3.0)).to_array(), [1.0, 2.0, 3.0]);

        assert_eq!(vec4p!(1.0, 2.0, 3.0, 4.0).to_array(), [1.0, 2.0, 3.0, 4.0]);
        assert_eq!(
            vec4p!(1.0, 2.0, vec2p!(3.0, 4.0)).to_array(),
            [1.0, 2.0, 3.0, 4.0]
        );
        assert_eq!(
            vec4p!(1.0, vec2p!(2.0, 3.0), 4.0).to_array(),
            [1.0, 2.0, 3.0, 4.0]
        );
        assert_eq!(
            vec4p!(1.0, vec3p!(2.0, 3.0, 4.0)).to_array(),
            [1.0, 2.0, 3.0, 4.0]
        );
        assert_eq!(
            vec4p!(vec2p!(1.0, 2.0), 3.0, 4.0).to_array(),
            [1.0, 2.0, 3.0, 4.0]
        );
        assert_eq!(
            vec4p!(vec2p!(1.0, 2.0), vec2p!(3.0, 4.0)).to_array(),
            [1.0, 2.0, 3.0, 4.0]
        );
        assert_eq!(
            vec4p!(vec3p!(1.0, 2.0, 3.0), 4.0).to_array(),
            [1.0, 2.0, 3.0, 4.0]
        );
        assert_eq!(
            vec4p!(vec4p!(1.0, 2.0, 3.0, 4.0)).to_array(),
            [1.0, 2.0, 3.0, 4.0]
        );
    }

    // These tests are generated for all primitive number types

    #[test]
    fn test_ops_aligned() {
        assert_eq!((vec2!(0.0, 1.0) + vec2!(2.0, 3.0)).to_array(), [2.0, 4.0]);
        assert_eq!((vec2!(5.0, 3.0) - vec2!(2.0, 2.0)).to_array(), [3.0, 1.0]);
        assert_eq!((vec2!(5.0, 3.0) * vec2!(2.0, 3.0)).to_array(), [10.0, 9.0]);
        assert_eq!((vec2!(5.0, 3.0) / vec2!(2.0, 3.0)).to_array(), [2.0, 1.0]);
        assert_eq!((vec2!(5.0, 3.0) % vec2!(2.0, 3.0)).to_array(), [1.0, 0.0]);
        assert_eq!((vec2!(5.0, 3.0) * 2.0).to_array(), [10.0, 6.0]);
        assert_eq!((vec2!(5.0, 3.0) / 2.0).to_array(), [2.0, 1.0]);
        assert_eq!((vec2!(5.0, 3.0) % 2.0).to_array(), [1.0, 1.0]);

        assert_eq!(
            (vec3!(0.0, 1.0, 2.0) + vec3!(3.0, 4.0, 5.0)).to_array(),
            [3.0, 5.0, 7.0]
        );
        assert_eq!(
            (vec3!(5.0, 3.0, 2.0) - vec3!(2.0, 2.0, 2.0)).to_array(),
            [3.0, 1.0, 0.0]
        );
        assert_eq!(
            (vec3!(5.0, 3.0, 2.0) * vec3!(2.0, 3.0, 4.0)).to_array(),
            [10.0, 9.0, 8.0]
        );
        assert_eq!(
            (vec3!(5.0, 3.0, 2.0) / vec3!(2.0, 3.0, 4.0)).to_array(),
            [2.0, 1.0, 0.0]
        );
        assert_eq!(
            (vec3!(5.0, 3.0, 2.0) % vec3!(2.0, 3.0, 4.0)).to_array(),
            [1.0, 0.0, 2.0]
        );
        assert_eq!((vec3!(5.0, 3.0, 2.0) * 2.0).to_array(), [10.0, 6.0, 4.0]);
        assert_eq!((vec3!(5.0, 3.0, 2.0) / 2.0).to_array(), [2.0, 1.0, 1.0]);
        assert_eq!((vec3!(5.0, 3.0, 2.0) % 2.0).to_array(), [1.0, 1.0, 0.0]);

        assert_eq!(
            (vec4!(0.0, 1.0, 2.0, 3.0) + vec4!(4.0, 5.0, 6.0, 7.0)).to_array(),
            [4.0, 6.0, 8.0, 10.0]
        );
        assert_eq!(
            (vec4!(5.0, 3.0, 2.0, 1.0) - vec4!(2.0, 2.0, 2.0, 2.0)).to_array(),
            [3.0, 1.0, 0.0, 1.0]
        );
        assert_eq!(
            (vec4!(5.0, 3.0, 2.0, 1.0) * vec4!(2.0, 3.0, 4.0, 5.0)).to_array(),
            [10.0, 9.0, 8.0, 5.0]
        );
        assert_eq!(
            (vec4!(5.0, 3.0, 2.0, 1.0) / vec4!(2.0, 3.0, 4.0, 5.0)).to_array(),
            [2.0, 1.0, 0.0, 1.0]
        );
        assert_eq!(
            (vec4!(5.0, 3.0, 2.0, 1.0) % vec4!(2.0, 3.0, 4.0, 5.0)).to_array(),
            [1.0, 0.0, 2.0, 1.0]
        );
        assert_eq!(
            (vec4!(5.0, 3.0, 2.0, 1.0) * 2.0).to_array(),
            [10.0, 6.0, 4.0, 2.0]
        );
        assert_eq!(
            (vec4!(5.0, 3.0, 2.0, 1.0) / 2.0).to_array(),
            [2.0, 1.0, 1.0, 1.0]
        );
        assert_eq!(
            (vec4!(5.0, 3.0, 2.0, 1.0) % 2.0).to_array(),
            [1.0, 1.0, 0.0, 1.0]
        );
    }

    // These tests are generated for all primitive number types

    #[test]
    fn test_ops_packed() {
        assert_eq!((vec2p!(0.0, 1.0) + vec2p!(2.0, 3.0)).to_array(), [2.0, 4.0]);
        assert_eq!((vec2p!(5.0, 3.0) - vec2p!(2.0, 2.0)).to_array(), [3.0, 1.0]);
        assert_eq!(
            (vec2p!(5.0, 3.0) * vec2p!(2.0, 3.0)).to_array(),
            [10.0, 9.0]
        );
        assert_eq!((vec2p!(5.0, 3.0) / vec2p!(2.0, 3.0)).to_array(), [2.0, 1.0]);
        assert_eq!((vec2p!(5.0, 3.0) % vec2p!(2.0, 3.0)).to_array(), [1.0, 0.0]);
        assert_eq!((vec2p!(5.0, 3.0) * 2.0).to_array(), [10.0, 6.0]);
        assert_eq!((vec2p!(5.0, 3.0) / 2.0).to_array(), [2.0, 1.0]);
        assert_eq!((vec2p!(5.0, 3.0) % 2.0).to_array(), [1.0, 1.0]);

        assert_eq!(
            (vec3p!(0.0, 1.0, 2.0) + vec3p!(3.0, 4.0, 5.0)).to_array(),
            [3.0, 5.0, 7.0]
        );
        assert_eq!(
            (vec3p!(5.0, 3.0, 2.0) - vec3p!(2.0, 2.0, 2.0)).to_array(),
            [3.0, 1.0, 0.0]
        );
        assert_eq!(
            (vec3p!(5.0, 3.0, 2.0) * vec3p!(2.0, 3.0, 4.0)).to_array(),
            [10.0, 9.0, 8.0]
        );
        assert_eq!(
            (vec3p!(5.0, 3.0, 2.0) / vec3p!(2.0, 3.0, 4.0)).to_array(),
            [2.0, 1.0, 0.0]
        );
        assert_eq!(
            (vec3p!(5.0, 3.0, 2.0) % vec3p!(2.0, 3.0, 4.0)).to_array(),
            [1.0, 0.0, 2.0]
        );
        assert_eq!((vec3p!(5.0, 3.0, 2.0) * 2.0).to_array(), [10.0, 6.0, 4.0]);
        assert_eq!((vec3p!(5.0, 3.0, 2.0) / 2.0).to_array(), [2.0, 1.0, 1.0]);
        assert_eq!((vec3p!(5.0, 3.0, 2.0) % 2.0).to_array(), [1.0, 1.0, 0.0]);

        assert_eq!(
            (vec4p!(0.0, 1.0, 2.0, 3.0) + vec4p!(4.0, 5.0, 6.0, 7.0)).to_array(),
            [4.0, 6.0, 8.0, 10.0]
        );
        assert_eq!(
            (vec4p!(5.0, 3.0, 2.0, 1.0) - vec4p!(2.0, 2.0, 2.0, 2.0)).to_array(),
            [3.0, 1.0, 0.0, 1.0]
        );
        assert_eq!(
            (vec4p!(5.0, 3.0, 2.0, 1.0) * vec4p!(2.0, 3.0, 4.0, 5.0)).to_array(),
            [10.0, 9.0, 8.0, 5.0]
        );
        assert_eq!(
            (vec4p!(5.0, 3.0, 2.0, 1.0) / vec4p!(2.0, 3.0, 4.0, 5.0)).to_array(),
            [2.0, 1.0, 0.0, 1.0]
        );
        assert_eq!(
            (vec4p!(5.0, 3.0, 2.0, 1.0) % vec4p!(2.0, 3.0, 4.0, 5.0)).to_array(),
            [1.0, 0.0, 2.0, 1.0]
        );
        assert_eq!(
            (vec4p!(5.0, 3.0, 2.0, 1.0) * 2.0).to_array(),
            [10.0, 6.0, 4.0, 2.0]
        );
        assert_eq!(
            (vec4p!(5.0, 3.0, 2.0, 1.0) / 2.0).to_array(),
            [2.0, 1.0, 1.0, 1.0]
        );
        assert_eq!(
            (vec4p!(5.0, 3.0, 2.0, 1.0) % 2.0).to_array(),
            [1.0, 1.0, 0.0, 1.0]
        );
    }

    // These tests are generated for all signed number types

    #[test]
    fn test_signed_ops_aligned() {
        assert_eq!((-vec2!(5.0, 4.0)).to_array(), [-5.0, -4.0]);
        assert_eq!((-vec3!(0.0, 1.0, 3.0)).to_array(), [0.0, -1.0, -3.0]);
        assert_eq!(
            (-vec4!(5.0, 4.0, 3.0, 2.0)).to_array(),
            [-5.0, -4.0, -3.0, -2.0]
        );
    }

    // These tests are generated for all signed number types

    #[test]
    fn test_signed_ops_packed() {
        assert_eq!((-vec2p!(5.0, 4.0)).to_array(), [-5.0, -4.0]);
        assert_eq!((-vec3p!(0.0, 1.0, 3.0)).to_array(), [0.0, -1.0, -3.0]);
        assert_eq!(
            (-vec4p!(5.0, 4.0, 3.0, 2.0)).to_array(),
            [-5.0, -4.0, -3.0, -2.0]
        );
    }
}
