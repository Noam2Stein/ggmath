// This file is automatically generated.
// To edit this file edit the codegen crate instead.

use crate::{Usize, vector::*};

impl<const N: usize, A: VecAlignment> Vector<N, u64, A>
where
    Usize<N>: VecLen,
{
    // The following items are generated for all number types

    /// A vector of all minimum values.
    pub const MIN: Self = Self::const_splat(u64::MIN);
    /// A vector of all maximum values.
    pub const MAX: Self = Self::const_splat(u64::MAX);

    /// Converts `self` to a vector of `f32` elements.
    #[inline(always)]
    pub fn as_f32(self) -> Vector<N, f32, A> {
        self.map(|x| x as f32)
    }

    /// Converts `self` to a vector of `f64` elements.
    #[inline(always)]
    pub fn as_f64(self) -> Vector<N, f64, A> {
        self.map(|x| x as f64)
    }

    /// Converts `self` to a vector of `i8` elements.
    #[inline(always)]
    pub fn as_i8(self) -> Vector<N, i8, A> {
        self.map(|x| x as i8)
    }

    /// Converts `self` to a vector of `i16` elements.
    #[inline(always)]
    pub fn as_i16(self) -> Vector<N, i16, A> {
        self.map(|x| x as i16)
    }

    /// Converts `self` to a vector of `i32` elements.
    #[inline(always)]
    pub fn as_i32(self) -> Vector<N, i32, A> {
        self.map(|x| x as i32)
    }

    /// Converts `self` to a vector of `i64` elements.
    #[inline(always)]
    pub fn as_i64(self) -> Vector<N, i64, A> {
        self.map(|x| x as i64)
    }

    /// Converts `self` to a vector of `i128` elements.
    #[inline(always)]
    pub fn as_i128(self) -> Vector<N, i128, A> {
        self.map(|x| x as i128)
    }

    /// Converts `self` to a vector of `isize` elements.
    #[inline(always)]
    pub fn as_isize(self) -> Vector<N, isize, A> {
        self.map(|x| x as isize)
    }

    /// Converts `self` to a vector of `u8` elements.
    #[inline(always)]
    pub fn as_u8(self) -> Vector<N, u8, A> {
        self.map(|x| x as u8)
    }

    /// Converts `self` to a vector of `u16` elements.
    #[inline(always)]
    pub fn as_u16(self) -> Vector<N, u16, A> {
        self.map(|x| x as u16)
    }

    /// Converts `self` to a vector of `u32` elements.
    #[inline(always)]
    pub fn as_u32(self) -> Vector<N, u32, A> {
        self.map(|x| x as u32)
    }

    /// Converts `self` to a vector of `u128` elements.
    #[inline(always)]
    pub fn as_u128(self) -> Vector<N, u128, A> {
        self.map(|x| x as u128)
    }

    /// Converts `self` to a vector of `usize` elements.
    #[inline(always)]
    pub fn as_usize(self) -> Vector<N, usize, A> {
        self.map(|x| x as usize)
    }

    // The following items are generated for all int types

    /// Returns `-self` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_neg(self) -> Option<Self> {
        self.map(|x| x.checked_neg()).flatten()
    }

    /// Returns `self + other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_add(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self[i].checked_add(other[i])).flatten()
    }

    /// Returns `self - other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_sub(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self[i].checked_sub(other[i])).flatten()
    }

    /// Returns `self * other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_mul(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self[i].checked_mul(other[i])).flatten()
    }

    /// Returns `self / other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_div(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self[i].checked_div(other[i])).flatten()
    }

    /// Returns `self % other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_rem(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self[i].checked_rem(other[i])).flatten()
    }

    /// Returns `-self` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_neg(self) -> Self {
        self.map(|x| x.wrapping_neg())
    }

    /// Returns `self + other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_add(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].wrapping_add(other[i]))
    }

    /// Returns `self - other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_sub(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].wrapping_sub(other[i]))
    }

    /// Returns `self * other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_mul(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].wrapping_mul(other[i]))
    }

    /// Returns `self / other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_div(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].wrapping_div(other[i]))
    }

    /// Returns `self % other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_rem(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].wrapping_rem(other[i]))
    }

    /// Returns `self + other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_add(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].saturating_add(other[i]))
    }

    /// Returns `self - other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_sub(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].saturating_sub(other[i]))
    }

    /// Returns `self * other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_mul(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].saturating_mul(other[i]))
    }

    /// Returns `self / other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_div(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].saturating_div(other[i]))
    }
}

impl<const N: usize, A: VecAlignment> Vector<N, u64, A>
where
    Usize<N>: VecLen,
{
    // The following items are generated for all primitive types

    /// Returns `self == other` and supports const contexts.
    #[inline(always)]
    pub const fn const_eq(self, other: Vector<N, u64, impl VecAlignment>) -> bool {
        let mut i = 0;
        while i < N {
            if self.as_array()[i] != other.as_array()[i] {
                return false;
            }
            i += 1;
        }
        true
    }

    /// Returns `self != other` and supports const contexts.
    #[inline(always)]
    pub const fn const_ne(self, other: Vector<N, u64, impl VecAlignment>) -> bool {
        let mut i = 0;
        while i < N {
            if self.as_array()[i] != other.as_array()[i] {
                return true;
            }
            i += 1;
        }
        false
    }

    /// Returns `self.eq_mask(other)` and supports const contexts.
    pub const fn const_eq_mask(
        self,
        other: Vector<N, u64, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] == other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.ne_mask(other)` and supports const contexts.
    pub const fn const_ne_mask(
        self,
        other: Vector<N, u64, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] != other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.lt_mask(other)` and supports const contexts.
    pub const fn const_lt_mask(
        self,
        other: Vector<N, u64, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] < other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.gt_mask(other)` and supports const contexts.
    pub const fn const_gt_mask(
        self,
        other: Vector<N, u64, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] > other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.le_mask(other)` and supports const contexts.
    pub const fn const_le_mask(
        self,
        other: Vector<N, u64, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] <= other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.ge_mask(other)` and supports const contexts.
    pub const fn const_ge_mask(
        self,
        other: Vector<N, u64, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] >= other.as_array()[i];
            i += 1;
        }
        output
    }

    // The following items are generated for all number types

    /// Returns `self + other` and supports const contexts.
    #[inline(always)]
    pub const fn const_add(mut self, other: Vector<N, u64, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] + other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self - other` and supports const contexts.
    #[inline(always)]
    pub const fn const_sub(mut self, other: Vector<N, u64, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] - other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self * other` and supports const contexts.
    #[inline(always)]
    pub const fn const_mul(mut self, other: Vector<N, u64, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] * other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self / other` and supports const contexts.
    #[inline(always)]
    pub const fn const_div(mut self, other: Vector<N, u64, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] / other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self % other` and supports const contexts.
    #[inline(always)]
    pub const fn const_rem(mut self, other: Vector<N, u64, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] % other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self.min(other)` and supports const contexts.
    #[inline(always)]
    pub const fn const_min(mut self, other: Vector<N, u64, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            if other.as_array()[i] < self.as_array()[i] {
                self.as_array_mut()[i] = other.as_array()[i];
            }
            i += 1;
        }
        self
    }

    /// Returns `self.max(other)` and supports const contexts.
    #[inline(always)]
    pub const fn const_max(mut self, other: Vector<N, u64, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            if other.as_array()[i] > self.as_array()[i] {
                self.as_array_mut()[i] = other.as_array()[i];
            }
            i += 1;
        }
        self
    }

    /// Returns `self.clamp(min, max)` and supports const contexts.
    #[inline(always)]
    pub const fn const_clamp(
        self,
        min: Vector<N, u64, impl VecAlignment>,
        max: Vector<N, u64, impl VecAlignment>,
    ) -> Self {
        #[cfg(debug_assertions)]
        assert!(
            min.const_le_mask(max).const_all_true(),
            "min must be less than or equal to max"
        );

        self.const_min(max).const_max(min)
    }

    /// Returns `self.sum()` and supports const contexts.
    #[inline(always)]
    pub const fn const_sum(self) -> u64 {
        let mut output = 0 as u64;
        let mut i = 0;
        while i < N {
            output += self.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.product()` and supports const contexts.
    #[inline(always)]
    pub const fn const_product(self) -> u64 {
        let mut output = 1 as u64;
        let mut i = 0;
        while i < N {
            output *= self.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.dot(other)` and supports const contexts.
    #[inline(always)]
    pub const fn const_dot(self, other: Vector<N, u64, impl VecAlignment>) -> u64 {
        let mut output = 0 as u64;
        let mut i = 0;
        while i < N {
            output += self.as_array()[i] * other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.mag_sq()` and supports const contexts.
    #[inline(always)]
    pub const fn const_mag_sq(self) -> u64 {
        let mut output = 0 as u64;
        let mut i = 0;
        while i < N {
            output += self.as_array()[i] * self.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.distance_sq(other)` and supports const contexts.
    #[inline(always)]
    pub const fn const_distance_sq(self, other: Vector<N, u64, impl VecAlignment>) -> u64 {
        self.const_abs_diff(other).const_mag_sq()
    }

    /// Version of `Vector::as_f32` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_f32(self) -> Vector<N, f32, A> {
        let mut output = Vector::<N, f32, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as f32;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_f64` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_f64(self) -> Vector<N, f64, A> {
        let mut output = Vector::<N, f64, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as f64;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i8` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i8(self) -> Vector<N, i8, A> {
        let mut output = Vector::<N, i8, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i8;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i16` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i16(self) -> Vector<N, i16, A> {
        let mut output = Vector::<N, i16, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i16;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i32` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i32(self) -> Vector<N, i32, A> {
        let mut output = Vector::<N, i32, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i32;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i64` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i64(self) -> Vector<N, i64, A> {
        let mut output = Vector::<N, i64, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i64;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i128` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i128(self) -> Vector<N, i128, A> {
        let mut output = Vector::<N, i128, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i128;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_isize` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_isize(self) -> Vector<N, isize, A> {
        let mut output = Vector::<N, isize, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as isize;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_u8` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_u8(self) -> Vector<N, u8, A> {
        let mut output = Vector::<N, u8, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as u8;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_u16` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_u16(self) -> Vector<N, u16, A> {
        let mut output = Vector::<N, u16, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as u16;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_u32` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_u32(self) -> Vector<N, u32, A> {
        let mut output = Vector::<N, u32, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as u32;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_u128` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_u128(self) -> Vector<N, u128, A> {
        let mut output = Vector::<N, u128, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as u128;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_usize` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_usize(self) -> Vector<N, usize, A> {
        let mut output = Vector::<N, usize, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as usize;
            i += 1;
        }
        output
    }

    // The following items are generated for all int types

    /// Returns `!self` and supports const contexts.
    #[inline(always)]
    pub const fn const_not(mut self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = !self.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self << other` and supports const contexts.
    #[inline(always)]
    pub const fn const_shl(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] << other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self >> other` and supports const contexts.
    #[inline(always)]
    pub const fn const_shr(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] >> other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self & other` and supports const contexts.
    #[inline(always)]
    pub const fn const_bitand(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] & other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self | other` and supports const contexts.
    #[inline(always)]
    pub const fn const_bitor(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] | other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self ^ other` and supports const contexts.
    #[inline(always)]
    pub const fn const_bitxor(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] ^ other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Version of `Vector::checked_neg` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_checked_neg(mut self) -> Option<Self> {
        let mut i = 0;
        while i < N {
            match self.as_array()[i].checked_neg() {
                Some(value) => self.as_array_mut()[i] = value,
                None => return None,
            };

            i += 1;
        }

        Some(self)
    }

    /// Version of `Vector::checked_add` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_checked_add(mut self, other: Self) -> Option<Self> {
        let mut i = 0;
        while i < N {
            match self.as_array()[i].checked_add(other.as_array()[i]) {
                Some(value) => self.as_array_mut()[i] = value,
                None => return None,
            };

            i += 1;
        }

        Some(self)
    }

    /// Version of `Vector::checked_sub` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_checked_sub(mut self, other: Self) -> Option<Self> {
        let mut i = 0;
        while i < N {
            match self.as_array()[i].checked_sub(other.as_array()[i]) {
                Some(value) => self.as_array_mut()[i] = value,
                None => return None,
            };

            i += 1;
        }

        Some(self)
    }

    /// Version of `Vector::checked_mul` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_checked_mul(mut self, other: Self) -> Option<Self> {
        let mut i = 0;
        while i < N {
            match self.as_array()[i].checked_mul(other.as_array()[i]) {
                Some(value) => self.as_array_mut()[i] = value,
                None => return None,
            };

            i += 1;
        }

        Some(self)
    }

    /// Version of `Vector::checked_div` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_checked_div(mut self, other: Self) -> Option<Self> {
        let mut i = 0;
        while i < N {
            match self.as_array()[i].checked_div(other.as_array()[i]) {
                Some(value) => self.as_array_mut()[i] = value,
                None => return None,
            };

            i += 1;
        }

        Some(self)
    }

    /// Version of `Vector::checked_rem` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_checked_rem(mut self, other: Self) -> Option<Self> {
        let mut i = 0;
        while i < N {
            match self.as_array()[i].checked_rem(other.as_array()[i]) {
                Some(value) => self.as_array_mut()[i] = value,
                None => return None,
            };

            i += 1;
        }

        Some(self)
    }

    /// Version of `Vector::wrapping_neg` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_wrapping_neg(mut self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].wrapping_neg();
            i += 1;
        }

        self
    }

    /// Version of `Vector::wrapping_add` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_wrapping_add(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].wrapping_add(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::wrapping_sub` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_wrapping_sub(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].wrapping_sub(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::wrapping_mul` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_wrapping_mul(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].wrapping_mul(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::wrapping_div` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_wrapping_div(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].wrapping_div(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::wrapping_rem` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_wrapping_rem(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].wrapping_rem(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::saturating_add` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_saturating_add(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].saturating_add(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::saturating_sub` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_saturating_sub(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].saturating_sub(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::saturating_mul` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_saturating_mul(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].saturating_mul(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::saturating_div` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_saturating_div(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].saturating_div(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Returns `self.abs_diff(other)` and supports const contexts.
    #[inline(always)]
    pub const fn const_abs_diff(self, other: Vector<N, u64, impl VecAlignment>) -> Self {
        self.const_max(other).const_sub(self.const_min(other))
    }
}

impl ScalarZero for u64 {
    const ZERO: u64 = 0 as Self;
}

impl ScalarOne for u64 {
    const ONE: u64 = 1 as Self;
}

#[cfg(test)]
mod tests {
    use crate::*;

    // These tests are generated for all primitive types

    #[test]
    fn test_array_aligned() {
        assert_eq!(
            Vector::<2, u64, VecAligned>::from_array([1, 2]).to_array(),
            [1, 2]
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).to_array(),
            [3, 4, 1]
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).to_array(),
            [2, 3, 4, 1]
        );

        assert_eq!(
            Vector::<2, u64, VecAligned>::from_array([1, 2]).as_array(),
            &[1, 2]
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).as_array(),
            &[3, 4, 1]
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).as_array(),
            &[2, 3, 4, 1]
        );

        assert_eq!(
            Vector::<2, u64, VecAligned>::from_array([1, 2]).as_array_mut(),
            &mut [1, 2]
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).as_array_mut(),
            &mut [3, 4, 1]
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).as_array_mut(),
            &mut [2, 3, 4, 1]
        );

        assert_eq!(
            Vector::<2, u64, VecAligned>::from_array([1, 2]).as_ptr(),
            [1, 2].as_ptr()
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).as_ptr(),
            [3, 4, 1].as_ptr()
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).as_ptr(),
            [2, 3, 4, 1].as_ptr()
        );

        assert_eq!(
            Vector::<2, u64, VecAligned>::from_array([1, 2]).as_mut_ptr(),
            [1, 2].as_mut_ptr()
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).as_mut_ptr(),
            [3, 4, 1].as_mut_ptr()
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).as_mut_ptr(),
            [2, 3, 4, 1].as_mut_ptr()
        );

        assert_eq!(
            Vector::<2, u64, VecAligned>::from_fn(|i| [1, 2][i]).to_array(),
            [1, 2]
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_fn(|i| [3, 4, 1][i]).to_array(),
            [3, 4, 1]
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_fn(|i| [2, 3, 4, 1][i]).to_array(),
            [2, 3, 4, 1]
        );

        assert_eq!(
            Vector::<2, u64, VecAligned>::from_array([1, 2])
                .map(|x| {
                    let idx = [1, 2].into_iter().position(|y| y == x).unwrap();
                    [1, 2][idx]
                })
                .to_array(),
            [1, 2]
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1])
                .map(|x| {
                    let idx = [3, 4, 1].into_iter().position(|y| y == x).unwrap();
                    [3, 4, 1][idx]
                })
                .to_array(),
            [3, 4, 1]
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1])
                .map(|x| {
                    let idx = [2, 3, 4, 1].into_iter().position(|y| y == x).unwrap();
                    [2, 3, 4, 1][idx]
                })
                .to_array(),
            [2, 3, 4, 1]
        );

        assert_eq!(
            Vector::<2, u64, VecAligned>::from_array([1, 2]).fold(|x, y| x + y),
            1 + 2
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).fold(|x, y| x + y),
            3 + 4 + 1
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).fold(|x, y| x + y),
            2 + 3 + 4 + 1
        );

        assert_eq!(
            Vector::<2, u64, VecAligned>::from_array([1, 2]).all(|x| x == 1),
            false
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).all(|x| x == 1),
            false
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).all(|x| x == 1),
            false
        );

        assert_eq!(
            Vector::<2, u64, VecAligned>::from_array([1, 2]).any(|x| x == 1),
            true
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).any(|x| x == 1),
            true
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).any(|x| x == 1),
            true
        );

        assert_eq!(
            Vector::<2, u64, VecAligned>::from_array([1, 2]).count(|x| x == 1),
            1
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).count(|x| x == 1),
            1
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).count(|x| x == 1),
            1
        );

        assert_eq!(Vector::<2, u64, VecAligned>::from_array([1, 2]).len(), 2);
        assert_eq!(Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).len(), 3);
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).len(),
            4
        );
    }

    #[test]
    fn test_splat_aligned() {
        assert_eq!(Vector::<2, u64, VecAligned>::splat(1).to_array(), [1; 2]);
        assert_eq!(Vector::<3, u64, VecAligned>::splat(3).to_array(), [3; 3]);
        assert_eq!(Vector::<4, u64, VecAligned>::splat(2).to_array(), [2; 4]);

        assert_eq!(
            Vector::<2, u64, VecAligned>::const_splat(1).to_array(),
            [1; 2]
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::const_splat(3).to_array(),
            [3; 3]
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::const_splat(2).to_array(),
            [2; 4]
        );
    }

    #[test]
    fn test_storage_aligned() {
        assert_eq!(
            Vector::<2, u64, VecAligned>::from_array([1, 2]).align(),
            Vector::<2, u64, VecAligned>::from_array([1, 2]),
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).align(),
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]),
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).align(),
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]),
        );

        assert_eq!(
            Vector::<2, u64, VecAligned>::from_array([1, 2]).pack(),
            Vector::<2, u64, VecPacked>::from_array([1, 2]),
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).pack(),
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]),
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).pack(),
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]),
        );

        assert_eq!(
            Vector::<2, u64, VecAligned>::from_array([1, 2]).to_storage::<VecAligned>(),
            Vector::<2, u64, VecAligned>::from_array([1, 2]),
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).to_storage::<VecAligned>(),
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]),
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).to_storage::<VecAligned>(),
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]),
        );

        assert_eq!(
            Vector::<2, u64, VecAligned>::from_array([1, 2]).to_storage::<VecPacked>(),
            Vector::<2, u64, VecPacked>::from_array([1, 2]),
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).to_storage::<VecPacked>(),
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]),
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).to_storage::<VecPacked>(),
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]),
        );

        assert_eq!(
            Vector::<2, u64, VecAligned>::from_array([1, 2]).is_aligned(),
            true
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).is_aligned(),
            true
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).is_aligned(),
            true
        );
    }

    #[test]
    fn test_swizzle_aligned() {
        assert_eq!(Vector::<2, u64, VecAligned>::from_array([1, 2]).x(), 1);
        assert_eq!(Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).y(), 4);
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).z(),
            4
        );

        assert_eq!(
            Vector::<2, u64, VecAligned>::from_array([1, 2]).yy(),
            Vector::<2, u64, VecAligned>::from_array([2, 2]),
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).zy(),
            Vector::<2, u64, VecAligned>::from_array([1, 4]),
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).xw(),
            Vector::<2, u64, VecAligned>::from_array([2, 1]),
        );

        assert_eq!(
            Vector::<2, u64, VecAligned>::from_array([1, 2]).xyy(),
            Vector::<3, u64, VecAligned>::from_array([1, 2, 2]),
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).yzy(),
            Vector::<3, u64, VecAligned>::from_array([4, 1, 4]),
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).wxy(),
            Vector::<3, u64, VecAligned>::from_array([1, 2, 3]),
        );

        assert_eq!(
            Vector::<2, u64, VecAligned>::from_array([1, 2]).xxyy(),
            Vector::<4, u64, VecAligned>::from_array([1, 1, 2, 2]),
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).yzyz(),
            Vector::<4, u64, VecAligned>::from_array([4, 1, 4, 1]),
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).wxyw(),
            Vector::<4, u64, VecAligned>::from_array([1, 2, 3, 1]),
        );
    }

    #[test]
    fn test_swizzle_ref_aligned() {
        assert_eq!(Vector::<2, u64, VecAligned>::from_array([1, 2]).x_ref(), &1);
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).y_ref(),
            &4
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).z_ref(),
            &4
        );

        assert_eq!(
            Vector::<2, u64, VecAligned>::from_array([1, 2]).xy_ref(),
            &Vector::<2, u64, VecPacked>::from_array([1, 2]),
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([1, 2, 3]).yz_ref(),
            &Vector::<2, u64, VecPacked>::from_array([2, 3]),
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([1, 2, 3, 4]).zw_ref(),
            &Vector::<2, u64, VecPacked>::from_array([3, 4]),
        );

        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([1, 2, 3]).xyz_ref(),
            &Vector::<3, u64, VecPacked>::from_array([1, 2, 3]),
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([1, 2, 3, 4]).yzw_ref(),
            &Vector::<3, u64, VecPacked>::from_array([2, 3, 4]),
        );

        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([1, 2, 3, 4]).xyzw_ref(),
            &Vector::<4, u64, VecPacked>::from_array([1, 2, 3, 4]),
        );
    }

    #[test]
    fn test_swizzle_mut_aligned() {
        assert_eq!(
            Vector::<2, u64, VecAligned>::from_array([1, 2]).x_mut(),
            &mut 1
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).y_mut(),
            &mut 4
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).z_mut(),
            &mut 4
        );

        assert_eq!(
            Vector::<2, u64, VecAligned>::from_array([1, 2]).x_y_mut(),
            (&mut 1, &mut 2)
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).xy_z_mut(),
            (&mut Vector::<2, u64, VecPacked>::from_array([3, 4]), &mut 1)
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).xy_zw_mut(),
            (
                &mut Vector::<2, u64, VecPacked>::from_array([2, 3]),
                &mut Vector::<2, u64, VecPacked>::from_array([4, 1]),
            ),
        );
    }

    #[test]
    fn test_swizzle_with_aligned() {
        assert_eq!(
            Vector::<2, u64, VecAligned>::from_array([1, 2]).with_x(3),
            Vector::<2, u64, VecAligned>::from_array([3, 2]),
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).with_y(2),
            Vector::<3, u64, VecAligned>::from_array([3, 2, 1]),
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).with_z(3),
            Vector::<4, u64, VecAligned>::from_array([2, 3, 3, 1]),
        );

        assert_eq!(
            Vector::<2, u64, VecAligned>::from_array([1, 2]).with_xy(vec2!(3, 4)),
            Vector::<2, u64, VecAligned>::from_array([3, 4]),
        );
        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]).with_zy(vec2!(2, 3)),
            Vector::<3, u64, VecAligned>::from_array([3, 3, 2]),
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).with_xw(vec2!(3, 4)),
            Vector::<4, u64, VecAligned>::from_array([3, 2, 3, 4]),
        );

        assert_eq!(
            Vector::<3, u64, VecAligned>::from_array([1, 2, 3]).with_xzy(vec3!(3, 4, 1)),
            Vector::<3, u64, VecAligned>::from_array([3, 1, 4]),
        );
        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).with_ywx(vec3!(3, 4, 1)),
            Vector::<4, u64, VecAligned>::from_array([1, 3, 4, 4]),
        );

        assert_eq!(
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]).with_xywz(vec4!(3, 4, 1, 2)),
            Vector::<4, u64, VecAligned>::from_array([3, 4, 2, 1]),
        );
    }

    #[test]
    fn test_swizzle_set_aligned() {
        assert_eq!(
            {
                let mut vector = Vector::<2, u64, VecAligned>::from_array([1, 2]);
                vector.set_x(3);
                vector
            },
            Vector::<2, u64, VecAligned>::from_array([3, 2]),
        );
        assert_eq!(
            {
                let mut vector = Vector::<3, u64, VecAligned>::from_array([3, 4, 1]);
                vector.set_y(2);
                vector
            },
            Vector::<3, u64, VecAligned>::from_array([3, 2, 1]),
        );
        assert_eq!(
            {
                let mut vector = Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]);
                vector.set_z(3);
                vector
            },
            Vector::<4, u64, VecAligned>::from_array([2, 3, 3, 1]),
        );

        assert_eq!(
            {
                let mut vector = Vector::<2, u64, VecAligned>::from_array([1, 2]);
                vector.set_xy(vec2!(3, 4));
                vector
            },
            Vector::<2, u64, VecAligned>::from_array([3, 4]),
        );
        assert_eq!(
            {
                let mut vector = Vector::<3, u64, VecAligned>::from_array([3, 4, 1]);
                vector.set_zy(vec2!(2, 3));
                vector
            },
            Vector::<3, u64, VecAligned>::from_array([3, 3, 2]),
        );
        assert_eq!(
            {
                let mut vector = Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]);
                vector.set_xw(vec2!(3, 4));
                vector
            },
            Vector::<4, u64, VecAligned>::from_array([3, 2, 3, 4]),
        );

        assert_eq!(
            {
                let mut vector = Vector::<3, u64, VecAligned>::from_array([1, 2, 3]);
                vector.set_xzy(vec3!(3, 4, 1));
                vector
            },
            Vector::<3, u64, VecAligned>::from_array([3, 1, 4]),
        );
        assert_eq!(
            {
                let mut vector = Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]);
                vector.set_ywx(vec3!(3, 4, 1));
                vector
            },
            Vector::<4, u64, VecAligned>::from_array([1, 3, 4, 4]),
        );

        assert_eq!(
            {
                let mut vector = Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]);
                vector.set_xywz(vec4!(3, 4, 1, 2));
                vector
            },
            Vector::<4, u64, VecAligned>::from_array([3, 4, 2, 1]),
        );
    }

    #[test]
    fn test_constructor_aligned() {
        assert_eq!(vec2!(1, 2).to_array(), [1, 2]);
        assert_eq!(vec2!(vec2!(1, 2)).to_array(), [1, 2]);

        assert_eq!(vec3!(1, 2, 3).to_array(), [1, 2, 3]);
        assert_eq!(vec3!(1, vec2!(2, 3)).to_array(), [1, 2, 3]);
        assert_eq!(vec3!(vec2!(1, 2), 3).to_array(), [1, 2, 3]);
        assert_eq!(vec3!(vec3!(1, 2, 3)).to_array(), [1, 2, 3]);

        assert_eq!(vec4!(1, 2, 3, 4).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4!(1, 2, vec2!(3, 4)).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4!(1, vec2!(2, 3), 4).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4!(1, vec3!(2, 3, 4)).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4!(vec2!(1, 2), 3, 4).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4!(vec2!(1, 2), vec2!(3, 4)).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4!(vec3!(1, 2, 3), 4).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4!(vec4!(1, 2, 3, 4)).to_array(), [1, 2, 3, 4]);
    }

    // These tests are generated for all primitive types

    #[test]
    fn test_array_packed() {
        assert_eq!(
            Vector::<2, u64, VecPacked>::from_array([1, 2]).to_array(),
            [1, 2]
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).to_array(),
            [3, 4, 1]
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).to_array(),
            [2, 3, 4, 1]
        );

        assert_eq!(
            Vector::<2, u64, VecPacked>::from_array([1, 2]).as_array(),
            &[1, 2]
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).as_array(),
            &[3, 4, 1]
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).as_array(),
            &[2, 3, 4, 1]
        );

        assert_eq!(
            Vector::<2, u64, VecPacked>::from_array([1, 2]).as_array_mut(),
            &mut [1, 2]
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).as_array_mut(),
            &mut [3, 4, 1]
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).as_array_mut(),
            &mut [2, 3, 4, 1]
        );

        assert_eq!(
            Vector::<2, u64, VecPacked>::from_array([1, 2]).as_ptr(),
            [1, 2].as_ptr()
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).as_ptr(),
            [3, 4, 1].as_ptr()
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).as_ptr(),
            [2, 3, 4, 1].as_ptr()
        );

        assert_eq!(
            Vector::<2, u64, VecPacked>::from_array([1, 2]).as_mut_ptr(),
            [1, 2].as_mut_ptr()
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).as_mut_ptr(),
            [3, 4, 1].as_mut_ptr()
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).as_mut_ptr(),
            [2, 3, 4, 1].as_mut_ptr()
        );

        assert_eq!(
            Vector::<2, u64, VecPacked>::from_fn(|i| [1, 2][i]).to_array(),
            [1, 2]
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_fn(|i| [3, 4, 1][i]).to_array(),
            [3, 4, 1]
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_fn(|i| [2, 3, 4, 1][i]).to_array(),
            [2, 3, 4, 1]
        );

        assert_eq!(
            Vector::<2, u64, VecPacked>::from_array([1, 2])
                .map(|x| {
                    let idx = [1, 2].into_iter().position(|y| y == x).unwrap();
                    [1, 2][idx]
                })
                .to_array(),
            [1, 2]
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1])
                .map(|x| {
                    let idx = [3, 4, 1].into_iter().position(|y| y == x).unwrap();
                    [3, 4, 1][idx]
                })
                .to_array(),
            [3, 4, 1]
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1])
                .map(|x| {
                    let idx = [2, 3, 4, 1].into_iter().position(|y| y == x).unwrap();
                    [2, 3, 4, 1][idx]
                })
                .to_array(),
            [2, 3, 4, 1]
        );

        assert_eq!(
            Vector::<2, u64, VecPacked>::from_array([1, 2]).fold(|x, y| x + y),
            1 + 2
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).fold(|x, y| x + y),
            3 + 4 + 1
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).fold(|x, y| x + y),
            2 + 3 + 4 + 1
        );

        assert_eq!(
            Vector::<2, u64, VecPacked>::from_array([1, 2]).all(|x| x == 1),
            false
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).all(|x| x == 1),
            false
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).all(|x| x == 1),
            false
        );

        assert_eq!(
            Vector::<2, u64, VecPacked>::from_array([1, 2]).any(|x| x == 1),
            true
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).any(|x| x == 1),
            true
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).any(|x| x == 1),
            true
        );

        assert_eq!(
            Vector::<2, u64, VecPacked>::from_array([1, 2]).count(|x| x == 1),
            1
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).count(|x| x == 1),
            1
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).count(|x| x == 1),
            1
        );

        assert_eq!(Vector::<2, u64, VecPacked>::from_array([1, 2]).len(), 2);
        assert_eq!(Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).len(), 3);
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).len(),
            4
        );
    }

    #[test]
    fn test_splat_packed() {
        assert_eq!(Vector::<2, u64, VecPacked>::splat(1).to_array(), [1; 2]);
        assert_eq!(Vector::<3, u64, VecPacked>::splat(3).to_array(), [3; 3]);
        assert_eq!(Vector::<4, u64, VecPacked>::splat(2).to_array(), [2; 4]);

        assert_eq!(
            Vector::<2, u64, VecPacked>::const_splat(1).to_array(),
            [1; 2]
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::const_splat(3).to_array(),
            [3; 3]
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::const_splat(2).to_array(),
            [2; 4]
        );
    }

    #[test]
    fn test_storage_packed() {
        assert_eq!(
            Vector::<2, u64, VecPacked>::from_array([1, 2]).align(),
            Vector::<2, u64, VecAligned>::from_array([1, 2]),
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).align(),
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]),
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).align(),
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]),
        );

        assert_eq!(
            Vector::<2, u64, VecPacked>::from_array([1, 2]).pack(),
            Vector::<2, u64, VecPacked>::from_array([1, 2]),
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).pack(),
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]),
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).pack(),
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]),
        );

        assert_eq!(
            Vector::<2, u64, VecPacked>::from_array([1, 2]).to_storage::<VecAligned>(),
            Vector::<2, u64, VecAligned>::from_array([1, 2]),
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).to_storage::<VecAligned>(),
            Vector::<3, u64, VecAligned>::from_array([3, 4, 1]),
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).to_storage::<VecAligned>(),
            Vector::<4, u64, VecAligned>::from_array([2, 3, 4, 1]),
        );

        assert_eq!(
            Vector::<2, u64, VecPacked>::from_array([1, 2]).to_storage::<VecPacked>(),
            Vector::<2, u64, VecPacked>::from_array([1, 2]),
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).to_storage::<VecPacked>(),
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]),
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).to_storage::<VecPacked>(),
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]),
        );

        assert_eq!(
            Vector::<2, u64, VecPacked>::from_array([1, 2]).is_aligned(),
            false
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).is_aligned(),
            false
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).is_aligned(),
            false
        );
    }

    #[test]
    fn test_swizzle_packed() {
        assert_eq!(Vector::<2, u64, VecPacked>::from_array([1, 2]).x(), 1);
        assert_eq!(Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).y(), 4);
        assert_eq!(Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).z(), 4);

        assert_eq!(
            Vector::<2, u64, VecPacked>::from_array([1, 2]).yy(),
            Vector::<2, u64, VecPacked>::from_array([2, 2]),
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).zy(),
            Vector::<2, u64, VecPacked>::from_array([1, 4]),
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).xw(),
            Vector::<2, u64, VecPacked>::from_array([2, 1]),
        );

        assert_eq!(
            Vector::<2, u64, VecPacked>::from_array([1, 2]).xyy(),
            Vector::<3, u64, VecPacked>::from_array([1, 2, 2]),
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).yzy(),
            Vector::<3, u64, VecPacked>::from_array([4, 1, 4]),
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).wxy(),
            Vector::<3, u64, VecPacked>::from_array([1, 2, 3]),
        );

        assert_eq!(
            Vector::<2, u64, VecPacked>::from_array([1, 2]).xxyy(),
            Vector::<4, u64, VecPacked>::from_array([1, 1, 2, 2]),
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).yzyz(),
            Vector::<4, u64, VecPacked>::from_array([4, 1, 4, 1]),
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).wxyw(),
            Vector::<4, u64, VecPacked>::from_array([1, 2, 3, 1]),
        );
    }

    #[test]
    fn test_swizzle_ref_packed() {
        assert_eq!(Vector::<2, u64, VecPacked>::from_array([1, 2]).x_ref(), &1);
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).y_ref(),
            &4
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).z_ref(),
            &4
        );

        assert_eq!(
            Vector::<2, u64, VecPacked>::from_array([1, 2]).xy_ref(),
            &Vector::<2, u64, VecPacked>::from_array([1, 2]),
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([1, 2, 3]).yz_ref(),
            &Vector::<2, u64, VecPacked>::from_array([2, 3]),
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([1, 2, 3, 4]).zw_ref(),
            &Vector::<2, u64, VecPacked>::from_array([3, 4]),
        );

        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([1, 2, 3]).xyz_ref(),
            &Vector::<3, u64, VecPacked>::from_array([1, 2, 3]),
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([1, 2, 3, 4]).yzw_ref(),
            &Vector::<3, u64, VecPacked>::from_array([2, 3, 4]),
        );

        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([1, 2, 3, 4]).xyzw_ref(),
            &Vector::<4, u64, VecPacked>::from_array([1, 2, 3, 4]),
        );
    }

    #[test]
    fn test_swizzle_mut_packed() {
        assert_eq!(
            Vector::<2, u64, VecPacked>::from_array([1, 2]).x_mut(),
            &mut 1
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).y_mut(),
            &mut 4
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).z_mut(),
            &mut 4
        );

        assert_eq!(
            Vector::<2, u64, VecPacked>::from_array([1, 2]).x_y_mut(),
            (&mut 1, &mut 2)
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).xy_z_mut(),
            (&mut Vector::<2, u64, VecPacked>::from_array([3, 4]), &mut 1)
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).xy_zw_mut(),
            (
                &mut Vector::<2, u64, VecPacked>::from_array([2, 3]),
                &mut Vector::<2, u64, VecPacked>::from_array([4, 1]),
            ),
        );
    }

    #[test]
    fn test_swizzle_with_packed() {
        assert_eq!(
            Vector::<2, u64, VecPacked>::from_array([1, 2]).with_x(3),
            Vector::<2, u64, VecPacked>::from_array([3, 2]),
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).with_y(2),
            Vector::<3, u64, VecPacked>::from_array([3, 2, 1]),
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).with_z(3),
            Vector::<4, u64, VecPacked>::from_array([2, 3, 3, 1]),
        );

        assert_eq!(
            Vector::<2, u64, VecPacked>::from_array([1, 2]).with_xy(vec2!(3, 4)),
            Vector::<2, u64, VecPacked>::from_array([3, 4]),
        );
        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([3, 4, 1]).with_zy(vec2!(2, 3)),
            Vector::<3, u64, VecPacked>::from_array([3, 3, 2]),
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).with_xw(vec2!(3, 4)),
            Vector::<4, u64, VecPacked>::from_array([3, 2, 3, 4]),
        );

        assert_eq!(
            Vector::<3, u64, VecPacked>::from_array([1, 2, 3]).with_xzy(vec3!(3, 4, 1)),
            Vector::<3, u64, VecPacked>::from_array([3, 1, 4]),
        );
        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).with_ywx(vec3!(3, 4, 1)),
            Vector::<4, u64, VecPacked>::from_array([1, 3, 4, 4]),
        );

        assert_eq!(
            Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]).with_xywz(vec4!(3, 4, 1, 2)),
            Vector::<4, u64, VecPacked>::from_array([3, 4, 2, 1]),
        );
    }

    #[test]
    fn test_swizzle_set_packed() {
        assert_eq!(
            {
                let mut vector = Vector::<2, u64, VecPacked>::from_array([1, 2]);
                vector.set_x(3);
                vector
            },
            Vector::<2, u64, VecPacked>::from_array([3, 2]),
        );
        assert_eq!(
            {
                let mut vector = Vector::<3, u64, VecPacked>::from_array([3, 4, 1]);
                vector.set_y(2);
                vector
            },
            Vector::<3, u64, VecPacked>::from_array([3, 2, 1]),
        );
        assert_eq!(
            {
                let mut vector = Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]);
                vector.set_z(3);
                vector
            },
            Vector::<4, u64, VecPacked>::from_array([2, 3, 3, 1]),
        );

        assert_eq!(
            {
                let mut vector = Vector::<2, u64, VecPacked>::from_array([1, 2]);
                vector.set_xy(vec2!(3, 4));
                vector
            },
            Vector::<2, u64, VecPacked>::from_array([3, 4]),
        );
        assert_eq!(
            {
                let mut vector = Vector::<3, u64, VecPacked>::from_array([3, 4, 1]);
                vector.set_zy(vec2!(2, 3));
                vector
            },
            Vector::<3, u64, VecPacked>::from_array([3, 3, 2]),
        );
        assert_eq!(
            {
                let mut vector = Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]);
                vector.set_xw(vec2!(3, 4));
                vector
            },
            Vector::<4, u64, VecPacked>::from_array([3, 2, 3, 4]),
        );

        assert_eq!(
            {
                let mut vector = Vector::<3, u64, VecPacked>::from_array([1, 2, 3]);
                vector.set_xzy(vec3!(3, 4, 1));
                vector
            },
            Vector::<3, u64, VecPacked>::from_array([3, 1, 4]),
        );
        assert_eq!(
            {
                let mut vector = Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]);
                vector.set_ywx(vec3!(3, 4, 1));
                vector
            },
            Vector::<4, u64, VecPacked>::from_array([1, 3, 4, 4]),
        );

        assert_eq!(
            {
                let mut vector = Vector::<4, u64, VecPacked>::from_array([2, 3, 4, 1]);
                vector.set_xywz(vec4!(3, 4, 1, 2));
                vector
            },
            Vector::<4, u64, VecPacked>::from_array([3, 4, 2, 1]),
        );
    }

    #[test]
    fn test_constructor_packed() {
        assert_eq!(vec2p!(1, 2).to_array(), [1, 2]);
        assert_eq!(vec2p!(vec2p!(1, 2)).to_array(), [1, 2]);

        assert_eq!(vec3p!(1, 2, 3).to_array(), [1, 2, 3]);
        assert_eq!(vec3p!(1, vec2p!(2, 3)).to_array(), [1, 2, 3]);
        assert_eq!(vec3p!(vec2p!(1, 2), 3).to_array(), [1, 2, 3]);
        assert_eq!(vec3p!(vec3p!(1, 2, 3)).to_array(), [1, 2, 3]);

        assert_eq!(vec4p!(1, 2, 3, 4).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4p!(1, 2, vec2p!(3, 4)).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4p!(1, vec2p!(2, 3), 4).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4p!(1, vec3p!(2, 3, 4)).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4p!(vec2p!(1, 2), 3, 4).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4p!(vec2p!(1, 2), vec2p!(3, 4)).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4p!(vec3p!(1, 2, 3), 4).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4p!(vec4p!(1, 2, 3, 4)).to_array(), [1, 2, 3, 4]);
    }

    // These tests are generated for all primitive number types

    #[test]
    fn test_ops_aligned() {
        assert_eq!((vec2!(0, 1) + vec2!(2, 3)).to_array(), [2, 4]);
        assert_eq!((vec2!(5, 3) - vec2!(2, 2)).to_array(), [3, 1]);
        assert_eq!((vec2!(5, 3) * vec2!(2, 3)).to_array(), [10, 9]);
        assert_eq!((vec2!(5, 3) / vec2!(2, 3)).to_array(), [2, 1]);
        assert_eq!((vec2!(5, 3) % vec2!(2, 3)).to_array(), [1, 0]);
        assert_eq!((vec2!(5, 3) * 2).to_array(), [10, 6]);
        assert_eq!((vec2!(5, 3) / 2).to_array(), [2, 1]);
        assert_eq!((vec2!(5, 3) % 2).to_array(), [1, 1]);

        assert_eq!((vec3!(0, 1, 2) + vec3!(3, 4, 5)).to_array(), [3, 5, 7]);
        assert_eq!((vec3!(5, 3, 2) - vec3!(2, 2, 2)).to_array(), [3, 1, 0]);
        assert_eq!((vec3!(5, 3, 2) * vec3!(2, 3, 4)).to_array(), [10, 9, 8]);
        assert_eq!((vec3!(5, 3, 2) / vec3!(2, 3, 4)).to_array(), [2, 1, 0]);
        assert_eq!((vec3!(5, 3, 2) % vec3!(2, 3, 4)).to_array(), [1, 0, 2]);
        assert_eq!((vec3!(5, 3, 2) * 2).to_array(), [10, 6, 4]);
        assert_eq!((vec3!(5, 3, 2) / 2).to_array(), [2, 1, 1]);
        assert_eq!((vec3!(5, 3, 2) % 2).to_array(), [1, 1, 0]);

        assert_eq!(
            (vec4!(0, 1, 2, 3) + vec4!(4, 5, 6, 7)).to_array(),
            [4, 6, 8, 10]
        );
        assert_eq!(
            (vec4!(5, 3, 2, 1) - vec4!(2, 2, 2, 2)).to_array(),
            [3, 1, 0, 1]
        );
        assert_eq!(
            (vec4!(5, 3, 2, 1) * vec4!(2, 3, 4, 5)).to_array(),
            [10, 9, 8, 5]
        );
        assert_eq!(
            (vec4!(5, 3, 2, 1) / vec4!(2, 3, 4, 5)).to_array(),
            [2, 1, 0, 1]
        );
        assert_eq!(
            (vec4!(5, 3, 2, 1) % vec4!(2, 3, 4, 5)).to_array(),
            [1, 0, 2, 1]
        );
        assert_eq!((vec4!(5, 3, 2, 1) * 2).to_array(), [10, 6, 4, 2]);
        assert_eq!((vec4!(5, 3, 2, 1) / 2).to_array(), [2, 1, 1, 1]);
        assert_eq!((vec4!(5, 3, 2, 1) % 2).to_array(), [1, 1, 0, 1]);
    }

    // These tests are generated for all primitive number types

    #[test]
    fn test_ops_packed() {
        assert_eq!((vec2p!(0, 1) + vec2p!(2, 3)).to_array(), [2, 4]);
        assert_eq!((vec2p!(5, 3) - vec2p!(2, 2)).to_array(), [3, 1]);
        assert_eq!((vec2p!(5, 3) * vec2p!(2, 3)).to_array(), [10, 9]);
        assert_eq!((vec2p!(5, 3) / vec2p!(2, 3)).to_array(), [2, 1]);
        assert_eq!((vec2p!(5, 3) % vec2p!(2, 3)).to_array(), [1, 0]);
        assert_eq!((vec2p!(5, 3) * 2).to_array(), [10, 6]);
        assert_eq!((vec2p!(5, 3) / 2).to_array(), [2, 1]);
        assert_eq!((vec2p!(5, 3) % 2).to_array(), [1, 1]);

        assert_eq!((vec3p!(0, 1, 2) + vec3p!(3, 4, 5)).to_array(), [3, 5, 7]);
        assert_eq!((vec3p!(5, 3, 2) - vec3p!(2, 2, 2)).to_array(), [3, 1, 0]);
        assert_eq!((vec3p!(5, 3, 2) * vec3p!(2, 3, 4)).to_array(), [10, 9, 8]);
        assert_eq!((vec3p!(5, 3, 2) / vec3p!(2, 3, 4)).to_array(), [2, 1, 0]);
        assert_eq!((vec3p!(5, 3, 2) % vec3p!(2, 3, 4)).to_array(), [1, 0, 2]);
        assert_eq!((vec3p!(5, 3, 2) * 2).to_array(), [10, 6, 4]);
        assert_eq!((vec3p!(5, 3, 2) / 2).to_array(), [2, 1, 1]);
        assert_eq!((vec3p!(5, 3, 2) % 2).to_array(), [1, 1, 0]);

        assert_eq!(
            (vec4p!(0, 1, 2, 3) + vec4p!(4, 5, 6, 7)).to_array(),
            [4, 6, 8, 10]
        );
        assert_eq!(
            (vec4p!(5, 3, 2, 1) - vec4p!(2, 2, 2, 2)).to_array(),
            [3, 1, 0, 1]
        );
        assert_eq!(
            (vec4p!(5, 3, 2, 1) * vec4p!(2, 3, 4, 5)).to_array(),
            [10, 9, 8, 5]
        );
        assert_eq!(
            (vec4p!(5, 3, 2, 1) / vec4p!(2, 3, 4, 5)).to_array(),
            [2, 1, 0, 1]
        );
        assert_eq!(
            (vec4p!(5, 3, 2, 1) % vec4p!(2, 3, 4, 5)).to_array(),
            [1, 0, 2, 1]
        );
        assert_eq!((vec4p!(5, 3, 2, 1) * 2).to_array(), [10, 6, 4, 2]);
        assert_eq!((vec4p!(5, 3, 2, 1) / 2).to_array(), [2, 1, 1, 1]);
        assert_eq!((vec4p!(5, 3, 2, 1) % 2).to_array(), [1, 1, 0, 1]);
    }

    // These tests are generated for all int types

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_add2_overflow_aligned() {
        assert_eq!((vec2!(u64::MAX, 1) + vec2!(1, 3)).to_array(), [u64::MIN, 4]);
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_add3_overflow_aligned() {
        assert_eq!(
            (vec3!(u64::MAX, 1, 3) + vec3!(1, 3, 5)).to_array(),
            [u64::MIN, 4, 8]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_add4_overflow_aligned() {
        assert_eq!(
            (vec4!(u64::MAX, 1, 3, 5) + vec4!(1, 3, 5, 7)).to_array(),
            [u64::MIN, 4, 8, 12]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_sub2_overflow_aligned() {
        assert_eq!((vec2!(u64::MIN, 5) - vec2!(1, 3)).to_array(), [u64::MAX, 2]);
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_sub3_overflow_aligned() {
        assert_eq!(
            (vec3!(u64::MIN, 5, 7) - vec3!(1, 3, 5)).to_array(),
            [u64::MAX, 2, 2]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_sub4_overflow_aligned() {
        assert_eq!(
            (vec4!(u64::MIN, 5, 7, 9) - vec4!(1, 3, 5, 7)).to_array(),
            [u64::MAX, 2, 2, 2]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_mul2_overflow_aligned() {
        assert_eq!(
            (vec2!(u64::MAX, 5) * vec2!(2, 3)).to_array(),
            [u64::MAX * 2, 15]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_mul3_overflow_aligned() {
        assert_eq!(
            (vec3!(u64::MAX, 5, 7) * vec3!(2, 3, 4)).to_array(),
            [u64::MAX * 2, 15, 28]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_mul4_overflow_aligned() {
        assert_eq!(
            (vec4!(u64::MAX, 5, 7, 9) * vec4!(2, 3, 4, 5)).to_array(),
            [u64::MAX * 2, 15, 28, 45]
        );
    }

    #[test]
    #[should_panic]
    fn test_div2_by_zero_aligned() {
        println!("{}", vec2!(3, 5) / vec2!(0, 3));
    }

    #[test]
    #[should_panic]
    fn test_div3_by_zero_aligned() {
        println!("{}", vec3!(3, 5, 7) / vec3!(0, 3, 5));
    }

    #[test]
    #[should_panic]
    fn test_div4_by_zero_aligned() {
        println!("{}", vec4!(3, 5, 7, 9) / vec4!(0, 3, 5, 7));
    }

    #[test]
    #[should_panic]
    fn test_rem2_by_zero_aligned() {
        println!("{}", vec2!(3, 5) % vec2!(0, 3));
    }

    #[test]
    #[should_panic]
    fn test_rem3_by_zero_aligned() {
        println!("{}", vec3!(3, 5, 7) % vec3!(0, 3, 5));
    }

    #[test]
    #[should_panic]
    fn test_rem4_by_zero_aligned() {
        println!("{}", vec4!(3, 5, 7, 9) % vec4!(0, 3, 5, 7));
    }

    // These tests are generated for all int types

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_add2_overflow_packed() {
        assert_eq!(
            (vec2p!(u64::MAX, 1) + vec2p!(1, 3)).to_array(),
            [u64::MIN, 4]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_add3_overflow_packed() {
        assert_eq!(
            (vec3p!(u64::MAX, 1, 3) + vec3p!(1, 3, 5)).to_array(),
            [u64::MIN, 4, 8]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_add4_overflow_packed() {
        assert_eq!(
            (vec4p!(u64::MAX, 1, 3, 5) + vec4p!(1, 3, 5, 7)).to_array(),
            [u64::MIN, 4, 8, 12]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_sub2_overflow_packed() {
        assert_eq!(
            (vec2p!(u64::MIN, 5) - vec2p!(1, 3)).to_array(),
            [u64::MAX, 2]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_sub3_overflow_packed() {
        assert_eq!(
            (vec3p!(u64::MIN, 5, 7) - vec3p!(1, 3, 5)).to_array(),
            [u64::MAX, 2, 2]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_sub4_overflow_packed() {
        assert_eq!(
            (vec4p!(u64::MIN, 5, 7, 9) - vec4p!(1, 3, 5, 7)).to_array(),
            [u64::MAX, 2, 2, 2]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_mul2_overflow_packed() {
        assert_eq!(
            (vec2p!(u64::MAX, 5) * vec2p!(2, 3)).to_array(),
            [u64::MAX * 2, 15]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_mul3_overflow_packed() {
        assert_eq!(
            (vec3p!(u64::MAX, 5, 7) * vec3p!(2, 3, 4)).to_array(),
            [u64::MAX * 2, 15, 28]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_mul4_overflow_packed() {
        assert_eq!(
            (vec4p!(u64::MAX, 5, 7, 9) * vec4p!(2, 3, 4, 5)).to_array(),
            [u64::MAX * 2, 15, 28, 45]
        );
    }

    #[test]
    #[should_panic]
    fn test_div2_by_zero_packed() {
        println!("{}", vec2p!(3, 5) / vec2p!(0, 3));
    }

    #[test]
    #[should_panic]
    fn test_div3_by_zero_packed() {
        println!("{}", vec3p!(3, 5, 7) / vec3p!(0, 3, 5));
    }

    #[test]
    #[should_panic]
    fn test_div4_by_zero_packed() {
        println!("{}", vec4p!(3, 5, 7, 9) / vec4p!(0, 3, 5, 7));
    }

    #[test]
    #[should_panic]
    fn test_rem2_by_zero_packed() {
        println!("{}", vec2p!(3, 5) % vec2p!(0, 3));
    }

    #[test]
    #[should_panic]
    fn test_rem3_by_zero_packed() {
        println!("{}", vec3p!(3, 5, 7) % vec3p!(0, 3, 5));
    }

    #[test]
    #[should_panic]
    fn test_rem4_by_zero_packed() {
        println!("{}", vec4p!(3, 5, 7, 9) % vec4p!(0, 3, 5, 7));
    }
}
