// This file is automatically generated.
// To edit this file edit the codegen crate instead.

use crate::{Usize, vector::*};

impl<const N: usize, A: VecAlignment> Vector<N, u32, A>
where
    Usize<N>: VecLen,
{
    // The following items are generated for all number types

    /// A vector of all minimum values.
    pub const MIN: Self = Self::const_splat(u32::MIN);
    /// A vector of all maximum values.
    pub const MAX: Self = Self::const_splat(u32::MAX);

    /// Converts `self` to a vector of `f32` elements.
    #[inline(always)]
    pub fn as_f32(self) -> Vector<N, f32, A> {
        self.map(|x| x as f32)
    }

    /// Converts `self` to a vector of `f64` elements.
    #[inline(always)]
    pub fn as_f64(self) -> Vector<N, f64, A> {
        self.map(|x| x as f64)
    }

    /// Converts `self` to a vector of `i8` elements.
    #[inline(always)]
    pub fn as_i8(self) -> Vector<N, i8, A> {
        self.map(|x| x as i8)
    }

    /// Converts `self` to a vector of `i16` elements.
    #[inline(always)]
    pub fn as_i16(self) -> Vector<N, i16, A> {
        self.map(|x| x as i16)
    }

    /// Converts `self` to a vector of `i32` elements.
    #[inline(always)]
    pub fn as_i32(self) -> Vector<N, i32, A> {
        self.map(|x| x as i32)
    }

    /// Converts `self` to a vector of `i64` elements.
    #[inline(always)]
    pub fn as_i64(self) -> Vector<N, i64, A> {
        self.map(|x| x as i64)
    }

    /// Converts `self` to a vector of `i128` elements.
    #[inline(always)]
    pub fn as_i128(self) -> Vector<N, i128, A> {
        self.map(|x| x as i128)
    }

    /// Converts `self` to a vector of `isize` elements.
    #[inline(always)]
    pub fn as_isize(self) -> Vector<N, isize, A> {
        self.map(|x| x as isize)
    }

    /// Converts `self` to a vector of `u8` elements.
    #[inline(always)]
    pub fn as_u8(self) -> Vector<N, u8, A> {
        self.map(|x| x as u8)
    }

    /// Converts `self` to a vector of `u16` elements.
    #[inline(always)]
    pub fn as_u16(self) -> Vector<N, u16, A> {
        self.map(|x| x as u16)
    }

    /// Converts `self` to a vector of `u64` elements.
    #[inline(always)]
    pub fn as_u64(self) -> Vector<N, u64, A> {
        self.map(|x| x as u64)
    }

    /// Converts `self` to a vector of `u128` elements.
    #[inline(always)]
    pub fn as_u128(self) -> Vector<N, u128, A> {
        self.map(|x| x as u128)
    }

    /// Converts `self` to a vector of `usize` elements.
    #[inline(always)]
    pub fn as_usize(self) -> Vector<N, usize, A> {
        self.map(|x| x as usize)
    }

    // The following items are generated for all int types

    /// Returns `-self` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_neg(self) -> Option<Self> {
        self.map(|x| x.checked_neg()).flatten()
    }

    /// Returns `self + other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_add(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self[i].checked_add(other[i])).flatten()
    }

    /// Returns `self - other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_sub(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self[i].checked_sub(other[i])).flatten()
    }

    /// Returns `self * other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_mul(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self[i].checked_mul(other[i])).flatten()
    }

    /// Returns `self / other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_div(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self[i].checked_div(other[i])).flatten()
    }

    /// Returns `self % other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_rem(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self[i].checked_rem(other[i])).flatten()
    }

    /// Returns `-self` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_neg(self) -> Self {
        self.map(|x| x.wrapping_neg())
    }

    /// Returns `self + other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_add(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].wrapping_add(other[i]))
    }

    /// Returns `self - other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_sub(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].wrapping_sub(other[i]))
    }

    /// Returns `self * other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_mul(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].wrapping_mul(other[i]))
    }

    /// Returns `self / other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_div(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].wrapping_div(other[i]))
    }

    /// Returns `self % other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_rem(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].wrapping_rem(other[i]))
    }

    /// Returns `self + other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_add(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].saturating_add(other[i]))
    }

    /// Returns `self - other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_sub(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].saturating_sub(other[i]))
    }

    /// Returns `self * other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_mul(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].saturating_mul(other[i]))
    }

    /// Returns `self / other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_div(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].saturating_div(other[i]))
    }
}

impl<const N: usize, A: VecAlignment> Vector<N, u32, A>
where
    Usize<N>: VecLen,
{
    // The following items are generated for all primitive types

    /// Returns `self == other` and supports const contexts.
    #[inline(always)]
    pub const fn const_eq(self, other: Vector<N, u32, impl VecAlignment>) -> bool {
        let mut i = 0;
        while i < N {
            if self.as_array()[i] != other.as_array()[i] {
                return false;
            }
            i += 1;
        }
        true
    }

    /// Returns `self != other` and supports const contexts.
    #[inline(always)]
    pub const fn const_ne(self, other: Vector<N, u32, impl VecAlignment>) -> bool {
        let mut i = 0;
        while i < N {
            if self.as_array()[i] != other.as_array()[i] {
                return true;
            }
            i += 1;
        }
        false
    }

    /// Returns `self.eq_mask(other)` and supports const contexts.
    pub const fn const_eq_mask(
        self,
        other: Vector<N, u32, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] == other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.ne_mask(other)` and supports const contexts.
    pub const fn const_ne_mask(
        self,
        other: Vector<N, u32, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] != other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.lt_mask(other)` and supports const contexts.
    pub const fn const_lt_mask(
        self,
        other: Vector<N, u32, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] < other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.gt_mask(other)` and supports const contexts.
    pub const fn const_gt_mask(
        self,
        other: Vector<N, u32, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] > other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.le_mask(other)` and supports const contexts.
    pub const fn const_le_mask(
        self,
        other: Vector<N, u32, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] <= other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.ge_mask(other)` and supports const contexts.
    pub const fn const_ge_mask(
        self,
        other: Vector<N, u32, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] >= other.as_array()[i];
            i += 1;
        }
        output
    }

    // The following items are generated for all number types

    /// Returns `self + other` and supports const contexts.
    #[inline(always)]
    pub const fn const_add(mut self, other: Vector<N, u32, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] + other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self - other` and supports const contexts.
    #[inline(always)]
    pub const fn const_sub(mut self, other: Vector<N, u32, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] - other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self * other` and supports const contexts.
    #[inline(always)]
    pub const fn const_mul(mut self, other: Vector<N, u32, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] * other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self / other` and supports const contexts.
    #[inline(always)]
    pub const fn const_div(mut self, other: Vector<N, u32, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] / other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self % other` and supports const contexts.
    #[inline(always)]
    pub const fn const_rem(mut self, other: Vector<N, u32, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] % other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self.min(other)` and supports const contexts.
    #[inline(always)]
    pub const fn const_min(mut self, other: Vector<N, u32, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            if other.as_array()[i] < self.as_array()[i] {
                self.as_array_mut()[i] = other.as_array()[i];
            }
            i += 1;
        }
        self
    }

    /// Returns `self.max(other)` and supports const contexts.
    #[inline(always)]
    pub const fn const_max(mut self, other: Vector<N, u32, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            if other.as_array()[i] > self.as_array()[i] {
                self.as_array_mut()[i] = other.as_array()[i];
            }
            i += 1;
        }
        self
    }

    /// Returns `self.clamp(min, max)` and supports const contexts.
    #[inline(always)]
    pub const fn const_clamp(
        self,
        min: Vector<N, u32, impl VecAlignment>,
        max: Vector<N, u32, impl VecAlignment>,
    ) -> Self {
        #[cfg(debug_assertions)]
        assert!(
            min.const_le_mask(max).const_all_true(),
            "min must be less than or equal to max"
        );

        self.const_min(max).const_max(min)
    }

    /// Returns `self.sum()` and supports const contexts.
    #[inline(always)]
    pub const fn const_sum(self) -> u32 {
        let mut output = 0 as u32;
        let mut i = 0;
        while i < N {
            output += self.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.product()` and supports const contexts.
    #[inline(always)]
    pub const fn const_product(self) -> u32 {
        let mut output = 1 as u32;
        let mut i = 0;
        while i < N {
            output *= self.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.dot(other)` and supports const contexts.
    #[inline(always)]
    pub const fn const_dot(self, other: Vector<N, u32, impl VecAlignment>) -> u32 {
        let mut output = 0 as u32;
        let mut i = 0;
        while i < N {
            output += self.as_array()[i] * other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.mag_sq()` and supports const contexts.
    #[inline(always)]
    pub const fn const_mag_sq(self) -> u32 {
        let mut output = 0 as u32;
        let mut i = 0;
        while i < N {
            output += self.as_array()[i] * self.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.distance_sq(other)` and supports const contexts.
    #[inline(always)]
    pub const fn const_distance_sq(self, other: Vector<N, u32, impl VecAlignment>) -> u32 {
        self.const_abs_diff(other).const_mag_sq()
    }

    /// Version of `Vector::as_f32` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_f32(self) -> Vector<N, f32, A> {
        let mut output = Vector::<N, f32, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as f32;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_f64` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_f64(self) -> Vector<N, f64, A> {
        let mut output = Vector::<N, f64, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as f64;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i8` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i8(self) -> Vector<N, i8, A> {
        let mut output = Vector::<N, i8, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i8;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i16` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i16(self) -> Vector<N, i16, A> {
        let mut output = Vector::<N, i16, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i16;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i32` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i32(self) -> Vector<N, i32, A> {
        let mut output = Vector::<N, i32, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i32;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i64` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i64(self) -> Vector<N, i64, A> {
        let mut output = Vector::<N, i64, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i64;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i128` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i128(self) -> Vector<N, i128, A> {
        let mut output = Vector::<N, i128, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i128;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_isize` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_isize(self) -> Vector<N, isize, A> {
        let mut output = Vector::<N, isize, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as isize;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_u8` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_u8(self) -> Vector<N, u8, A> {
        let mut output = Vector::<N, u8, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as u8;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_u16` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_u16(self) -> Vector<N, u16, A> {
        let mut output = Vector::<N, u16, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as u16;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_u64` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_u64(self) -> Vector<N, u64, A> {
        let mut output = Vector::<N, u64, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as u64;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_u128` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_u128(self) -> Vector<N, u128, A> {
        let mut output = Vector::<N, u128, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as u128;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_usize` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_usize(self) -> Vector<N, usize, A> {
        let mut output = Vector::<N, usize, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as usize;
            i += 1;
        }
        output
    }

    // The following items are generated for all int types

    /// Returns `!self` and supports const contexts.
    #[inline(always)]
    pub const fn const_not(mut self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = !self.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self << other` and supports const contexts.
    #[inline(always)]
    pub const fn const_shl(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] << other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self >> other` and supports const contexts.
    #[inline(always)]
    pub const fn const_shr(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] >> other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self & other` and supports const contexts.
    #[inline(always)]
    pub const fn const_bitand(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] & other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self | other` and supports const contexts.
    #[inline(always)]
    pub const fn const_bitor(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] | other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self ^ other` and supports const contexts.
    #[inline(always)]
    pub const fn const_bitxor(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] ^ other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Version of `Vector::checked_neg` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_checked_neg(mut self) -> Option<Self> {
        let mut i = 0;
        while i < N {
            match self.as_array()[i].checked_neg() {
                Some(value) => self.as_array_mut()[i] = value,
                None => return None,
            };

            i += 1;
        }

        Some(self)
    }

    /// Version of `Vector::checked_add` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_checked_add(mut self, other: Self) -> Option<Self> {
        let mut i = 0;
        while i < N {
            match self.as_array()[i].checked_add(other.as_array()[i]) {
                Some(value) => self.as_array_mut()[i] = value,
                None => return None,
            };

            i += 1;
        }

        Some(self)
    }

    /// Version of `Vector::checked_sub` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_checked_sub(mut self, other: Self) -> Option<Self> {
        let mut i = 0;
        while i < N {
            match self.as_array()[i].checked_sub(other.as_array()[i]) {
                Some(value) => self.as_array_mut()[i] = value,
                None => return None,
            };

            i += 1;
        }

        Some(self)
    }

    /// Version of `Vector::checked_mul` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_checked_mul(mut self, other: Self) -> Option<Self> {
        let mut i = 0;
        while i < N {
            match self.as_array()[i].checked_mul(other.as_array()[i]) {
                Some(value) => self.as_array_mut()[i] = value,
                None => return None,
            };

            i += 1;
        }

        Some(self)
    }

    /// Version of `Vector::checked_div` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_checked_div(mut self, other: Self) -> Option<Self> {
        let mut i = 0;
        while i < N {
            match self.as_array()[i].checked_div(other.as_array()[i]) {
                Some(value) => self.as_array_mut()[i] = value,
                None => return None,
            };

            i += 1;
        }

        Some(self)
    }

    /// Version of `Vector::checked_rem` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_checked_rem(mut self, other: Self) -> Option<Self> {
        let mut i = 0;
        while i < N {
            match self.as_array()[i].checked_rem(other.as_array()[i]) {
                Some(value) => self.as_array_mut()[i] = value,
                None => return None,
            };

            i += 1;
        }

        Some(self)
    }

    /// Version of `Vector::wrapping_neg` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_wrapping_neg(mut self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].wrapping_neg();
            i += 1;
        }

        self
    }

    /// Version of `Vector::wrapping_add` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_wrapping_add(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].wrapping_add(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::wrapping_sub` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_wrapping_sub(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].wrapping_sub(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::wrapping_mul` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_wrapping_mul(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].wrapping_mul(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::wrapping_div` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_wrapping_div(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].wrapping_div(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::wrapping_rem` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_wrapping_rem(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].wrapping_rem(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::saturating_add` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_saturating_add(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].saturating_add(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::saturating_sub` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_saturating_sub(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].saturating_sub(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::saturating_mul` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_saturating_mul(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].saturating_mul(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::saturating_div` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_saturating_div(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].saturating_div(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Returns `self.abs_diff(other)` and supports const contexts.
    #[inline(always)]
    pub const fn const_abs_diff(self, other: Vector<N, u32, impl VecAlignment>) -> Self {
        self.const_max(other).const_sub(self.const_min(other))
    }
}

impl ScalarZero for u32 {
    const ZERO: u32 = 0 as Self;
}

impl ScalarOne for u32 {
    const ONE: u32 = 1 as Self;
}

#[cfg(test)]
#[allow(arithmetic_overflow)]
mod tests {
    use crate::*;

    // These tests are generated for all primitive types

    #[test]
    fn test_array_aligned() {
        assert_eq!(
            Vector::<2, u32, VecAligned>::from_array([1, 2]).to_array(),
            [1, 2]
        );
        assert_eq!(
            Vector::<3, u32, VecAligned>::from_array([3, 4, 1]).to_array(),
            [3, 4, 1]
        );
        assert_eq!(
            Vector::<4, u32, VecAligned>::from_array([2, 3, 4, 1]).to_array(),
            [2, 3, 4, 1]
        );

        assert_eq!(
            Vector::<2, u32, VecAligned>::from_array([1, 2]).as_array(),
            &[1, 2]
        );
        assert_eq!(
            Vector::<3, u32, VecAligned>::from_array([3, 4, 1]).as_array(),
            &[3, 4, 1]
        );
        assert_eq!(
            Vector::<4, u32, VecAligned>::from_array([2, 3, 4, 1]).as_array(),
            &[2, 3, 4, 1]
        );

        assert_eq!(
            Vector::<2, u32, VecAligned>::from_array([1, 2]).as_array_mut(),
            &mut [1, 2]
        );
        assert_eq!(
            Vector::<3, u32, VecAligned>::from_array([3, 4, 1]).as_array_mut(),
            &mut [3, 4, 1]
        );
        assert_eq!(
            Vector::<4, u32, VecAligned>::from_array([2, 3, 4, 1]).as_array_mut(),
            &mut [2, 3, 4, 1]
        );

        assert_eq!(
            Vector::<2, u32, VecAligned>::from_fn(|i| [1, 2][i]).to_array(),
            [1, 2]
        );
        assert_eq!(
            Vector::<3, u32, VecAligned>::from_fn(|i| [3, 4, 1][i]).to_array(),
            [3, 4, 1]
        );
        assert_eq!(
            Vector::<4, u32, VecAligned>::from_fn(|i| [2, 3, 4, 1][i]).to_array(),
            [2, 3, 4, 1]
        );

        assert_eq!(
            vec2!(1, 2)
                .map(|x| {
                    let idx = [1, 2].into_iter().position(|y| y == x).unwrap();
                    [1, 2][idx]
                })
                .to_array(),
            [1, 2]
        );
        assert_eq!(
            vec3!(3, 4, 1)
                .map(|x| {
                    let idx = [3, 4, 1].into_iter().position(|y| y == x).unwrap();
                    [3, 4, 1][idx]
                })
                .to_array(),
            [3, 4, 1]
        );
        assert_eq!(
            vec4!(2, 3, 4, 1)
                .map(|x| {
                    let idx = [2, 3, 4, 1].into_iter().position(|y| y == x).unwrap();
                    [2, 3, 4, 1][idx]
                })
                .to_array(),
            [2, 3, 4, 1]
        );

        assert_eq!(vec2!(1, 2).fold(1, |x, y| x + y), 1 + 1 + 2);
        assert_eq!(vec3!(3, 4, 1).fold(1, |x, y| x + y), 1 + 3 + 4 + 1);
        assert_eq!(vec4!(2, 3, 4, 1).fold(1, |x, y| x + y), 1 + 2 + 3 + 4 + 1);

        assert_eq!(vec2!(1, 2).reduce(|x, y| x + y), 1 + 2);
        assert_eq!(vec3!(3, 4, 1).reduce(|x, y| x + y), 3 + 4 + 1);
        assert_eq!(vec4!(2, 3, 4, 1).reduce(|x, y| x + y), 2 + 3 + 4 + 1);

        assert_eq!(vec2!(1, 2).all(|x| x == 1), false);
        assert_eq!(vec3!(3, 4, 1).all(|x| x == 1), false);
        assert_eq!(vec4!(2, 3, 4, 1).all(|x| x == 1), false);

        assert_eq!(vec2!(1, 2).any(|x| x == 1), true);
        assert_eq!(vec3!(3, 4, 1).any(|x| x == 1), true);
        assert_eq!(vec4!(2, 3, 4, 1).any(|x| x == 1), true);

        assert_eq!(vec2!(1, 2).count(|x| x == 1), 1);
        assert_eq!(vec3!(3, 4, 1).count(|x| x == 1), 1);
        assert_eq!(vec4!(2, 3, 4, 1).count(|x| x == 1), 1);

        assert_eq!(vec2!(1, 2).len(), 2);
        assert_eq!(vec3!(3, 4, 1).len(), 3);
        assert_eq!(vec4!(2, 3, 4, 1).len(), 4);
    }

    #[test]
    fn test_splat_aligned() {
        assert_eq!(Vector::<2, u32, VecAligned>::splat(1).to_array(), [1; 2]);
        assert_eq!(Vector::<3, u32, VecAligned>::splat(3).to_array(), [3; 3]);
        assert_eq!(Vector::<4, u32, VecAligned>::splat(2).to_array(), [2; 4]);

        assert_eq!(
            Vector::<2, u32, VecAligned>::const_splat(1).to_array(),
            [1; 2]
        );
        assert_eq!(
            Vector::<3, u32, VecAligned>::const_splat(3).to_array(),
            [3; 3]
        );
        assert_eq!(
            Vector::<4, u32, VecAligned>::const_splat(2).to_array(),
            [2; 4]
        );
    }

    #[test]
    fn test_storage_aligned() {
        assert_eq!(vec2!(1, 2).align(), vec2!(1, 2),);
        assert_eq!(vec3!(3, 4, 1).align(), vec3!(3, 4, 1),);
        assert_eq!(vec4!(2, 3, 4, 1).align(), vec4!(2, 3, 4, 1),);

        assert_eq!(vec2!(1, 2).pack(), vec2!(1, 2),);
        assert_eq!(vec3!(3, 4, 1).pack(), vec3!(3, 4, 1),);
        assert_eq!(vec4!(2, 3, 4, 1).pack(), vec4!(2, 3, 4, 1),);

        assert_eq!(vec2!(1, 2).to_storage::<VecAligned>(), vec2!(1, 2),);
        assert_eq!(vec3!(3, 4, 1).to_storage::<VecAligned>(), vec3!(3, 4, 1),);
        assert_eq!(
            vec4!(2, 3, 4, 1).to_storage::<VecAligned>(),
            vec4!(2, 3, 4, 1),
        );

        assert_eq!(vec2!(1, 2).to_storage::<VecPacked>(), vec2!(1, 2),);
        assert_eq!(vec3!(3, 4, 1).to_storage::<VecPacked>(), vec3!(3, 4, 1),);
        assert_eq!(
            vec4!(2, 3, 4, 1).to_storage::<VecPacked>(),
            vec4!(2, 3, 4, 1),
        );

        assert_eq!(
            Vector::<2, u32, VecAligned>::from_array([1, 2]).is_aligned(),
            true
        );
        assert_eq!(
            Vector::<3, u32, VecAligned>::from_array([3, 4, 1]).is_aligned(),
            true
        );
        assert_eq!(
            Vector::<4, u32, VecAligned>::from_array([2, 3, 4, 1]).is_aligned(),
            true
        );
    }

    #[test]
    fn test_swizzle_aligned() {
        assert_eq!(vec2!(1, 2).x(), 1);
        assert_eq!(vec3!(3, 4, 1).y(), 4);
        assert_eq!(vec4!(2, 3, 4, 1).z(), 4);

        assert_eq!(vec2!(1, 2).yy(), vec2!(2, 2),);
        assert_eq!(vec3!(3, 4, 1).zy(), vec2!(1, 4),);
        assert_eq!(vec4!(2, 3, 4, 1).xw(), vec2!(2, 1),);

        assert_eq!(vec2!(1, 2).xyy(), vec3!(1, 2, 2),);
        assert_eq!(vec3!(3, 4, 1).yzy(), vec3!(4, 1, 4),);
        assert_eq!(vec4!(2, 3, 4, 1).wxy(), vec3!(1, 2, 3),);

        assert_eq!(vec2!(1, 2).xxyy(), vec4!(1, 1, 2, 2),);
        assert_eq!(vec3!(3, 4, 1).yzyz(), vec4!(4, 1, 4, 1),);
        assert_eq!(vec4!(2, 3, 4, 1).wxyw(), vec4!(1, 2, 3, 1),);
    }

    #[test]
    fn test_swizzle_ref_aligned() {
        assert_eq!(vec2!(1, 2).x_ref(), &1);
        assert_eq!(vec3!(3, 4, 1).y_ref(), &4);
        assert_eq!(vec4!(2, 3, 4, 1).z_ref(), &4);

        assert_eq!(vec2!(1, 2).xy_ref(), &vec2p!(1, 2),);
        assert_eq!(vec3!(1, 2, 3).yz_ref(), &vec2p!(2, 3),);
        assert_eq!(vec4!(1, 2, 3, 4).zw_ref(), &vec2p!(3, 4),);

        assert_eq!(vec3!(1, 2, 3).xyz_ref(), &vec3p!(1, 2, 3),);
        assert_eq!(vec4!(1, 2, 3, 4).yzw_ref(), &vec3p!(2, 3, 4),);

        assert_eq!(vec4!(1, 2, 3, 4).xyzw_ref(), &vec4p!(1, 2, 3, 4),);
    }

    #[test]
    fn test_swizzle_mut_aligned() {
        assert_eq!(vec2!(1, 2).x_mut(), &mut 1);
        assert_eq!(vec3!(3, 4, 1).y_mut(), &mut 4);
        assert_eq!(vec4!(2, 3, 4, 1).z_mut(), &mut 4);

        assert_eq!(vec2!(1, 2).x_y_mut(), (&mut 1, &mut 2));
        assert_eq!(vec3!(3, 4, 1).xy_z_mut(), (&mut vec2p!(3, 4), &mut 1));
        assert_eq!(
            vec4!(2, 3, 4, 1).xy_zw_mut(),
            (&mut vec2p!(2, 3), &mut vec2p!(4, 1)),
        );
    }

    #[test]
    fn test_swizzle_with_aligned() {
        assert_eq!(vec2!(1, 2).with_x(3), vec2!(3, 2),);
        assert_eq!(vec3!(3, 4, 1).with_y(2), vec3!(3, 2, 1),);
        assert_eq!(vec4!(2, 3, 4, 1).with_z(3), vec4!(2, 3, 3, 1),);

        assert_eq!(vec2!(1, 2).with_xy(vec2!(3, 4)), vec2!(3, 4),);
        assert_eq!(vec3!(3, 4, 1).with_zy(vec2!(2, 3)), vec3!(3, 3, 2),);
        assert_eq!(vec4!(2, 3, 4, 1).with_xw(vec2!(3, 4)), vec4!(3, 3, 4, 4),);

        assert_eq!(vec3!(1, 2, 3).with_xzy(vec3!(3, 4, 1)), vec3!(3, 1, 4),);
        assert_eq!(
            vec4!(2, 3, 4, 1).with_ywx(vec3!(3, 4, 1)),
            vec4!(1, 3, 4, 4),
        );

        assert_eq!(
            vec4!(2, 3, 4, 1).with_xywz(vec4!(3, 4, 1, 2)),
            vec4!(3, 4, 2, 1),
        );
    }

    #[test]
    fn test_swizzle_set_aligned() {
        assert_eq!(
            {
                let mut vector = vec2!(1, 2);
                vector.set_x(3);
                vector
            },
            vec2!(3, 2),
        );
        assert_eq!(
            {
                let mut vector = vec3!(3, 4, 1);
                vector.set_y(2);
                vector
            },
            vec3!(3, 2, 1),
        );
        assert_eq!(
            {
                let mut vector = vec4!(2, 3, 4, 1);
                vector.set_z(3);
                vector
            },
            vec4!(2, 3, 3, 1),
        );

        assert_eq!(
            {
                let mut vector = vec2!(1, 2);
                vector.set_xy(vec2!(3, 4));
                vector
            },
            vec2!(3, 4),
        );
        assert_eq!(
            {
                let mut vector = vec3!(3, 4, 1);
                vector.set_zy(vec2!(2, 3));
                vector
            },
            vec3!(3, 3, 2),
        );
        assert_eq!(
            {
                let mut vector = vec4!(2, 3, 4, 1);
                vector.set_xw(vec2!(3, 4));
                vector
            },
            vec4!(3, 3, 4, 4),
        );

        assert_eq!(
            {
                let mut vector = vec3!(1, 2, 3);
                vector.set_xzy(vec3!(3, 4, 1));
                vector
            },
            vec3!(3, 1, 4),
        );
        assert_eq!(
            {
                let mut vector = vec4!(2, 3, 4, 1);
                vector.set_ywx(vec3!(3, 4, 1));
                vector
            },
            vec4!(1, 3, 4, 4),
        );

        assert_eq!(
            {
                let mut vector = vec4!(2, 3, 4, 1);
                vector.set_xywz(vec4!(3, 4, 1, 2));
                vector
            },
            vec4!(3, 4, 2, 1),
        );
    }

    #[test]
    fn test_constructor_aligned() {
        assert_eq!(vec2!(1, 2).to_array(), [1, 2]);
        assert_eq!(vec2!(vec2!(1, 2)).to_array(), [1, 2]);

        assert_eq!(vec3!(1, 2, 3).to_array(), [1, 2, 3]);
        assert_eq!(vec3!(1, vec2!(2, 3)).to_array(), [1, 2, 3]);
        assert_eq!(vec3!(vec2!(1, 2), 3).to_array(), [1, 2, 3]);
        assert_eq!(vec3!(vec3!(1, 2, 3)).to_array(), [1, 2, 3]);

        assert_eq!(vec4!(1, 2, 3, 4).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4!(1, 2, vec2!(3, 4)).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4!(1, vec2!(2, 3), 4).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4!(1, vec3!(2, 3, 4)).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4!(vec2!(1, 2), 3, 4).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4!(vec2!(1, 2), vec2!(3, 4)).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4!(vec3!(1, 2, 3), 4).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4!(vec4!(1, 2, 3, 4)).to_array(), [1, 2, 3, 4]);
    }

    #[test]
    fn test_cmp_aligned() {
        assert_eq!(vec2!(1, 2).eq(&vec2!(1, 2)), true);
        assert_eq!(vec3!(1, 2, 3).eq(&vec3!(1, 2, 3)), true);
        assert_eq!(vec4!(1, 2, 3, 4).eq(&vec4!(1, 2, 3, 4)), true);

        assert_eq!(vec2!(1, 2).eq(&vec2!(1, 1)), false);
        assert_eq!(vec3!(1, 2, 3).eq(&vec3!(1, 1, 3)), false);
        assert_eq!(vec4!(1, 2, 3, 4).eq(&vec4!(1, 1, 3, 4)), false);

        assert_eq!(vec2!(1, 2).ne(&vec2!(1, 2)), false);
        assert_eq!(vec3!(1, 2, 3).ne(&vec3!(1, 2, 3)), false);
        assert_eq!(vec4!(1, 2, 3, 4).ne(&vec4!(1, 2, 3, 4)), false);

        assert_eq!(vec2!(1, 2).ne(&vec2!(1, 1)), true);
        assert_eq!(vec3!(1, 2, 3).ne(&vec3!(1, 1, 3)), true);
        assert_eq!(vec4!(1, 2, 3, 4).ne(&vec4!(1, 1, 3, 4)), true);

        assert_eq!(vec2!(1, 2).eq_mask(vec2!(1, 1)), vec2!(true, false));
        assert_eq!(
            vec3!(1, 2, 3).eq_mask(vec3!(1, 1, 3)),
            vec3!(true, false, true)
        );
        assert_eq!(
            vec4!(1, 2, 3, 4).eq_mask(vec4!(1, 1, 3, 4)),
            vec4!(true, false, true, true)
        );

        assert_eq!(vec2!(1, 2).ne_mask(vec2!(1, 1)), vec2!(false, true));
        assert_eq!(
            vec3!(1, 2, 3).ne_mask(vec3!(1, 1, 3)),
            vec3!(false, true, false)
        );
        assert_eq!(
            vec4!(1, 2, 3, 4).ne_mask(vec4!(1, 1, 3, 4)),
            vec4!(false, true, false, false)
        );

        assert_eq!(vec2!(1, 1).lt_mask(vec2!(1, 2)), vec2!(false, true));
        assert_eq!(
            vec3!(1, 1, 2).lt_mask(vec3!(1, 2, 2)),
            vec3!(false, true, false)
        );
        assert_eq!(
            vec4!(1, 2, 1, 1).lt_mask(vec4!(1, 2, 2, 1)),
            vec4!(false, false, true, false)
        );

        assert_eq!(vec2!(2, 2).gt_mask(vec2!(2, 1)), vec2!(false, true));
        assert_eq!(
            vec3!(2, 2, 1).gt_mask(vec3!(2, 1, 1)),
            vec3!(false, true, false)
        );
        assert_eq!(
            vec4!(2, 1, 2, 2).gt_mask(vec4!(2, 1, 1, 2)),
            vec4!(false, false, true, false)
        );

        assert_eq!(vec2!(2, 2).le_mask(vec2!(2, 1)), vec2!(true, false));
        assert_eq!(
            vec3!(2, 2, 1).le_mask(vec3!(2, 1, 1)),
            vec3!(true, false, true)
        );
        assert_eq!(
            vec4!(2, 1, 2, 2).le_mask(vec4!(2, 1, 1, 2)),
            vec4!(true, true, false, true)
        );

        assert_eq!(vec2!(1, 1).ge_mask(vec2!(1, 2)), vec2!(true, false));
        assert_eq!(
            vec3!(1, 1, 2).ge_mask(vec3!(1, 2, 2)),
            vec3!(true, false, true)
        );
        assert_eq!(
            vec4!(1, 2, 1, 1).ge_mask(vec4!(1, 2, 2, 1)),
            vec4!(true, true, false, true)
        );
    }

    // These tests are generated for all primitive types

    #[test]
    fn test_array_packed() {
        assert_eq!(
            Vector::<2, u32, VecPacked>::from_array([1, 2]).to_array(),
            [1, 2]
        );
        assert_eq!(
            Vector::<3, u32, VecPacked>::from_array([3, 4, 1]).to_array(),
            [3, 4, 1]
        );
        assert_eq!(
            Vector::<4, u32, VecPacked>::from_array([2, 3, 4, 1]).to_array(),
            [2, 3, 4, 1]
        );

        assert_eq!(
            Vector::<2, u32, VecPacked>::from_array([1, 2]).as_array(),
            &[1, 2]
        );
        assert_eq!(
            Vector::<3, u32, VecPacked>::from_array([3, 4, 1]).as_array(),
            &[3, 4, 1]
        );
        assert_eq!(
            Vector::<4, u32, VecPacked>::from_array([2, 3, 4, 1]).as_array(),
            &[2, 3, 4, 1]
        );

        assert_eq!(
            Vector::<2, u32, VecPacked>::from_array([1, 2]).as_array_mut(),
            &mut [1, 2]
        );
        assert_eq!(
            Vector::<3, u32, VecPacked>::from_array([3, 4, 1]).as_array_mut(),
            &mut [3, 4, 1]
        );
        assert_eq!(
            Vector::<4, u32, VecPacked>::from_array([2, 3, 4, 1]).as_array_mut(),
            &mut [2, 3, 4, 1]
        );

        assert_eq!(
            Vector::<2, u32, VecPacked>::from_fn(|i| [1, 2][i]).to_array(),
            [1, 2]
        );
        assert_eq!(
            Vector::<3, u32, VecPacked>::from_fn(|i| [3, 4, 1][i]).to_array(),
            [3, 4, 1]
        );
        assert_eq!(
            Vector::<4, u32, VecPacked>::from_fn(|i| [2, 3, 4, 1][i]).to_array(),
            [2, 3, 4, 1]
        );

        assert_eq!(
            vec2p!(1, 2)
                .map(|x| {
                    let idx = [1, 2].into_iter().position(|y| y == x).unwrap();
                    [1, 2][idx]
                })
                .to_array(),
            [1, 2]
        );
        assert_eq!(
            vec3p!(3, 4, 1)
                .map(|x| {
                    let idx = [3, 4, 1].into_iter().position(|y| y == x).unwrap();
                    [3, 4, 1][idx]
                })
                .to_array(),
            [3, 4, 1]
        );
        assert_eq!(
            vec4p!(2, 3, 4, 1)
                .map(|x| {
                    let idx = [2, 3, 4, 1].into_iter().position(|y| y == x).unwrap();
                    [2, 3, 4, 1][idx]
                })
                .to_array(),
            [2, 3, 4, 1]
        );

        assert_eq!(vec2p!(1, 2).fold(1, |x, y| x + y), 1 + 1 + 2);
        assert_eq!(vec3p!(3, 4, 1).fold(1, |x, y| x + y), 1 + 3 + 4 + 1);
        assert_eq!(vec4p!(2, 3, 4, 1).fold(1, |x, y| x + y), 1 + 2 + 3 + 4 + 1);

        assert_eq!(vec2p!(1, 2).reduce(|x, y| x + y), 1 + 2);
        assert_eq!(vec3p!(3, 4, 1).reduce(|x, y| x + y), 3 + 4 + 1);
        assert_eq!(vec4p!(2, 3, 4, 1).reduce(|x, y| x + y), 2 + 3 + 4 + 1);

        assert_eq!(vec2p!(1, 2).all(|x| x == 1), false);
        assert_eq!(vec3p!(3, 4, 1).all(|x| x == 1), false);
        assert_eq!(vec4p!(2, 3, 4, 1).all(|x| x == 1), false);

        assert_eq!(vec2p!(1, 2).any(|x| x == 1), true);
        assert_eq!(vec3p!(3, 4, 1).any(|x| x == 1), true);
        assert_eq!(vec4p!(2, 3, 4, 1).any(|x| x == 1), true);

        assert_eq!(vec2p!(1, 2).count(|x| x == 1), 1);
        assert_eq!(vec3p!(3, 4, 1).count(|x| x == 1), 1);
        assert_eq!(vec4p!(2, 3, 4, 1).count(|x| x == 1), 1);

        assert_eq!(vec2p!(1, 2).len(), 2);
        assert_eq!(vec3p!(3, 4, 1).len(), 3);
        assert_eq!(vec4p!(2, 3, 4, 1).len(), 4);
    }

    #[test]
    fn test_splat_packed() {
        assert_eq!(Vector::<2, u32, VecPacked>::splat(1).to_array(), [1; 2]);
        assert_eq!(Vector::<3, u32, VecPacked>::splat(3).to_array(), [3; 3]);
        assert_eq!(Vector::<4, u32, VecPacked>::splat(2).to_array(), [2; 4]);

        assert_eq!(
            Vector::<2, u32, VecPacked>::const_splat(1).to_array(),
            [1; 2]
        );
        assert_eq!(
            Vector::<3, u32, VecPacked>::const_splat(3).to_array(),
            [3; 3]
        );
        assert_eq!(
            Vector::<4, u32, VecPacked>::const_splat(2).to_array(),
            [2; 4]
        );
    }

    #[test]
    fn test_storage_packed() {
        assert_eq!(vec2p!(1, 2).align(), vec2p!(1, 2),);
        assert_eq!(vec3p!(3, 4, 1).align(), vec3p!(3, 4, 1),);
        assert_eq!(vec4p!(2, 3, 4, 1).align(), vec4p!(2, 3, 4, 1),);

        assert_eq!(vec2p!(1, 2).pack(), vec2p!(1, 2),);
        assert_eq!(vec3p!(3, 4, 1).pack(), vec3p!(3, 4, 1),);
        assert_eq!(vec4p!(2, 3, 4, 1).pack(), vec4p!(2, 3, 4, 1),);

        assert_eq!(vec2p!(1, 2).to_storage::<VecAligned>(), vec2p!(1, 2),);
        assert_eq!(vec3p!(3, 4, 1).to_storage::<VecAligned>(), vec3p!(3, 4, 1),);
        assert_eq!(
            vec4p!(2, 3, 4, 1).to_storage::<VecAligned>(),
            vec4p!(2, 3, 4, 1),
        );

        assert_eq!(vec2p!(1, 2).to_storage::<VecPacked>(), vec2p!(1, 2),);
        assert_eq!(vec3p!(3, 4, 1).to_storage::<VecPacked>(), vec3p!(3, 4, 1),);
        assert_eq!(
            vec4p!(2, 3, 4, 1).to_storage::<VecPacked>(),
            vec4p!(2, 3, 4, 1),
        );

        assert_eq!(
            Vector::<2, u32, VecPacked>::from_array([1, 2]).is_aligned(),
            false
        );
        assert_eq!(
            Vector::<3, u32, VecPacked>::from_array([3, 4, 1]).is_aligned(),
            false
        );
        assert_eq!(
            Vector::<4, u32, VecPacked>::from_array([2, 3, 4, 1]).is_aligned(),
            false
        );
    }

    #[test]
    fn test_swizzle_packed() {
        assert_eq!(vec2p!(1, 2).x(), 1);
        assert_eq!(vec3p!(3, 4, 1).y(), 4);
        assert_eq!(vec4p!(2, 3, 4, 1).z(), 4);

        assert_eq!(vec2p!(1, 2).yy(), vec2p!(2, 2),);
        assert_eq!(vec3p!(3, 4, 1).zy(), vec2p!(1, 4),);
        assert_eq!(vec4p!(2, 3, 4, 1).xw(), vec2p!(2, 1),);

        assert_eq!(vec2p!(1, 2).xyy(), vec3p!(1, 2, 2),);
        assert_eq!(vec3p!(3, 4, 1).yzy(), vec3p!(4, 1, 4),);
        assert_eq!(vec4p!(2, 3, 4, 1).wxy(), vec3p!(1, 2, 3),);

        assert_eq!(vec2p!(1, 2).xxyy(), vec4p!(1, 1, 2, 2),);
        assert_eq!(vec3p!(3, 4, 1).yzyz(), vec4p!(4, 1, 4, 1),);
        assert_eq!(vec4p!(2, 3, 4, 1).wxyw(), vec4p!(1, 2, 3, 1),);
    }

    #[test]
    fn test_swizzle_ref_packed() {
        assert_eq!(vec2p!(1, 2).x_ref(), &1);
        assert_eq!(vec3p!(3, 4, 1).y_ref(), &4);
        assert_eq!(vec4p!(2, 3, 4, 1).z_ref(), &4);

        assert_eq!(vec2p!(1, 2).xy_ref(), &vec2p!(1, 2),);
        assert_eq!(vec3p!(1, 2, 3).yz_ref(), &vec2p!(2, 3),);
        assert_eq!(vec4p!(1, 2, 3, 4).zw_ref(), &vec2p!(3, 4),);

        assert_eq!(vec3p!(1, 2, 3).xyz_ref(), &vec3p!(1, 2, 3),);
        assert_eq!(vec4p!(1, 2, 3, 4).yzw_ref(), &vec3p!(2, 3, 4),);

        assert_eq!(vec4p!(1, 2, 3, 4).xyzw_ref(), &vec4p!(1, 2, 3, 4),);
    }

    #[test]
    fn test_swizzle_mut_packed() {
        assert_eq!(vec2p!(1, 2).x_mut(), &mut 1);
        assert_eq!(vec3p!(3, 4, 1).y_mut(), &mut 4);
        assert_eq!(vec4p!(2, 3, 4, 1).z_mut(), &mut 4);

        assert_eq!(vec2p!(1, 2).x_y_mut(), (&mut 1, &mut 2));
        assert_eq!(vec3p!(3, 4, 1).xy_z_mut(), (&mut vec2p!(3, 4), &mut 1));
        assert_eq!(
            vec4p!(2, 3, 4, 1).xy_zw_mut(),
            (&mut vec2p!(2, 3), &mut vec2p!(4, 1)),
        );
    }

    #[test]
    fn test_swizzle_with_packed() {
        assert_eq!(vec2p!(1, 2).with_x(3), vec2p!(3, 2),);
        assert_eq!(vec3p!(3, 4, 1).with_y(2), vec3p!(3, 2, 1),);
        assert_eq!(vec4p!(2, 3, 4, 1).with_z(3), vec4p!(2, 3, 3, 1),);

        assert_eq!(vec2p!(1, 2).with_xy(vec2!(3, 4)), vec2p!(3, 4),);
        assert_eq!(vec3p!(3, 4, 1).with_zy(vec2!(2, 3)), vec3p!(3, 3, 2),);
        assert_eq!(vec4p!(2, 3, 4, 1).with_xw(vec2!(3, 4)), vec4p!(3, 3, 4, 4),);

        assert_eq!(vec3p!(1, 2, 3).with_xzy(vec3!(3, 4, 1)), vec3p!(3, 1, 4),);
        assert_eq!(
            vec4p!(2, 3, 4, 1).with_ywx(vec3!(3, 4, 1)),
            vec4p!(1, 3, 4, 4),
        );

        assert_eq!(
            vec4p!(2, 3, 4, 1).with_xywz(vec4!(3, 4, 1, 2)),
            vec4p!(3, 4, 2, 1),
        );
    }

    #[test]
    fn test_swizzle_set_packed() {
        assert_eq!(
            {
                let mut vector = vec2p!(1, 2);
                vector.set_x(3);
                vector
            },
            vec2p!(3, 2),
        );
        assert_eq!(
            {
                let mut vector = vec3p!(3, 4, 1);
                vector.set_y(2);
                vector
            },
            vec3p!(3, 2, 1),
        );
        assert_eq!(
            {
                let mut vector = vec4p!(2, 3, 4, 1);
                vector.set_z(3);
                vector
            },
            vec4p!(2, 3, 3, 1),
        );

        assert_eq!(
            {
                let mut vector = vec2p!(1, 2);
                vector.set_xy(vec2!(3, 4));
                vector
            },
            vec2p!(3, 4),
        );
        assert_eq!(
            {
                let mut vector = vec3p!(3, 4, 1);
                vector.set_zy(vec2!(2, 3));
                vector
            },
            vec3p!(3, 3, 2),
        );
        assert_eq!(
            {
                let mut vector = vec4p!(2, 3, 4, 1);
                vector.set_xw(vec2!(3, 4));
                vector
            },
            vec4p!(3, 3, 4, 4),
        );

        assert_eq!(
            {
                let mut vector = vec3p!(1, 2, 3);
                vector.set_xzy(vec3!(3, 4, 1));
                vector
            },
            vec3p!(3, 1, 4),
        );
        assert_eq!(
            {
                let mut vector = vec4p!(2, 3, 4, 1);
                vector.set_ywx(vec3!(3, 4, 1));
                vector
            },
            vec4p!(1, 3, 4, 4),
        );

        assert_eq!(
            {
                let mut vector = vec4p!(2, 3, 4, 1);
                vector.set_xywz(vec4!(3, 4, 1, 2));
                vector
            },
            vec4p!(3, 4, 2, 1),
        );
    }

    #[test]
    fn test_constructor_packed() {
        assert_eq!(vec2p!(1, 2).to_array(), [1, 2]);
        assert_eq!(vec2p!(vec2p!(1, 2)).to_array(), [1, 2]);

        assert_eq!(vec3p!(1, 2, 3).to_array(), [1, 2, 3]);
        assert_eq!(vec3p!(1, vec2p!(2, 3)).to_array(), [1, 2, 3]);
        assert_eq!(vec3p!(vec2p!(1, 2), 3).to_array(), [1, 2, 3]);
        assert_eq!(vec3p!(vec3p!(1, 2, 3)).to_array(), [1, 2, 3]);

        assert_eq!(vec4p!(1, 2, 3, 4).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4p!(1, 2, vec2p!(3, 4)).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4p!(1, vec2p!(2, 3), 4).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4p!(1, vec3p!(2, 3, 4)).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4p!(vec2p!(1, 2), 3, 4).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4p!(vec2p!(1, 2), vec2p!(3, 4)).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4p!(vec3p!(1, 2, 3), 4).to_array(), [1, 2, 3, 4]);
        assert_eq!(vec4p!(vec4p!(1, 2, 3, 4)).to_array(), [1, 2, 3, 4]);
    }

    #[test]
    fn test_cmp_packed() {
        assert_eq!(vec2p!(1, 2).eq(&vec2p!(1, 2)), true);
        assert_eq!(vec3p!(1, 2, 3).eq(&vec3p!(1, 2, 3)), true);
        assert_eq!(vec4p!(1, 2, 3, 4).eq(&vec4p!(1, 2, 3, 4)), true);

        assert_eq!(vec2p!(1, 2).eq(&vec2p!(1, 1)), false);
        assert_eq!(vec3p!(1, 2, 3).eq(&vec3p!(1, 1, 3)), false);
        assert_eq!(vec4p!(1, 2, 3, 4).eq(&vec4p!(1, 1, 3, 4)), false);

        assert_eq!(vec2p!(1, 2).ne(&vec2p!(1, 2)), false);
        assert_eq!(vec3p!(1, 2, 3).ne(&vec3p!(1, 2, 3)), false);
        assert_eq!(vec4p!(1, 2, 3, 4).ne(&vec4p!(1, 2, 3, 4)), false);

        assert_eq!(vec2p!(1, 2).ne(&vec2p!(1, 1)), true);
        assert_eq!(vec3p!(1, 2, 3).ne(&vec3p!(1, 1, 3)), true);
        assert_eq!(vec4p!(1, 2, 3, 4).ne(&vec4p!(1, 1, 3, 4)), true);

        assert_eq!(vec2p!(1, 2).eq_mask(vec2p!(1, 1)), vec2p!(true, false));
        assert_eq!(
            vec3p!(1, 2, 3).eq_mask(vec3p!(1, 1, 3)),
            vec3p!(true, false, true)
        );
        assert_eq!(
            vec4p!(1, 2, 3, 4).eq_mask(vec4p!(1, 1, 3, 4)),
            vec4p!(true, false, true, true)
        );

        assert_eq!(vec2p!(1, 2).ne_mask(vec2p!(1, 1)), vec2p!(false, true));
        assert_eq!(
            vec3p!(1, 2, 3).ne_mask(vec3p!(1, 1, 3)),
            vec3p!(false, true, false)
        );
        assert_eq!(
            vec4p!(1, 2, 3, 4).ne_mask(vec4p!(1, 1, 3, 4)),
            vec4p!(false, true, false, false)
        );

        assert_eq!(vec2p!(1, 1).lt_mask(vec2p!(1, 2)), vec2p!(false, true));
        assert_eq!(
            vec3p!(1, 1, 2).lt_mask(vec3p!(1, 2, 2)),
            vec3p!(false, true, false)
        );
        assert_eq!(
            vec4p!(1, 2, 1, 1).lt_mask(vec4p!(1, 2, 2, 1)),
            vec4p!(false, false, true, false)
        );

        assert_eq!(vec2p!(2, 2).gt_mask(vec2p!(2, 1)), vec2p!(false, true));
        assert_eq!(
            vec3p!(2, 2, 1).gt_mask(vec3p!(2, 1, 1)),
            vec3p!(false, true, false)
        );
        assert_eq!(
            vec4p!(2, 1, 2, 2).gt_mask(vec4p!(2, 1, 1, 2)),
            vec4p!(false, false, true, false)
        );

        assert_eq!(vec2p!(2, 2).le_mask(vec2p!(2, 1)), vec2p!(true, false));
        assert_eq!(
            vec3p!(2, 2, 1).le_mask(vec3p!(2, 1, 1)),
            vec3p!(true, false, true)
        );
        assert_eq!(
            vec4p!(2, 1, 2, 2).le_mask(vec4p!(2, 1, 1, 2)),
            vec4p!(true, true, false, true)
        );

        assert_eq!(vec2p!(1, 1).ge_mask(vec2p!(1, 2)), vec2p!(true, false));
        assert_eq!(
            vec3p!(1, 1, 2).ge_mask(vec3p!(1, 2, 2)),
            vec3p!(true, false, true)
        );
        assert_eq!(
            vec4p!(1, 2, 1, 1).ge_mask(vec4p!(1, 2, 2, 1)),
            vec4p!(true, true, false, true)
        );
    }

    // These tests are generated for all int types

    #[test]
    fn test_add_aligned() {
        assert_eq!((vec2!(3, 1) + vec2!(5, 3)).to_array(), [8, 4]);
        assert_eq!((vec3!(3, 1, 2) + vec3!(5, 3, 4)).to_array(), [8, 4, 6]);
        assert_eq!(
            (vec4!(3, 1, 2, 0) + vec4!(5, 3, 4, 1)).to_array(),
            [8, 4, 6, 1]
        );
    }

    #[test]
    fn test_sub_aligned() {
        assert_eq!((vec2!(8, 50) - vec2!(5, 3)).to_array(), [3, 47]);
        assert_eq!((vec3!(56, 12, 21) - vec3!(5, 3, 4)).to_array(), [51, 9, 17]);
        assert_eq!(
            (vec4!(39, 13, 21, 4) - vec4!(5, 3, 4, 1)).to_array(),
            [34, 10, 17, 3]
        );
    }

    #[test]
    fn test_mul_aligned() {
        assert_eq!((vec2!(3, 1) * vec2!(5, 3)).to_array(), [15, 3]);
        assert_eq!((vec3!(3, 1, 2) * vec3!(5, 3, 4)).to_array(), [15, 3, 8]);
        assert_eq!(
            (vec4!(3, 1, 2, 0) * vec4!(5, 3, 4, 1)).to_array(),
            [15, 3, 8, 0]
        );
    }

    #[test]
    fn test_div_aligned() {
        assert_eq!((vec2!(8, 50) / vec2!(5, 3)).to_array(), [1, 16]);
        assert_eq!((vec3!(56, 12, 21) / vec3!(5, 3, 4)).to_array(), [11, 4, 5]);
        assert_eq!(
            (vec4!(39, 13, 21, 4) / vec4!(5, 3, 4, 1)).to_array(),
            [7, 4, 5, 4]
        );
    }

    #[test]
    fn test_rem_aligned() {
        assert_eq!((vec2!(8, 50) % vec2!(5, 3)).to_array(), [3, 2]);
        assert_eq!((vec3!(56, 12, 21) % vec3!(5, 3, 4)).to_array(), [1, 0, 1]);
        assert_eq!(
            (vec4!(39, 13, 21, 4) % vec4!(5, 3, 4, 1)).to_array(),
            [4, 1, 1, 0]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_add2_overflow_aligned() {
        assert_eq!((vec2!(u32::MAX, 1) + vec2!(1, 3)).to_array(), [u32::MIN, 4]);
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_add3_overflow_aligned() {
        assert_eq!(
            (vec3!(u32::MAX, 1, 3) + vec3!(1, 3, 5)).to_array(),
            [u32::MIN, 4, 8]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_add4_overflow_aligned() {
        assert_eq!(
            (vec4!(u32::MAX, 1, 3, 5) + vec4!(1, 3, 5, 7)).to_array(),
            [u32::MIN, 4, 8, 12]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_sub2_overflow_aligned() {
        assert_eq!((vec2!(u32::MIN, 5) - vec2!(1, 3)).to_array(), [u32::MAX, 2]);
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_sub3_overflow_aligned() {
        assert_eq!(
            (vec3!(u32::MIN, 5, 7) - vec3!(1, 3, 5)).to_array(),
            [u32::MAX, 2, 2]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_sub4_overflow_aligned() {
        assert_eq!(
            (vec4!(u32::MIN, 5, 7, 9) - vec4!(1, 3, 5, 7)).to_array(),
            [u32::MAX, 2, 2, 2]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_mul2_overflow_aligned() {
        assert_eq!(
            (vec2!(u32::MAX, 5) * vec2!(2, 3)).to_array(),
            [u32::MAX * 2, 15]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_mul3_overflow_aligned() {
        assert_eq!(
            (vec3!(u32::MAX, 5, 7) * vec3!(2, 3, 4)).to_array(),
            [u32::MAX * 2, 15, 28]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_mul4_overflow_aligned() {
        assert_eq!(
            (vec4!(u32::MAX, 5, 7, 9) * vec4!(2, 3, 4, 5)).to_array(),
            [u32::MAX * 2, 15, 28, 45]
        );
    }

    #[test]
    #[should_panic]
    fn test_div2_by_zero_aligned() {
        println!("{}", vec2!(3, 5) / vec2!(0, 3));
    }

    #[test]
    #[should_panic]
    fn test_div3_by_zero_aligned() {
        println!("{}", vec3!(3, 5, 7) / vec3!(0, 3, 5));
    }

    #[test]
    #[should_panic]
    fn test_div4_by_zero_aligned() {
        println!("{}", vec4!(3, 5, 7, 9) / vec4!(0, 3, 5, 7));
    }

    #[test]
    #[should_panic]
    fn test_rem2_by_zero_aligned() {
        println!("{}", vec2!(3, 5) % vec2!(0, 3));
    }

    #[test]
    #[should_panic]
    fn test_rem3_by_zero_aligned() {
        println!("{}", vec3!(3, 5, 7) % vec3!(0, 3, 5));
    }

    #[test]
    #[should_panic]
    fn test_rem4_by_zero_aligned() {
        println!("{}", vec4!(3, 5, 7, 9) % vec4!(0, 3, 5, 7));
    }

    // These tests are generated for all int types

    #[test]
    fn test_add_packed() {
        assert_eq!((vec2p!(3, 1) + vec2p!(5, 3)).to_array(), [8, 4]);
        assert_eq!((vec3p!(3, 1, 2) + vec3p!(5, 3, 4)).to_array(), [8, 4, 6]);
        assert_eq!(
            (vec4p!(3, 1, 2, 0) + vec4p!(5, 3, 4, 1)).to_array(),
            [8, 4, 6, 1]
        );
    }

    #[test]
    fn test_sub_packed() {
        assert_eq!((vec2p!(8, 50) - vec2p!(5, 3)).to_array(), [3, 47]);
        assert_eq!(
            (vec3p!(56, 12, 21) - vec3p!(5, 3, 4)).to_array(),
            [51, 9, 17]
        );
        assert_eq!(
            (vec4p!(39, 13, 21, 4) - vec4p!(5, 3, 4, 1)).to_array(),
            [34, 10, 17, 3]
        );
    }

    #[test]
    fn test_mul_packed() {
        assert_eq!((vec2p!(3, 1) * vec2p!(5, 3)).to_array(), [15, 3]);
        assert_eq!((vec3p!(3, 1, 2) * vec3p!(5, 3, 4)).to_array(), [15, 3, 8]);
        assert_eq!(
            (vec4p!(3, 1, 2, 0) * vec4p!(5, 3, 4, 1)).to_array(),
            [15, 3, 8, 0]
        );
    }

    #[test]
    fn test_div_packed() {
        assert_eq!((vec2p!(8, 50) / vec2p!(5, 3)).to_array(), [1, 16]);
        assert_eq!(
            (vec3p!(56, 12, 21) / vec3p!(5, 3, 4)).to_array(),
            [11, 4, 5]
        );
        assert_eq!(
            (vec4p!(39, 13, 21, 4) / vec4p!(5, 3, 4, 1)).to_array(),
            [7, 4, 5, 4]
        );
    }

    #[test]
    fn test_rem_packed() {
        assert_eq!((vec2p!(8, 50) % vec2p!(5, 3)).to_array(), [3, 2]);
        assert_eq!((vec3p!(56, 12, 21) % vec3p!(5, 3, 4)).to_array(), [1, 0, 1]);
        assert_eq!(
            (vec4p!(39, 13, 21, 4) % vec4p!(5, 3, 4, 1)).to_array(),
            [4, 1, 1, 0]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_add2_overflow_packed() {
        assert_eq!(
            (vec2p!(u32::MAX, 1) + vec2p!(1, 3)).to_array(),
            [u32::MIN, 4]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_add3_overflow_packed() {
        assert_eq!(
            (vec3p!(u32::MAX, 1, 3) + vec3p!(1, 3, 5)).to_array(),
            [u32::MIN, 4, 8]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_add4_overflow_packed() {
        assert_eq!(
            (vec4p!(u32::MAX, 1, 3, 5) + vec4p!(1, 3, 5, 7)).to_array(),
            [u32::MIN, 4, 8, 12]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_sub2_overflow_packed() {
        assert_eq!(
            (vec2p!(u32::MIN, 5) - vec2p!(1, 3)).to_array(),
            [u32::MAX, 2]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_sub3_overflow_packed() {
        assert_eq!(
            (vec3p!(u32::MIN, 5, 7) - vec3p!(1, 3, 5)).to_array(),
            [u32::MAX, 2, 2]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_sub4_overflow_packed() {
        assert_eq!(
            (vec4p!(u32::MIN, 5, 7, 9) - vec4p!(1, 3, 5, 7)).to_array(),
            [u32::MAX, 2, 2, 2]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_mul2_overflow_packed() {
        assert_eq!(
            (vec2p!(u32::MAX, 5) * vec2p!(2, 3)).to_array(),
            [u32::MAX * 2, 15]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_mul3_overflow_packed() {
        assert_eq!(
            (vec3p!(u32::MAX, 5, 7) * vec3p!(2, 3, 4)).to_array(),
            [u32::MAX * 2, 15, 28]
        );
    }

    #[test]
    #[cfg_attr(debug_assertions, should_panic)]
    fn test_mul4_overflow_packed() {
        assert_eq!(
            (vec4p!(u32::MAX, 5, 7, 9) * vec4p!(2, 3, 4, 5)).to_array(),
            [u32::MAX * 2, 15, 28, 45]
        );
    }

    #[test]
    #[should_panic]
    fn test_div2_by_zero_packed() {
        println!("{}", vec2p!(3, 5) / vec2p!(0, 3));
    }

    #[test]
    #[should_panic]
    fn test_div3_by_zero_packed() {
        println!("{}", vec3p!(3, 5, 7) / vec3p!(0, 3, 5));
    }

    #[test]
    #[should_panic]
    fn test_div4_by_zero_packed() {
        println!("{}", vec4p!(3, 5, 7, 9) / vec4p!(0, 3, 5, 7));
    }

    #[test]
    #[should_panic]
    fn test_rem2_by_zero_packed() {
        println!("{}", vec2p!(3, 5) % vec2p!(0, 3));
    }

    #[test]
    #[should_panic]
    fn test_rem3_by_zero_packed() {
        println!("{}", vec3p!(3, 5, 7) % vec3p!(0, 3, 5));
    }

    #[test]
    #[should_panic]
    fn test_rem4_by_zero_packed() {
        println!("{}", vec4p!(3, 5, 7, 9) % vec4p!(0, 3, 5, 7));
    }
}
