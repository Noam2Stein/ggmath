// This file is automatically generated.
// To edit this file edit the codegen crate instead.

use crate::{Usize, vector::*};

impl<const N: usize, A: VecAlignment> Vector<N, bool, A>
where
    Usize<N>: VecLen,
{
    /// Converts `self` to a vector of `f32` elements.
    #[inline(always)]
    pub fn as_f32(self) -> Vector<N, f32, A> {
        self.map(|x| x as f32)
    }

    /// Converts `self` to a vector of `f64` elements.
    #[inline(always)]
    pub fn as_f64(self) -> Vector<N, f64, A> {
        self.map(|x| x as f64)
    }

    /// Converts `self` to a vector of `i8` elements.
    #[inline(always)]
    pub fn as_i8(self) -> Vector<N, i8, A> {
        self.map(|x| x as i8)
    }

    /// Converts `self` to a vector of `i16` elements.
    #[inline(always)]
    pub fn as_i16(self) -> Vector<N, i16, A> {
        self.map(|x| x as i16)
    }

    /// Converts `self` to a vector of `i32` elements.
    #[inline(always)]
    pub fn as_i32(self) -> Vector<N, i32, A> {
        self.map(|x| x as i32)
    }

    /// Converts `self` to a vector of `i64` elements.
    #[inline(always)]
    pub fn as_i64(self) -> Vector<N, i64, A> {
        self.map(|x| x as i64)
    }

    /// Converts `self` to a vector of `i128` elements.
    #[inline(always)]
    pub fn as_i128(self) -> Vector<N, i128, A> {
        self.map(|x| x as i128)
    }

    /// Converts `self` to a vector of `isize` elements.
    #[inline(always)]
    pub fn as_isize(self) -> Vector<N, isize, A> {
        self.map(|x| x as isize)
    }

    /// Converts `self` to a vector of `u8` elements.
    #[inline(always)]
    pub fn as_u8(self) -> Vector<N, u8, A> {
        self.map(|x| x as u8)
    }

    /// Converts `self` to a vector of `u16` elements.
    #[inline(always)]
    pub fn as_u16(self) -> Vector<N, u16, A> {
        self.map(|x| x as u16)
    }

    /// Converts `self` to a vector of `u32` elements.
    #[inline(always)]
    pub fn as_u32(self) -> Vector<N, u32, A> {
        self.map(|x| x as u32)
    }

    /// Converts `self` to a vector of `u64` elements.
    #[inline(always)]
    pub fn as_u64(self) -> Vector<N, u64, A> {
        self.map(|x| x as u64)
    }

    /// Converts `self` to a vector of `u128` elements.
    #[inline(always)]
    pub fn as_u128(self) -> Vector<N, u128, A> {
        self.map(|x| x as u128)
    }

    /// Converts `self` to a vector of `usize` elements.
    #[inline(always)]
    pub fn as_usize(self) -> Vector<N, usize, A> {
        self.map(|x| x as usize)
    }
}

impl<const N: usize, A: VecAlignment> Vector<N, bool, A>
where
    Usize<N>: VecLen,
{
    // The following items are generated for all primitive types

    /// Returns `self == other` and supports const contexts.
    #[inline(always)]
    pub const fn const_eq(self, other: Vector<N, bool, impl VecAlignment>) -> bool {
        let mut i = 0;
        while i < N {
            if self.as_array()[i] != other.as_array()[i] {
                return false;
            }
            i += 1;
        }
        true
    }

    /// Returns `self != other` and supports const contexts.
    #[inline(always)]
    pub const fn const_ne(self, other: Vector<N, bool, impl VecAlignment>) -> bool {
        let mut i = 0;
        while i < N {
            if self.as_array()[i] != other.as_array()[i] {
                return true;
            }
            i += 1;
        }
        false
    }

    /// Returns `self.eq_mask(other)` and supports const contexts.
    pub const fn const_eq_mask(
        self,
        other: Vector<N, bool, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] == other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.ne_mask(other)` and supports const contexts.
    pub const fn const_ne_mask(
        self,
        other: Vector<N, bool, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] != other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.lt_mask(other)` and supports const contexts.
    pub const fn const_lt_mask(
        self,
        other: Vector<N, bool, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] < other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.gt_mask(other)` and supports const contexts.
    pub const fn const_gt_mask(
        self,
        other: Vector<N, bool, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] > other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.le_mask(other)` and supports const contexts.
    pub const fn const_le_mask(
        self,
        other: Vector<N, bool, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] <= other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.ge_mask(other)` and supports const contexts.
    pub const fn const_ge_mask(
        self,
        other: Vector<N, bool, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] >= other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_f32` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_f32(self) -> Vector<N, f32, A> {
        let mut output = Vector::<N, f32, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as f32;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_f64` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_f64(self) -> Vector<N, f64, A> {
        let mut output = Vector::<N, f64, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as f64;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i8` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i8(self) -> Vector<N, i8, A> {
        let mut output = Vector::<N, i8, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i8;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i16` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i16(self) -> Vector<N, i16, A> {
        let mut output = Vector::<N, i16, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i16;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i32` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i32(self) -> Vector<N, i32, A> {
        let mut output = Vector::<N, i32, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i32;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i64` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i64(self) -> Vector<N, i64, A> {
        let mut output = Vector::<N, i64, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i64;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i128` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i128(self) -> Vector<N, i128, A> {
        let mut output = Vector::<N, i128, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i128;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_isize` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_isize(self) -> Vector<N, isize, A> {
        let mut output = Vector::<N, isize, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as isize;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_u8` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_u8(self) -> Vector<N, u8, A> {
        let mut output = Vector::<N, u8, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as u8;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_u16` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_u16(self) -> Vector<N, u16, A> {
        let mut output = Vector::<N, u16, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as u16;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_u32` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_u32(self) -> Vector<N, u32, A> {
        let mut output = Vector::<N, u32, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as u32;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_u64` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_u64(self) -> Vector<N, u64, A> {
        let mut output = Vector::<N, u64, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as u64;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_u128` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_u128(self) -> Vector<N, u128, A> {
        let mut output = Vector::<N, u128, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as u128;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_usize` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_usize(self) -> Vector<N, usize, A> {
        let mut output = Vector::<N, usize, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as usize;
            i += 1;
        }
        output
    }
}

#[cfg(test)]
#[allow(arithmetic_overflow)]
mod tests {
    use crate::*;

    // These tests are generated for all primitive types

    #[test]
    fn test_array_aligned() {
        assert_eq!(
            Vector::<2, bool, VecAligned>::from_array([true, false]).to_array(),
            [true, false]
        );
        assert_eq!(
            Vector::<3, bool, VecAligned>::from_array([true, false, true]).to_array(),
            [true, false, true]
        );
        assert_eq!(
            Vector::<4, bool, VecAligned>::from_array([false, true, false, true]).to_array(),
            [false, true, false, true]
        );

        assert_eq!(
            Vector::<2, bool, VecAligned>::from_array([true, false]).as_array(),
            &[true, false]
        );
        assert_eq!(
            Vector::<3, bool, VecAligned>::from_array([true, false, true]).as_array(),
            &[true, false, true]
        );
        assert_eq!(
            Vector::<4, bool, VecAligned>::from_array([false, true, false, true]).as_array(),
            &[false, true, false, true]
        );

        assert_eq!(
            Vector::<2, bool, VecAligned>::from_array([true, false]).as_array_mut(),
            &mut [true, false]
        );
        assert_eq!(
            Vector::<3, bool, VecAligned>::from_array([true, false, true]).as_array_mut(),
            &mut [true, false, true]
        );
        assert_eq!(
            Vector::<4, bool, VecAligned>::from_array([false, true, false, true]).as_array_mut(),
            &mut [false, true, false, true]
        );

        assert_eq!(
            Vector::<2, bool, VecAligned>::from_fn(|i| [true, false][i]).to_array(),
            [true, false]
        );
        assert_eq!(
            Vector::<3, bool, VecAligned>::from_fn(|i| [true, false, true][i]).to_array(),
            [true, false, true]
        );
        assert_eq!(
            Vector::<4, bool, VecAligned>::from_fn(|i| [false, true, false, true][i]).to_array(),
            [false, true, false, true]
        );

        assert_eq!(
            vec2!(true, false)
                .map(|x| {
                    let idx = [true, false].into_iter().position(|y| y == x).unwrap();
                    [true, false][idx]
                })
                .to_array(),
            [true, false]
        );
        assert_eq!(
            vec3!(true, false, true)
                .map(|x| {
                    let idx = [true, false, true]
                        .into_iter()
                        .position(|y| y == x)
                        .unwrap();
                    [true, false, true][idx]
                })
                .to_array(),
            [true, false, true]
        );
        assert_eq!(
            vec4!(false, true, false, true)
                .map(|x| {
                    let idx = [false, true, false, true]
                        .into_iter()
                        .position(|y| y == x)
                        .unwrap();
                    [false, true, false, true][idx]
                })
                .to_array(),
            [false, true, false, true]
        );

        assert_eq!(vec2!(true, false).fold(|x, y| x & y), true & false);
        assert_eq!(
            vec3!(true, false, true).fold(|x, y| x & y),
            true & false & true
        );
        assert_eq!(
            vec4!(false, true, false, true).fold(|x, y| x & y),
            false & true & false & true
        );

        assert_eq!(vec2!(true, false).all(|x| x == true), false);
        assert_eq!(vec3!(true, false, true).all(|x| x == true), false);
        assert_eq!(vec4!(false, true, false, true).all(|x| x == true), false);

        assert_eq!(vec2!(true, false).any(|x| x == true), true);
        assert_eq!(vec3!(true, false, true).any(|x| x == true), true);
        assert_eq!(vec4!(false, true, false, true).any(|x| x == true), true);

        assert_eq!(vec2!(true, false).count(|x| x == true), 1);
        assert_eq!(vec3!(true, false, true).count(|x| x == true), 2);
        assert_eq!(vec4!(false, true, false, true).count(|x| x == true), 2);

        assert_eq!(vec2!(true, false).len(), 2);
        assert_eq!(vec3!(true, false, true).len(), 3);
        assert_eq!(vec4!(false, true, false, true).len(), 4);
    }

    #[test]
    fn test_splat_aligned() {
        assert_eq!(
            Vector::<2, bool, VecAligned>::splat(true).to_array(),
            [true; 2]
        );
        assert_eq!(
            Vector::<3, bool, VecAligned>::splat(true).to_array(),
            [true; 3]
        );
        assert_eq!(
            Vector::<4, bool, VecAligned>::splat(false).to_array(),
            [false; 4]
        );

        assert_eq!(
            Vector::<2, bool, VecAligned>::const_splat(true).to_array(),
            [true; 2]
        );
        assert_eq!(
            Vector::<3, bool, VecAligned>::const_splat(true).to_array(),
            [true; 3]
        );
        assert_eq!(
            Vector::<4, bool, VecAligned>::const_splat(false).to_array(),
            [false; 4]
        );
    }

    #[test]
    fn test_storage_aligned() {
        assert_eq!(vec2!(true, false).align(), vec2!(true, false),);
        assert_eq!(vec3!(true, false, true).align(), vec3!(true, false, true),);
        assert_eq!(
            vec4!(false, true, false, true).align(),
            vec4!(false, true, false, true),
        );

        assert_eq!(vec2!(true, false).pack(), vec2!(true, false),);
        assert_eq!(vec3!(true, false, true).pack(), vec3!(true, false, true),);
        assert_eq!(
            vec4!(false, true, false, true).pack(),
            vec4!(false, true, false, true),
        );

        assert_eq!(
            vec2!(true, false).to_storage::<VecAligned>(),
            vec2!(true, false),
        );
        assert_eq!(
            vec3!(true, false, true).to_storage::<VecAligned>(),
            vec3!(true, false, true),
        );
        assert_eq!(
            vec4!(false, true, false, true).to_storage::<VecAligned>(),
            vec4!(false, true, false, true),
        );

        assert_eq!(
            vec2!(true, false).to_storage::<VecPacked>(),
            vec2!(true, false),
        );
        assert_eq!(
            vec3!(true, false, true).to_storage::<VecPacked>(),
            vec3!(true, false, true),
        );
        assert_eq!(
            vec4!(false, true, false, true).to_storage::<VecPacked>(),
            vec4!(false, true, false, true),
        );

        assert_eq!(
            Vector::<2, bool, VecAligned>::from_array([true, false]).is_aligned(),
            true
        );
        assert_eq!(
            Vector::<3, bool, VecAligned>::from_array([true, false, true]).is_aligned(),
            true
        );
        assert_eq!(
            Vector::<4, bool, VecAligned>::from_array([false, true, false, true]).is_aligned(),
            true
        );
    }

    #[test]
    fn test_swizzle_aligned() {
        assert_eq!(vec2!(true, false).x(), true);
        assert_eq!(vec3!(true, false, true).y(), false);
        assert_eq!(vec4!(false, true, false, true).z(), false);

        assert_eq!(vec2!(true, false).yy(), vec2!(false, false),);
        assert_eq!(vec3!(true, false, true).zy(), vec2!(true, false),);
        assert_eq!(vec4!(false, true, false, true).xw(), vec2!(false, true),);

        assert_eq!(vec2!(true, false).xyy(), vec3!(true, false, false),);
        assert_eq!(vec3!(true, false, true).yzy(), vec3!(false, true, false),);
        assert_eq!(
            vec4!(false, true, false, true).wxy(),
            vec3!(true, false, true),
        );

        assert_eq!(vec2!(true, false).xxyy(), vec4!(true, true, false, false),);
        assert_eq!(
            vec3!(true, false, true).yzyz(),
            vec4!(false, true, false, true),
        );
        assert_eq!(
            vec4!(false, true, false, true).wxyw(),
            vec4!(true, false, true, true),
        );
    }

    #[test]
    fn test_swizzle_ref_aligned() {
        assert_eq!(vec2!(true, false).x_ref(), &true);
        assert_eq!(vec3!(true, false, true).y_ref(), &false);
        assert_eq!(vec4!(false, true, false, true).z_ref(), &false);

        assert_eq!(vec2!(true, false).xy_ref(), &vec2p!(true, false),);
        assert_eq!(vec3!(true, false, true).yz_ref(), &vec2p!(false, true),);
        assert_eq!(
            vec4!(true, false, true, false).zw_ref(),
            &vec2p!(true, false),
        );

        assert_eq!(
            vec3!(true, false, true).xyz_ref(),
            &vec3p!(true, false, true),
        );
        assert_eq!(
            vec4!(true, false, true, false).yzw_ref(),
            &vec3p!(false, true, false),
        );

        assert_eq!(
            vec4!(true, false, true, false).xyzw_ref(),
            &vec4p!(true, false, true, false),
        );
    }

    #[test]
    fn test_swizzle_mut_aligned() {
        assert_eq!(vec2!(true, false).x_mut(), &mut true);
        assert_eq!(vec3!(true, false, true).y_mut(), &mut false);
        assert_eq!(vec4!(false, true, false, true).z_mut(), &mut false);

        assert_eq!(vec2!(true, false).x_y_mut(), (&mut true, &mut false));
        assert_eq!(
            vec3!(true, false, true).xy_z_mut(),
            (&mut vec2p!(true, false), &mut true)
        );
        assert_eq!(
            vec4!(false, true, false, true).xy_zw_mut(),
            (&mut vec2p!(false, true), &mut vec2p!(false, true)),
        );
    }

    #[test]
    fn test_swizzle_with_aligned() {
        assert_eq!(vec2!(true, false).with_x(true), vec2!(true, false),);
        assert_eq!(
            vec3!(true, false, true).with_y(false),
            vec3!(true, false, true),
        );
        assert_eq!(
            vec4!(false, true, false, true).with_z(true),
            vec4!(false, true, true, true),
        );

        assert_eq!(
            vec2!(true, false).with_xy(vec2!(true, false)),
            vec2!(true, false),
        );
        assert_eq!(
            vec3!(true, false, true).with_zy(vec2!(false, true)),
            vec3!(true, true, false),
        );
        assert_eq!(
            vec4!(false, true, false, true).with_xw(vec2!(true, false)),
            vec4!(true, true, false, false),
        );

        assert_eq!(
            vec3!(true, false, true).with_xzy(vec3!(true, false, true)),
            vec3!(true, true, false),
        );
        assert_eq!(
            vec4!(false, true, false, true).with_ywx(vec3!(true, false, true)),
            vec4!(true, true, false, false),
        );

        assert_eq!(
            vec4!(false, true, false, true).with_xywz(vec4!(true, false, true, false)),
            vec4!(true, false, false, true),
        );
    }

    #[test]
    fn test_swizzle_set_aligned() {
        assert_eq!(
            {
                let mut vector = vec2!(true, false);
                vector.set_x(true);
                vector
            },
            vec2!(true, false),
        );
        assert_eq!(
            {
                let mut vector = vec3!(true, false, true);
                vector.set_y(false);
                vector
            },
            vec3!(true, false, true),
        );
        assert_eq!(
            {
                let mut vector = vec4!(false, true, false, true);
                vector.set_z(true);
                vector
            },
            vec4!(false, true, true, true),
        );

        assert_eq!(
            {
                let mut vector = vec2!(true, false);
                vector.set_xy(vec2!(true, false));
                vector
            },
            vec2!(true, false),
        );
        assert_eq!(
            {
                let mut vector = vec3!(true, false, true);
                vector.set_zy(vec2!(false, true));
                vector
            },
            vec3!(true, true, false),
        );
        assert_eq!(
            {
                let mut vector = vec4!(false, true, false, true);
                vector.set_xw(vec2!(true, false));
                vector
            },
            vec4!(true, true, false, false),
        );

        assert_eq!(
            {
                let mut vector = vec3!(true, false, true);
                vector.set_xzy(vec3!(true, false, true));
                vector
            },
            vec3!(true, true, false),
        );
        assert_eq!(
            {
                let mut vector = vec4!(false, true, false, true);
                vector.set_ywx(vec3!(true, false, true));
                vector
            },
            vec4!(true, true, false, false),
        );

        assert_eq!(
            {
                let mut vector = vec4!(false, true, false, true);
                vector.set_xywz(vec4!(true, false, true, false));
                vector
            },
            vec4!(true, false, false, true),
        );
    }

    #[test]
    fn test_constructor_aligned() {
        assert_eq!(vec2!(true, false).to_array(), [true, false]);
        assert_eq!(vec2!(vec2!(true, false)).to_array(), [true, false]);

        assert_eq!(vec3!(true, false, true).to_array(), [true, false, true]);
        assert_eq!(
            vec3!(true, vec2!(false, true)).to_array(),
            [true, false, true]
        );
        assert_eq!(
            vec3!(vec2!(true, false), true).to_array(),
            [true, false, true]
        );
        assert_eq!(
            vec3!(vec3!(true, false, true)).to_array(),
            [true, false, true]
        );

        assert_eq!(
            vec4!(true, false, true, false).to_array(),
            [true, false, true, false]
        );
        assert_eq!(
            vec4!(true, false, vec2!(true, false)).to_array(),
            [true, false, true, false]
        );
        assert_eq!(
            vec4!(true, vec2!(false, true), false).to_array(),
            [true, false, true, false]
        );
        assert_eq!(
            vec4!(true, vec3!(false, true, false)).to_array(),
            [true, false, true, false]
        );
        assert_eq!(
            vec4!(vec2!(true, false), true, false).to_array(),
            [true, false, true, false]
        );
        assert_eq!(
            vec4!(vec2!(true, false), vec2!(true, false)).to_array(),
            [true, false, true, false]
        );
        assert_eq!(
            vec4!(vec3!(true, false, true), false).to_array(),
            [true, false, true, false]
        );
        assert_eq!(
            vec4!(vec4!(true, false, true, false)).to_array(),
            [true, false, true, false]
        );
    }

    // These tests are generated for all primitive types

    #[test]
    fn test_array_packed() {
        assert_eq!(
            Vector::<2, bool, VecPacked>::from_array([true, false]).to_array(),
            [true, false]
        );
        assert_eq!(
            Vector::<3, bool, VecPacked>::from_array([true, false, true]).to_array(),
            [true, false, true]
        );
        assert_eq!(
            Vector::<4, bool, VecPacked>::from_array([false, true, false, true]).to_array(),
            [false, true, false, true]
        );

        assert_eq!(
            Vector::<2, bool, VecPacked>::from_array([true, false]).as_array(),
            &[true, false]
        );
        assert_eq!(
            Vector::<3, bool, VecPacked>::from_array([true, false, true]).as_array(),
            &[true, false, true]
        );
        assert_eq!(
            Vector::<4, bool, VecPacked>::from_array([false, true, false, true]).as_array(),
            &[false, true, false, true]
        );

        assert_eq!(
            Vector::<2, bool, VecPacked>::from_array([true, false]).as_array_mut(),
            &mut [true, false]
        );
        assert_eq!(
            Vector::<3, bool, VecPacked>::from_array([true, false, true]).as_array_mut(),
            &mut [true, false, true]
        );
        assert_eq!(
            Vector::<4, bool, VecPacked>::from_array([false, true, false, true]).as_array_mut(),
            &mut [false, true, false, true]
        );

        assert_eq!(
            Vector::<2, bool, VecPacked>::from_fn(|i| [true, false][i]).to_array(),
            [true, false]
        );
        assert_eq!(
            Vector::<3, bool, VecPacked>::from_fn(|i| [true, false, true][i]).to_array(),
            [true, false, true]
        );
        assert_eq!(
            Vector::<4, bool, VecPacked>::from_fn(|i| [false, true, false, true][i]).to_array(),
            [false, true, false, true]
        );

        assert_eq!(
            vec2p!(true, false)
                .map(|x| {
                    let idx = [true, false].into_iter().position(|y| y == x).unwrap();
                    [true, false][idx]
                })
                .to_array(),
            [true, false]
        );
        assert_eq!(
            vec3p!(true, false, true)
                .map(|x| {
                    let idx = [true, false, true]
                        .into_iter()
                        .position(|y| y == x)
                        .unwrap();
                    [true, false, true][idx]
                })
                .to_array(),
            [true, false, true]
        );
        assert_eq!(
            vec4p!(false, true, false, true)
                .map(|x| {
                    let idx = [false, true, false, true]
                        .into_iter()
                        .position(|y| y == x)
                        .unwrap();
                    [false, true, false, true][idx]
                })
                .to_array(),
            [false, true, false, true]
        );

        assert_eq!(vec2p!(true, false).fold(|x, y| x & y), true & false);
        assert_eq!(
            vec3p!(true, false, true).fold(|x, y| x & y),
            true & false & true
        );
        assert_eq!(
            vec4p!(false, true, false, true).fold(|x, y| x & y),
            false & true & false & true
        );

        assert_eq!(vec2p!(true, false).all(|x| x == true), false);
        assert_eq!(vec3p!(true, false, true).all(|x| x == true), false);
        assert_eq!(vec4p!(false, true, false, true).all(|x| x == true), false);

        assert_eq!(vec2p!(true, false).any(|x| x == true), true);
        assert_eq!(vec3p!(true, false, true).any(|x| x == true), true);
        assert_eq!(vec4p!(false, true, false, true).any(|x| x == true), true);

        assert_eq!(vec2p!(true, false).count(|x| x == true), 1);
        assert_eq!(vec3p!(true, false, true).count(|x| x == true), 2);
        assert_eq!(vec4p!(false, true, false, true).count(|x| x == true), 2);

        assert_eq!(vec2p!(true, false).len(), 2);
        assert_eq!(vec3p!(true, false, true).len(), 3);
        assert_eq!(vec4p!(false, true, false, true).len(), 4);
    }

    #[test]
    fn test_splat_packed() {
        assert_eq!(
            Vector::<2, bool, VecPacked>::splat(true).to_array(),
            [true; 2]
        );
        assert_eq!(
            Vector::<3, bool, VecPacked>::splat(true).to_array(),
            [true; 3]
        );
        assert_eq!(
            Vector::<4, bool, VecPacked>::splat(false).to_array(),
            [false; 4]
        );

        assert_eq!(
            Vector::<2, bool, VecPacked>::const_splat(true).to_array(),
            [true; 2]
        );
        assert_eq!(
            Vector::<3, bool, VecPacked>::const_splat(true).to_array(),
            [true; 3]
        );
        assert_eq!(
            Vector::<4, bool, VecPacked>::const_splat(false).to_array(),
            [false; 4]
        );
    }

    #[test]
    fn test_storage_packed() {
        assert_eq!(vec2p!(true, false).align(), vec2p!(true, false),);
        assert_eq!(vec3p!(true, false, true).align(), vec3p!(true, false, true),);
        assert_eq!(
            vec4p!(false, true, false, true).align(),
            vec4p!(false, true, false, true),
        );

        assert_eq!(vec2p!(true, false).pack(), vec2p!(true, false),);
        assert_eq!(vec3p!(true, false, true).pack(), vec3p!(true, false, true),);
        assert_eq!(
            vec4p!(false, true, false, true).pack(),
            vec4p!(false, true, false, true),
        );

        assert_eq!(
            vec2p!(true, false).to_storage::<VecAligned>(),
            vec2p!(true, false),
        );
        assert_eq!(
            vec3p!(true, false, true).to_storage::<VecAligned>(),
            vec3p!(true, false, true),
        );
        assert_eq!(
            vec4p!(false, true, false, true).to_storage::<VecAligned>(),
            vec4p!(false, true, false, true),
        );

        assert_eq!(
            vec2p!(true, false).to_storage::<VecPacked>(),
            vec2p!(true, false),
        );
        assert_eq!(
            vec3p!(true, false, true).to_storage::<VecPacked>(),
            vec3p!(true, false, true),
        );
        assert_eq!(
            vec4p!(false, true, false, true).to_storage::<VecPacked>(),
            vec4p!(false, true, false, true),
        );

        assert_eq!(
            Vector::<2, bool, VecPacked>::from_array([true, false]).is_aligned(),
            false
        );
        assert_eq!(
            Vector::<3, bool, VecPacked>::from_array([true, false, true]).is_aligned(),
            false
        );
        assert_eq!(
            Vector::<4, bool, VecPacked>::from_array([false, true, false, true]).is_aligned(),
            false
        );
    }

    #[test]
    fn test_swizzle_packed() {
        assert_eq!(vec2p!(true, false).x(), true);
        assert_eq!(vec3p!(true, false, true).y(), false);
        assert_eq!(vec4p!(false, true, false, true).z(), false);

        assert_eq!(vec2p!(true, false).yy(), vec2p!(false, false),);
        assert_eq!(vec3p!(true, false, true).zy(), vec2p!(true, false),);
        assert_eq!(vec4p!(false, true, false, true).xw(), vec2p!(false, true),);

        assert_eq!(vec2p!(true, false).xyy(), vec3p!(true, false, false),);
        assert_eq!(vec3p!(true, false, true).yzy(), vec3p!(false, true, false),);
        assert_eq!(
            vec4p!(false, true, false, true).wxy(),
            vec3p!(true, false, true),
        );

        assert_eq!(vec2p!(true, false).xxyy(), vec4p!(true, true, false, false),);
        assert_eq!(
            vec3p!(true, false, true).yzyz(),
            vec4p!(false, true, false, true),
        );
        assert_eq!(
            vec4p!(false, true, false, true).wxyw(),
            vec4p!(true, false, true, true),
        );
    }

    #[test]
    fn test_swizzle_ref_packed() {
        assert_eq!(vec2p!(true, false).x_ref(), &true);
        assert_eq!(vec3p!(true, false, true).y_ref(), &false);
        assert_eq!(vec4p!(false, true, false, true).z_ref(), &false);

        assert_eq!(vec2p!(true, false).xy_ref(), &vec2p!(true, false),);
        assert_eq!(vec3p!(true, false, true).yz_ref(), &vec2p!(false, true),);
        assert_eq!(
            vec4p!(true, false, true, false).zw_ref(),
            &vec2p!(true, false),
        );

        assert_eq!(
            vec3p!(true, false, true).xyz_ref(),
            &vec3p!(true, false, true),
        );
        assert_eq!(
            vec4p!(true, false, true, false).yzw_ref(),
            &vec3p!(false, true, false),
        );

        assert_eq!(
            vec4p!(true, false, true, false).xyzw_ref(),
            &vec4p!(true, false, true, false),
        );
    }

    #[test]
    fn test_swizzle_mut_packed() {
        assert_eq!(vec2p!(true, false).x_mut(), &mut true);
        assert_eq!(vec3p!(true, false, true).y_mut(), &mut false);
        assert_eq!(vec4p!(false, true, false, true).z_mut(), &mut false);

        assert_eq!(vec2p!(true, false).x_y_mut(), (&mut true, &mut false));
        assert_eq!(
            vec3p!(true, false, true).xy_z_mut(),
            (&mut vec2p!(true, false), &mut true)
        );
        assert_eq!(
            vec4p!(false, true, false, true).xy_zw_mut(),
            (&mut vec2p!(false, true), &mut vec2p!(false, true)),
        );
    }

    #[test]
    fn test_swizzle_with_packed() {
        assert_eq!(vec2p!(true, false).with_x(true), vec2p!(true, false),);
        assert_eq!(
            vec3p!(true, false, true).with_y(false),
            vec3p!(true, false, true),
        );
        assert_eq!(
            vec4p!(false, true, false, true).with_z(true),
            vec4p!(false, true, true, true),
        );

        assert_eq!(
            vec2p!(true, false).with_xy(vec2!(true, false)),
            vec2p!(true, false),
        );
        assert_eq!(
            vec3p!(true, false, true).with_zy(vec2!(false, true)),
            vec3p!(true, true, false),
        );
        assert_eq!(
            vec4p!(false, true, false, true).with_xw(vec2!(true, false)),
            vec4p!(true, true, false, false),
        );

        assert_eq!(
            vec3p!(true, false, true).with_xzy(vec3!(true, false, true)),
            vec3p!(true, true, false),
        );
        assert_eq!(
            vec4p!(false, true, false, true).with_ywx(vec3!(true, false, true)),
            vec4p!(true, true, false, false),
        );

        assert_eq!(
            vec4p!(false, true, false, true).with_xywz(vec4!(true, false, true, false)),
            vec4p!(true, false, false, true),
        );
    }

    #[test]
    fn test_swizzle_set_packed() {
        assert_eq!(
            {
                let mut vector = vec2p!(true, false);
                vector.set_x(true);
                vector
            },
            vec2p!(true, false),
        );
        assert_eq!(
            {
                let mut vector = vec3p!(true, false, true);
                vector.set_y(false);
                vector
            },
            vec3p!(true, false, true),
        );
        assert_eq!(
            {
                let mut vector = vec4p!(false, true, false, true);
                vector.set_z(true);
                vector
            },
            vec4p!(false, true, true, true),
        );

        assert_eq!(
            {
                let mut vector = vec2p!(true, false);
                vector.set_xy(vec2!(true, false));
                vector
            },
            vec2p!(true, false),
        );
        assert_eq!(
            {
                let mut vector = vec3p!(true, false, true);
                vector.set_zy(vec2!(false, true));
                vector
            },
            vec3p!(true, true, false),
        );
        assert_eq!(
            {
                let mut vector = vec4p!(false, true, false, true);
                vector.set_xw(vec2!(true, false));
                vector
            },
            vec4p!(true, true, false, false),
        );

        assert_eq!(
            {
                let mut vector = vec3p!(true, false, true);
                vector.set_xzy(vec3!(true, false, true));
                vector
            },
            vec3p!(true, true, false),
        );
        assert_eq!(
            {
                let mut vector = vec4p!(false, true, false, true);
                vector.set_ywx(vec3!(true, false, true));
                vector
            },
            vec4p!(true, true, false, false),
        );

        assert_eq!(
            {
                let mut vector = vec4p!(false, true, false, true);
                vector.set_xywz(vec4!(true, false, true, false));
                vector
            },
            vec4p!(true, false, false, true),
        );
    }

    #[test]
    fn test_constructor_packed() {
        assert_eq!(vec2p!(true, false).to_array(), [true, false]);
        assert_eq!(vec2p!(vec2p!(true, false)).to_array(), [true, false]);

        assert_eq!(vec3p!(true, false, true).to_array(), [true, false, true]);
        assert_eq!(
            vec3p!(true, vec2p!(false, true)).to_array(),
            [true, false, true]
        );
        assert_eq!(
            vec3p!(vec2p!(true, false), true).to_array(),
            [true, false, true]
        );
        assert_eq!(
            vec3p!(vec3p!(true, false, true)).to_array(),
            [true, false, true]
        );

        assert_eq!(
            vec4p!(true, false, true, false).to_array(),
            [true, false, true, false]
        );
        assert_eq!(
            vec4p!(true, false, vec2p!(true, false)).to_array(),
            [true, false, true, false]
        );
        assert_eq!(
            vec4p!(true, vec2p!(false, true), false).to_array(),
            [true, false, true, false]
        );
        assert_eq!(
            vec4p!(true, vec3p!(false, true, false)).to_array(),
            [true, false, true, false]
        );
        assert_eq!(
            vec4p!(vec2p!(true, false), true, false).to_array(),
            [true, false, true, false]
        );
        assert_eq!(
            vec4p!(vec2p!(true, false), vec2p!(true, false)).to_array(),
            [true, false, true, false]
        );
        assert_eq!(
            vec4p!(vec3p!(true, false, true), false).to_array(),
            [true, false, true, false]
        );
        assert_eq!(
            vec4p!(vec4p!(true, false, true, false)).to_array(),
            [true, false, true, false]
        );
    }
}
