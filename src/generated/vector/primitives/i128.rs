// This file is automatically generated.
// To edit this file edit the codegen crate instead.

use crate::{Usize, vector::*};

impl<const N: usize, A: VecAlignment> Vector<N, i128, A>
where
    Usize<N>: VecLen,
{
    // The following items are generated for all number types

    /// A vector of all minimum values.
    pub const MIN: Self = Self::const_splat(i128::MIN);
    /// A vector of all maximum values.
    pub const MAX: Self = Self::const_splat(i128::MAX);

    /// Converts `self` to a vector of `f32` elements.
    #[inline(always)]
    pub fn as_f32(self) -> Vector<N, f32, A> {
        self.map(|x| x as f32)
    }

    /// Converts `self` to a vector of `f64` elements.
    #[inline(always)]
    pub fn as_f64(self) -> Vector<N, f64, A> {
        self.map(|x| x as f64)
    }

    /// Converts `self` to a vector of `i8` elements.
    #[inline(always)]
    pub fn as_i8(self) -> Vector<N, i8, A> {
        self.map(|x| x as i8)
    }

    /// Converts `self` to a vector of `i16` elements.
    #[inline(always)]
    pub fn as_i16(self) -> Vector<N, i16, A> {
        self.map(|x| x as i16)
    }

    /// Converts `self` to a vector of `i32` elements.
    #[inline(always)]
    pub fn as_i32(self) -> Vector<N, i32, A> {
        self.map(|x| x as i32)
    }

    /// Converts `self` to a vector of `i64` elements.
    #[inline(always)]
    pub fn as_i64(self) -> Vector<N, i64, A> {
        self.map(|x| x as i64)
    }

    /// Converts `self` to a vector of `isize` elements.
    #[inline(always)]
    pub fn as_isize(self) -> Vector<N, isize, A> {
        self.map(|x| x as isize)
    }

    /// Converts `self` to a vector of `u8` elements.
    #[inline(always)]
    pub fn as_u8(self) -> Vector<N, u8, A> {
        self.map(|x| x as u8)
    }

    /// Converts `self` to a vector of `u16` elements.
    #[inline(always)]
    pub fn as_u16(self) -> Vector<N, u16, A> {
        self.map(|x| x as u16)
    }

    /// Converts `self` to a vector of `u32` elements.
    #[inline(always)]
    pub fn as_u32(self) -> Vector<N, u32, A> {
        self.map(|x| x as u32)
    }

    /// Converts `self` to a vector of `u64` elements.
    #[inline(always)]
    pub fn as_u64(self) -> Vector<N, u64, A> {
        self.map(|x| x as u64)
    }

    /// Converts `self` to a vector of `u128` elements.
    #[inline(always)]
    pub fn as_u128(self) -> Vector<N, u128, A> {
        self.map(|x| x as u128)
    }

    /// Converts `self` to a vector of `usize` elements.
    #[inline(always)]
    pub fn as_usize(self) -> Vector<N, usize, A> {
        self.map(|x| x as usize)
    }

    // The following items are generated for all int types

    /// Returns `-self` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_neg(self) -> Option<Self> {
        self.map(|x| x.checked_neg()).flatten()
    }

    /// Returns `self + other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_add(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self[i].checked_add(other[i])).flatten()
    }

    /// Returns `self - other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_sub(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self[i].checked_sub(other[i])).flatten()
    }

    /// Returns `self * other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_mul(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self[i].checked_mul(other[i])).flatten()
    }

    /// Returns `self / other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_div(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self[i].checked_div(other[i])).flatten()
    }

    /// Returns `self % other` or `None` if there is an overflow.
    #[inline(always)]
    pub fn checked_rem(self, other: Self) -> Option<Self> {
        Vector::from_fn(|i| self[i].checked_rem(other[i])).flatten()
    }

    /// Returns `-self` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_neg(self) -> Self {
        self.map(|x| x.wrapping_neg())
    }

    /// Returns `self + other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_add(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].wrapping_add(other[i]))
    }

    /// Returns `self - other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_sub(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].wrapping_sub(other[i]))
    }

    /// Returns `self * other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_mul(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].wrapping_mul(other[i]))
    }

    /// Returns `self / other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_div(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].wrapping_div(other[i]))
    }

    /// Returns `self % other` with wrapping arithmetic.
    #[inline(always)]
    pub fn wrapping_rem(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].wrapping_rem(other[i]))
    }

    /// Returns `self + other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_add(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].saturating_add(other[i]))
    }

    /// Returns `self - other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_sub(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].saturating_sub(other[i]))
    }

    /// Returns `self * other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_mul(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].saturating_mul(other[i]))
    }

    /// Returns `self / other` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_div(self, other: Self) -> Self {
        Vector::from_fn(|i| self[i].saturating_div(other[i]))
    }

    // The following items are generated for all signed number types

    /// Returns a vector containing the absolute value of each element of `self`.
    #[inline(always)]
    pub fn abs(self) -> Self {
        self.map(|x| x.abs())
    }

    // The following items are generated for all signed int types

    /// Returns `-self` with saturating arithmetic.
    #[inline(always)]
    pub fn saturating_neg(self) -> Self {
        Vector::from_fn(|i| self[i].saturating_neg())
    }

    /// Returns a vector containing the signum of each element of `self`.
    /// Signum for each element is:
    /// - `1` if the element is positive
    /// - `-1` if the element is negative
    /// - `0` if the element is zero
    #[inline(always)]
    pub fn signum(self) -> Self {
        self.map(|x| x.signum())
    }
}

impl<const N: usize, A: VecAlignment> Vector<N, i128, A>
where
    Usize<N>: VecLen,
{
    // The following items are generated for all number types

    /// Returns `self + other` and supports const contexts.
    #[inline(always)]
    pub const fn const_add(mut self, other: Vector<N, i128, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] + other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self - other` and supports const contexts.
    #[inline(always)]
    pub const fn const_sub(mut self, other: Vector<N, i128, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] - other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self * other` and supports const contexts.
    #[inline(always)]
    pub const fn const_mul(mut self, other: Vector<N, i128, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] * other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self / other` and supports const contexts.
    #[inline(always)]
    pub const fn const_div(mut self, other: Vector<N, i128, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] / other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self % other` and supports const contexts.
    #[inline(always)]
    pub const fn const_rem(mut self, other: Vector<N, i128, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] % other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self == other` and supports const contexts.
    #[inline(always)]
    pub const fn const_eq(self, other: Vector<N, i128, impl VecAlignment>) -> bool {
        let mut i = 0;
        while i < N {
            if self.as_array()[i] != other.as_array()[i] {
                return false;
            }
            i += 1;
        }
        true
    }

    /// Returns `self != other` and supports const contexts.
    #[inline(always)]
    pub const fn const_ne(self, other: Vector<N, i128, impl VecAlignment>) -> bool {
        let mut i = 0;
        while i < N {
            if self.as_array()[i] != other.as_array()[i] {
                return true;
            }
            i += 1;
        }
        false
    }

    /// Returns `self.eq_mask(other)` and supports const contexts.
    pub const fn const_eq_mask(
        self,
        other: Vector<N, i128, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] == other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.ne_mask(other)` and supports const contexts.
    pub const fn const_ne_mask(
        self,
        other: Vector<N, i128, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] != other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.lt_mask(other)` and supports const contexts.
    pub const fn const_lt_mask(
        self,
        other: Vector<N, i128, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] < other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.gt_mask(other)` and supports const contexts.
    pub const fn const_gt_mask(
        self,
        other: Vector<N, i128, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] > other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.le_mask(other)` and supports const contexts.
    pub const fn const_le_mask(
        self,
        other: Vector<N, i128, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] <= other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.ge_mask(other)` and supports const contexts.
    pub const fn const_ge_mask(
        self,
        other: Vector<N, i128, impl VecAlignment>,
    ) -> Vector<N, bool, A> {
        let mut output = Vector::const_splat(false);
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] >= other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.min(other)` and supports const contexts.
    #[inline(always)]
    pub const fn const_min(mut self, other: Vector<N, i128, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            if other.as_array()[i] < self.as_array()[i] {
                self.as_array_mut()[i] = other.as_array()[i];
            }
            i += 1;
        }
        self
    }

    /// Returns `self.max(other)` and supports const contexts.
    #[inline(always)]
    pub const fn const_max(mut self, other: Vector<N, i128, impl VecAlignment>) -> Self {
        let mut i = 0;
        while i < N {
            if other.as_array()[i] > self.as_array()[i] {
                self.as_array_mut()[i] = other.as_array()[i];
            }
            i += 1;
        }
        self
    }

    /// Returns `self.clamp(min, max)` and supports const contexts.
    #[inline(always)]
    pub const fn const_clamp(
        self,
        min: Vector<N, i128, impl VecAlignment>,
        max: Vector<N, i128, impl VecAlignment>,
    ) -> Self {
        self.const_min(max).const_max(min)
    }

    /// Returns `self.sum()` and supports const contexts.
    #[inline(always)]
    pub const fn const_sum(self) -> i128 {
        let mut output = 0 as i128;
        let mut i = 0;
        while i < N {
            output += self.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.product()` and supports const contexts.
    #[inline(always)]
    pub const fn const_product(self) -> i128 {
        let mut output = 1 as i128;
        let mut i = 0;
        while i < N {
            output *= self.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.dot(other)` and supports const contexts.
    #[inline(always)]
    pub const fn const_dot(self, other: Vector<N, i128, impl VecAlignment>) -> i128 {
        let mut output = 0 as i128;
        let mut i = 0;
        while i < N {
            output += self.as_array()[i] * other.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.mag_sq()` and supports const contexts.
    #[inline(always)]
    pub const fn const_mag_sq(self) -> i128 {
        let mut output = 0 as i128;
        let mut i = 0;
        while i < N {
            output += self.as_array()[i] * self.as_array()[i];
            i += 1;
        }
        output
    }

    /// Returns `self.distance_sq(other)` and supports const contexts.
    #[inline(always)]
    pub const fn const_distance_sq(self, other: Vector<N, i128, impl VecAlignment>) -> i128 {
        self.const_abs_diff(other).const_mag_sq()
    }

    /// Version of `Vector::as_f32` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_f32(self) -> Vector<N, f32, A> {
        let mut output = Vector::<N, f32, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as f32;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_f64` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_f64(self) -> Vector<N, f64, A> {
        let mut output = Vector::<N, f64, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as f64;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i8` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i8(self) -> Vector<N, i8, A> {
        let mut output = Vector::<N, i8, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i8;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i16` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i16(self) -> Vector<N, i16, A> {
        let mut output = Vector::<N, i16, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i16;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i32` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i32(self) -> Vector<N, i32, A> {
        let mut output = Vector::<N, i32, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i32;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_i64` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_i64(self) -> Vector<N, i64, A> {
        let mut output = Vector::<N, i64, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as i64;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_isize` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_isize(self) -> Vector<N, isize, A> {
        let mut output = Vector::<N, isize, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as isize;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_u8` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_u8(self) -> Vector<N, u8, A> {
        let mut output = Vector::<N, u8, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as u8;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_u16` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_u16(self) -> Vector<N, u16, A> {
        let mut output = Vector::<N, u16, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as u16;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_u32` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_u32(self) -> Vector<N, u32, A> {
        let mut output = Vector::<N, u32, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as u32;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_u64` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_u64(self) -> Vector<N, u64, A> {
        let mut output = Vector::<N, u64, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as u64;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_u128` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_u128(self) -> Vector<N, u128, A> {
        let mut output = Vector::<N, u128, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as u128;
            i += 1;
        }
        output
    }

    /// Version of `Vector::as_usize` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_as_usize(self) -> Vector<N, usize, A> {
        let mut output = Vector::<N, usize, A>::GARBAGE;
        let mut i = 0;
        while i < N {
            output.as_array_mut()[i] = self.as_array()[i] as usize;
            i += 1;
        }
        output
    }

    // The following items are generated for all int types

    /// Returns `!self` and supports const contexts.
    #[inline(always)]
    pub const fn const_not(mut self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = !self.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self << other` and supports const contexts.
    #[inline(always)]
    pub const fn const_shl(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] << other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self >> other` and supports const contexts.
    #[inline(always)]
    pub const fn const_shr(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] >> other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self & other` and supports const contexts.
    #[inline(always)]
    pub const fn const_bitand(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] & other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self | other` and supports const contexts.
    #[inline(always)]
    pub const fn const_bitor(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] | other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Returns `self ^ other` and supports const contexts.
    #[inline(always)]
    pub const fn const_bitxor(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i] ^ other.as_array()[i];
            i += 1;
        }

        self
    }

    /// Version of `Vector::checked_neg` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_checked_neg(mut self) -> Option<Self> {
        let mut i = 0;
        while i < N {
            match self.as_array()[i].checked_neg() {
                Some(value) => self.as_array_mut()[i] = value,
                None => return None,
            };

            i += 1;
        }

        Some(self)
    }

    /// Version of `Vector::checked_add` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_checked_add(mut self, other: Self) -> Option<Self> {
        let mut i = 0;
        while i < N {
            match self.as_array()[i].checked_add(other.as_array()[i]) {
                Some(value) => self.as_array_mut()[i] = value,
                None => return None,
            };

            i += 1;
        }

        Some(self)
    }

    /// Version of `Vector::checked_sub` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_checked_sub(mut self, other: Self) -> Option<Self> {
        let mut i = 0;
        while i < N {
            match self.as_array()[i].checked_sub(other.as_array()[i]) {
                Some(value) => self.as_array_mut()[i] = value,
                None => return None,
            };

            i += 1;
        }

        Some(self)
    }

    /// Version of `Vector::checked_mul` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_checked_mul(mut self, other: Self) -> Option<Self> {
        let mut i = 0;
        while i < N {
            match self.as_array()[i].checked_mul(other.as_array()[i]) {
                Some(value) => self.as_array_mut()[i] = value,
                None => return None,
            };

            i += 1;
        }

        Some(self)
    }

    /// Version of `Vector::checked_div` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_checked_div(mut self, other: Self) -> Option<Self> {
        let mut i = 0;
        while i < N {
            match self.as_array()[i].checked_div(other.as_array()[i]) {
                Some(value) => self.as_array_mut()[i] = value,
                None => return None,
            };

            i += 1;
        }

        Some(self)
    }

    /// Version of `Vector::checked_rem` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_checked_rem(mut self, other: Self) -> Option<Self> {
        let mut i = 0;
        while i < N {
            match self.as_array()[i].checked_rem(other.as_array()[i]) {
                Some(value) => self.as_array_mut()[i] = value,
                None => return None,
            };

            i += 1;
        }

        Some(self)
    }

    /// Version of `Vector::wrapping_neg` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_wrapping_neg(mut self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].wrapping_neg();
            i += 1;
        }

        self
    }

    /// Version of `Vector::wrapping_add` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_wrapping_add(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].wrapping_add(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::wrapping_sub` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_wrapping_sub(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].wrapping_sub(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::wrapping_mul` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_wrapping_mul(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].wrapping_mul(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::wrapping_div` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_wrapping_div(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].wrapping_div(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::wrapping_rem` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_wrapping_rem(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].wrapping_rem(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::saturating_add` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_saturating_add(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].saturating_add(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::saturating_sub` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_saturating_sub(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].saturating_sub(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::saturating_mul` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_saturating_mul(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].saturating_mul(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Version of `Vector::saturating_div` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_saturating_div(mut self, other: Self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].saturating_div(other.as_array()[i]);
            i += 1;
        }

        self
    }

    /// Returns `self.abs_diff(other)` and supports const contexts.
    #[inline(always)]
    pub const fn const_abs_diff(self, other: Vector<N, i128, impl VecAlignment>) -> Self {
        self.const_max(other).const_sub(self.const_min(other))
    }

    // The following items are generated for all signed number types

    /// Returns `-self` and supports const contexts.
    #[inline(always)]
    pub const fn const_neg(mut self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = -self.as_array()[i];
            i += 1;
        }

        self
    }

    /// Version of `Vector::abs` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_abs(mut self) -> Self {
        let mut i = 0;

        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].abs();
            i += 1;
        }

        self
    }

    /// Version of `Vector::signum` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_signum(mut self) -> Self {
        let mut i = 0;

        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].signum();
            i += 1;
        }

        self
    }

    // The following items are generated for all signed int types

    /// Version of `Vector::saturating_neg` that can be called from const contexts.
    /// This version may be less performant than the normal version.
    ///
    /// When rust's const capabilities are expanded, this function will be removed.
    #[inline(always)]
    pub const fn const_saturating_neg(mut self) -> Self {
        let mut i = 0;
        while i < N {
            self.as_array_mut()[i] = self.as_array()[i].saturating_neg();
            i += 1;
        }

        self
    }
}

impl ScalarZero for i128 {
    const ZERO: i128 = 0 as Self;
}

impl ScalarOne for i128 {
    const ONE: i128 = 1 as Self;
}

impl ScalarNegOne for i128 {
    const NEG_ONE: i128 = -1 as Self;
}
