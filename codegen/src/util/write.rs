use std::{
    fs::File,
    io::Write,
    path::Path,
    process::{Command, Stdio},
};

use genco::lang::rust::Tokens;
use indoc::formatdoc;

const WORKPLACE_DIR: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/..");
const SRC_DIR: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/../src");
const TESTS_DIR: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/../tests");
const BENCHES_DIR: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/../benches");

pub trait TokensExt {
    fn write_in_src(&self, path_in_src: impl AsRef<Path>);
    fn write_in_tests(&self, path_in_tests: impl AsRef<Path>);
    fn write_in_benches(&self, path_in_benches: impl AsRef<Path>);
}

impl TokensExt for Tokens {
    fn write_in_src(&self, path_in_src: impl AsRef<Path>) {
        assert!(Path::new(SRC_DIR).exists());
        write_with_full_path(self.clone(), &Path::new(SRC_DIR).join(path_in_src));
    }

    fn write_in_tests(&self, path_in_tests: impl AsRef<Path>) {
        assert!(Path::new(TESTS_DIR).exists());
        write_with_full_path(self.clone(), &Path::new(TESTS_DIR).join(path_in_tests));
    }

    fn write_in_benches(&self, path_in_benches: impl AsRef<Path>) {
        assert!(Path::new(BENCHES_DIR).exists());
        write_with_full_path(self.clone(), &Path::new(BENCHES_DIR).join(path_in_benches));
    }
}

fn write_with_full_path(tokens: Tokens, path: &Path) {
    assert!(path.is_absolute());
    assert!(path.extension().unwrap() == "rs");
    assert!(path.starts_with(WORKPLACE_DIR));

    if !path.exists() {
        std::fs::create_dir_all(path.parent().unwrap()).unwrap();
    }

    let generated_content = tokens.to_file_string().unwrap();

    let unformatted_content = formatdoc! {r#"
        // This file was generated by a codegen tool.
        // To modify this file, modify the source code of the codegen tool.

        {generated_content}
    "#};

    let formatted_content = format_rust_code(&unformatted_content);

    if let Ok(existing_content) = std::fs::read_to_string(&path)
        && existing_content == formatted_content
    {
        return;
    }

    let mut file = File::create(path).unwrap();
    file.write_all(formatted_content.as_bytes()).unwrap();
}

fn format_rust_code(unformatted: &str) -> String {
    let mut child = Command::new("rustfmt")
        .arg("--emit")
        .arg("stdout")
        .arg("--edition")
        .arg("2024")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .expect("failed to spawn rustfmt");

    {
        let stdin = child.stdin.as_mut().expect("failed to open stdin");
        stdin
            .write_all(unformatted.as_bytes())
            .expect("write failed");
    }

    let output = child.wait_with_output().expect("failed to wait on rustfmt");

    if output.status.success() {
        String::from_utf8_lossy(&output.stdout).to_string()
    } else {
        eprintln!("rustfmt error: {}", String::from_utf8_lossy(&output.stderr));
        unformatted.to_string()
    }
}
