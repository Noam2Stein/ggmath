use std::{
    fs::File,
    io::{Read, Write},
    path::Path,
    process::{Command, Stdio},
};

use genco::lang::rust::Tokens;
use indoc::formatdoc;

const WORKPLACE_DIR: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/..");
const SRC_DIR: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/../src");
const TESTS_DIR: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/../tests");

pub trait TokensExt {
    fn write_in_src(&self, path_in_src: impl AsRef<Path>);
    fn write_in_tests(&self, path_in_tests: impl AsRef<Path>);
}

impl TokensExt for Tokens {
    fn write_in_src(&self, path_in_src: impl AsRef<Path>) {
        assert!(Path::new(SRC_DIR).exists());
        write_with_full_path(self.clone(), &Path::new(SRC_DIR).join(path_in_src));
    }

    fn write_in_tests(&self, path_in_tests: impl AsRef<Path>) {
        assert!(Path::new(TESTS_DIR).exists());
        write_with_full_path(self.clone(), &Path::new(TESTS_DIR).join(path_in_tests));
    }
}

fn write_with_full_path(tokens: Tokens, path: &Path) {
    assert!(path.is_absolute());
    assert!(path.extension().unwrap() == "rs");
    assert!(path.starts_with(WORKPLACE_DIR));

    if !path.exists() {
        std::fs::create_dir_all(path.parent().unwrap()).unwrap();
    }

    let unformatted_base_content = tokens.to_file_string().unwrap();

    let unformatted_content = formatdoc! {r#"
        // This file was automatically generated by ggmath's codegen tool.
        // Do not modify this file directly!

        {unformatted_base_content}
    "#};

    let content = format_rust_code(&unformatted_content);

    if let Ok(mut existing_file) = File::open(&path) {
        let mut existing_content = String::new();
        existing_file.read_to_string(&mut existing_content).unwrap();

        if existing_content == content && existing_file.metadata().unwrap().permissions().readonly()
        {
            return;
        } else {
            let mut permissions = existing_file.metadata().unwrap().permissions();
            permissions.set_readonly(false);
            existing_file.set_permissions(permissions).unwrap();
        }
    }

    let mut file = File::create(path).unwrap();

    let mut perm = file.metadata().unwrap().permissions();
    perm.set_readonly(true);
    file.set_permissions(perm).unwrap();

    file.write_all(content.as_bytes()).unwrap();
}

fn format_rust_code(unformatted: &str) -> String {
    let mut child = Command::new("rustfmt")
        .arg("--emit")
        .arg("stdout")
        .arg("--edition")
        .arg("2024")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .expect("failed to spawn rustfmt");

    {
        let stdin = child.stdin.as_mut().expect("failed to open stdin");
        stdin
            .write_all(unformatted.as_bytes())
            .expect("write failed");
    }

    let output = child.wait_with_output().expect("failed to wait on rustfmt");

    if output.status.success() {
        String::from_utf8_lossy(&output.stdout).to_string()
    } else {
        eprintln!("rustfmt error: {}", String::from_utf8_lossy(&output.stderr));
        unformatted.to_string()
    }
}
