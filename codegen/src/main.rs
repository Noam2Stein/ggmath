use std::{fmt::Write, ops::RangeInclusive, process::Command};

use const_format::formatcp;
use indoc::writedoc;

mod aabb;
mod matrix;
mod module;
mod primitives;
mod quaternion;
mod vector;
use module::*;

const ROOT_DIR: &str = formatcp!("{}/..", env!("CARGO_MANIFEST_DIR"));
const SRC_DIR: &str = formatcp!("{ROOT_DIR}/src");

const COMPONENTS: &[&str] = &["x", "y", "z", "w"];
const ORDINALS: &[&str] = &["1st", "2nd", "3rd", "4th"];

const MIN_LENGTH: usize = 2;
const MAX_LENGTH: usize = COMPONENTS.len();
const LENGTHS: RangeInclusive<usize> = MIN_LENGTH..=MAX_LENGTH;

fn main() {
    let mut module = ModDir::lib_rs();

    primitives::write_mod(module.submod_dir("primitives"));
    vector::write_mod(module.submod_dir("vector"));
    matrix::write_mod(module.submod_dir("matrix"));
    quaternion::write_mod(module.submod_dir("quaternion"));
    aabb::write_mod(module.submod_dir("aabb"));

    writedoc!(
        module,
        r#"
        #![deny(missing_docs)]
        #![doc = include_str!("../README.md")]

        // This crate is automatically generated by the local `codegen` tool.
        // Changes to the code should be made there, not here.

        mod primitives;
        pub use primitives::*;

        #[cfg(feature = "vector")]
        pub mod vector;
        #[cfg(feature = "vector")]
        pub use vector::*;

        #[cfg(feature = "matrix")]
        pub mod matrix;
        #[cfg(feature = "matrix")]
        pub use matrix::*;

        #[cfg(feature = "quaternion")]
        pub mod quaternion;
        #[cfg(feature = "quaternion")]
        pub use quaternion::*;

        #[cfg(feature = "aabb")]
        pub mod aabb;
        #[cfg(feature = "aabb")]
        pub use aabb::*;

        #[doc(hidden)]
        pub mod _hidden_ {{
            pub use paste::*;
        }}

        /// Is used to implement traits for specific numbers, with the pattern `where Usize<VAL>: Trait`.
        pub struct Usize<const VAL: usize>;

        /// The base trait for mathamatical types.
        ///
        /// Makes sure a type represents data that is always valid and can be copied and sent anywhere.
        /// Is automatically implemented for types that implement its supertraits.
        pub trait Construct: Sized + Send + Sync + Copy + 'static + std::panic::UnwindSafe + std::panic::RefUnwindSafe {{}}

        impl<T: Sized + Send + Sync + Copy + 'static + std::panic::UnwindSafe + std::panic::RefUnwindSafe>
            Construct for T
        {{
        }}
        "#
    )
    .unwrap();

    Command::new("cargo")
        .current_dir(ROOT_DIR)
        .arg("fmt")
        .output()
        .expect("failed to run cargo fmt");

    Command::new("cargo")
        .current_dir(ROOT_DIR)
        .arg("build")
        .output()
        .expect("failed to run cargo build");

    Command::new("cargo")
        .current_dir(ROOT_DIR)
        .arg("test")
        .output()
        .expect("failed to run cargo test");
}

fn join_and(iter: impl Iterator<Item = String>) -> String {
    let mut vec = iter.collect::<Vec<_>>();
    let last = vec.pop();

    if let Some(last) = last {
        if vec.is_empty() {
            last
        } else {
            format!("{} and {last}", vec.join(", "))
        }
    } else {
        String::new()
    }
}

#[expect(unused)]
fn join_or(iter: impl Iterator<Item = String>) -> String {
    let mut vec = iter.collect::<Vec<_>>();
    let last = vec.pop();

    if let Some(last) = last {
        if vec.is_empty() {
            last
        } else {
            format!("{} or {last}", vec.join(", "))
        }
    } else {
        String::new()
    }
}
