use std::{
    fs::{File, read_dir, remove_dir_all, remove_file},
    io::Write,
    path::Path,
    process::{Command, Stdio},
};

use genco::lang::rust::Tokens;
use indoc::formatdoc;

use crate::module::WORKPLACE_DIR;

#[derive(Debug, Clone)]
pub struct RawFile {
    pub name: String,
    pub content: ModContent,
}

#[derive(Debug, Clone)]
pub struct RawDir {
    pub name: String,
    pub content: ModContent,
    pub submod_files: Vec<RawFile>,
    pub submod_dirs: Vec<RawDir>,
}

#[derive(Debug, Clone)]
pub struct ModContent {
    pub tokens: Tokens,
}

impl RawFile {
    pub fn export(self, parent_path: &Path) {
        let path = parent_path.join(&self.name).with_extension("rs");
        self.content.export(path);
    }
}

impl RawDir {
    pub fn export(self, parent_path: &Path, file_name: impl Into<String>) {
        let dir_path = parent_path.join(&self.name);
        let modrs_path = dir_path.join(file_name.into()).with_extension("rs");

        for entry in read_dir(&dir_path)
            .into_iter()
            .flatten()
            .map(|entry| entry.unwrap())
        {
            if entry.path() == modrs_path {
                continue;
            }

            let entry_name_path = entry.path().with_extension("");
            let entry_name = entry_name_path.file_name().unwrap().to_str().unwrap();

            if self.submod_files.iter().any(|file| file.name == entry_name) {
                continue;
            }

            if self.submod_dirs.iter().any(|dir| dir.name == entry_name) {
                continue;
            }

            if entry.path().is_dir() {
                remove_dir_all(entry.path()).unwrap();
            } else {
                remove_file(entry.path()).unwrap();
            }
        }

        self.content.export(modrs_path);

        for submod_file in self.submod_files {
            submod_file.export(&dir_path);
        }

        for submod_dir in self.submod_dirs {
            submod_dir.export(&dir_path, "mod");
        }
    }
}

impl ModContent {
    fn export(self, path: impl AsRef<Path>) {
        let path = path.as_ref();

        assert!(path.is_absolute());
        assert!(path.extension().unwrap() == "rs");
        assert!(path.starts_with(Path::new(WORKPLACE_DIR)));

        if !path.exists() {
            std::fs::create_dir_all(path.parent().unwrap()).unwrap();
        }

        let generated_content = self.tokens.to_file_string().unwrap();

        let unformatted_content = formatdoc! {r#"
            // This file was generated by a codegen tool.
            // To modify this file, modify the source code of the codegen tool.

            {generated_content}
        "#};

        let formatted_content = format_rust_code(&unformatted_content);

        if let Ok(existing_content) = std::fs::read_to_string(&path)
            && existing_content == formatted_content
        {
            return;
        }

        let mut file = File::create(path).unwrap();
        file.write_all(formatted_content.as_bytes()).unwrap();
    }
}

fn format_rust_code(unformatted: &str) -> String {
    let mut child = Command::new("rustfmt")
        .arg("--emit")
        .arg("stdout")
        .arg("--edition")
        .arg("2024")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .expect("failed to spawn rustfmt");

    {
        let stdin = child.stdin.as_mut().expect("failed to open stdin");
        stdin
            .write_all(unformatted.as_bytes())
            .expect("write failed");
    }

    let output = child.wait_with_output().expect("failed to wait on rustfmt");

    if output.status.success() {
        String::from_utf8_lossy(&output.stdout).to_string()
    } else {
        eprintln!("rustfmt error: {}", String::from_utf8_lossy(&output.stderr));
        unformatted.to_string()
    }
}
